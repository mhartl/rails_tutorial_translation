<div id="top"></div>


<h1 class="chapter"><a id="sec:6" href="modeling-and-viewing-users-one#top" class="heading"><span class="number">Глава 6</span> Моделирование и просмотр пользователей, часть I</a></h1>


<p><a class="ref" href="filling-in-the-layout#top">Главу&nbsp;5</a>, мы закончили заглушкой страницы для создания новых пользователей (<a class="ref" href="filling-in-the-layout#sec:user_signup">Раздел&nbsp;5.3</a>); в течение следующих трех глав мы выполним обещание, неявное в этой начинающейся странице регистрации. Первый важный шаг это создание <em>модели данных</em> для пользователей нашего сайта, вместе со способом хранить эти данные. Завершение этой задачи является целью для ближайших двух глав, и мы дадим пользователям возможность зарегистрироваться в системе в  <a class="ref" href="sign-up#top">Главе&nbsp;8</a>.  Как только пример приложения сможет создавать новых пользователей, мы позволим им входить и выходить (<a class="ref" href="sign-in-sign-out#top">Глава&nbsp;9</a>), и в <a class="ref" href="updating-showing-and-deleting-users#top">Главе&nbsp;10</a> (<a class="ref" href="updating-showing-and-deleting-users#sec:protecting_pages">Раздел&nbsp;10.2</a>) мы узнаем, как защитить страницы от несанкцонированного доступа.</p>

<p>Взятые вместе, материалы с <a class="ref" href="modeling-and-viewing-users-one#top">Главы&nbsp;6</a> по <a class="ref" href="updating-showing-and-deleting-users#top">Главу&nbsp;10</a> разрабатывают полную Rails систему входа и аутентификации. Как вы знаете, там, в стране Rails, есть различные готовые решения для аутентификации; <a class="ref" href="modeling-and-viewing-users-one#sidebar:roll_your_own">Блок&nbsp;6.1</a> объясняет, почему (по крайней мере, сначала) это - хорошая идея - прикрутить свою собственную.</p>

<div class="label" id="sidebar:roll_your_own"></div>


<div class="sidebar"><span class="title"><span class="header">Блок 6.1.</span><span class="description">Прикручивание собственной  системы аутентификации.</span></span>
<p>Фактически всем веб-приложениям в настоящее время требуется какая либо система входа и аутентификации. Неудивительно, что у большинства веб-фреймворков есть множество вариантов реализации подобных систем, и Rails не исключение. Примеры систем аутентификации и авторизации включают в себя <a href="http://github.com/thoughtbot/clearance">Clearance</a>, <a href="http://github.com/binarylogic/authlogic">Authlogic</a>, <a href="http://github.com/plataformatec/devise">Devise</a>, и <a href="http://railscasts.com/episodes/192-authorization-with-cancan">CanCan</a> (так же как не-Rails-специфичные решения, построенные на <a href="http://en.wikipedia.org/wiki/OpenID">OpenID</a> или <a href="http://en.wikipedia.org/wiki/Oauth">OAuth</a>). Разумно спросить, почему мы должны повторно изобретать колесо. Почему бы просто не использовать стандартное решение вместо того, чтобы прикручивать собственное?</p>

<p>Есть несколько причин, почему создание нашей собственной системы аутентификации является хорошей идеей. Во-первых, стандартного решения для аутентификации в Rails не существует; а привязав учебник к какому либо конкретному проекту мы рискуем тем, что выбранный проект может выйти из моды или устареть. Кроме того, даже если бы мы угадали, то кодовая база проекта продолжала бы развиваться, тем самым превращая учебник в устаревший хлам. Наконец, представление всей машинерии аутентификации сразу было бы педагогическим бедствием - к примеру, Clearance содержит более чем 1 000 строк кода и создает сложную модель данных с самого начала. Системы аутентификации - захватывающее и богатое программированием упражнение; прикручивание нашего собственного означает, что мы можем рассматривать одну маленькую часть за один раз, что приведет к намного более глубокому пониманию - и аутентификации и Rails.</p>

<p>Я призываю вас изучить&nbsp;<a class="ref" href="modeling-and-viewing-users-one#top">6</a>&nbsp;-&nbsp;<a class="ref" href="updating-showing-and-deleting-users#top">10</a> главы чтобы дать себе хорошую основу для будущих проектов. Если вам однажды случится  использовать стандартную систему аутентификации для своих собственных приложений, то вы будете в хорошей позиции чтобы понять и адаптировать его под ваши потребности.</p>
</div>


<p>Параллельно с нашим моделированием данных мы также разработаем веб-страницу для того, чтобы показать пользователя, которая будет служить первым шагом к реализации архитектуры REST для пользователей (вкратце обсуждается в  <a class="ref" href="a-demo-app#sec:mvc_in_action">Разделе&nbsp;2.2.2</a>). Хотя мы не будем заходить так далеко в этой главе, наша конечная цель для страниц профиля пользователя состоит в том, чтобы показать аватар пользователя, основные данные пользователя, и список микросообщений, как на макете в <a class="ref" href="modeling-and-viewing-users-one#fig:profile_mockup">Рис.&nbsp;6.1</a>.<sup class="footnote" id="fnref:6.1"><a href="#fn:6.1">1</a></sup> (<a class="ref" href="modeling-and-viewing-users-one#fig:profile_mockup">Рис.&nbsp;6.1</a> содержит наш первый пример <em>lorem ipsum</em> текста, который имеет <a href="http://www.straightdope.com/columns/read/2290/what-does-the-filler-text-lorem-ipsum-mean">захватывающую историю</a> и ее определенно стоит прочитать в свободное время.) В этой главе, мы положим начало странице, показывающей пользователя, и мы начнем заполнять ее деталями, начиная с <a class="ref" href="modeling-and-viewing-users-two#top">Главы&nbsp;7</a>.</p>

<div class="label" id="fig:profile_mockup"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/profile_mockup.png" alt="profile_mockup" /></span></div><div class="caption"><span class="header">Рисунок  6.1: </span><span class="description">Макет страницы просмотра пользователя.&nbsp;<a href="http://railstutorial.org/images/figures/profile_mockup-full.png">(полный размер)</a></span></div></div>


<p>Как обычно, если вы продолжаете использовать Git для управления версиями, сейчас было бы хорошее время, чтобы сделать отдельную тему ветки для моделировния пользователей:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> git checkout master
<span class="gp">$</span> git checkout -b modeling-users
</pre></div>
</div>


<p>(Первая строка здесь только для того чтобы удостовериться, что вы находитесь на master ветке, чтобы тема ветки <tt>modeling-users</tt> была основана на <tt>master</tt> ветке. Можно пропустить эту команду, если вы уже находитесь на master ветке.)</p>

<div class="label" id="sec:user_model"></div>


<h2><a id="sec:6.1" href="modeling-and-viewing-users-one#sec:user_model" class="heading"><span class="number">6.1</span> Модель User</a></h2>


<p>Хотя конечная цель следующих трех глав это создание страницы регистрации для нашего сайта, в принятии регистрационной информации сейчас хорошего мало, так нам в настоящий момент попросту негде ее хранить. Таким образом, первый шаг в регистрации пользователей должен создать структуру данных, для получения и хранения их информации. В Rails дефолтную структуру данных для модели данных называют, что достаточно естественно, <em>модель</em> (М. в MVC из <a class="ref" href="beginning#sec:mvc">Раздела&nbsp;1.2.6</a>). Дефолтное решение Rails для проблемы персистентности состоит в том, чтобы использовать <em>базу данных</em> для долгосрочного хранения данных, и дефолтную библиотеку <em>Active Record</em> для взаимодействия с базой данных.<sup class="footnote" id="fnref:6.2"><a href="#fn:6.2">2</a></sup></p>

<p>Active Record идет с массой методов для создания, хранения и поиска объектов данных и все они без необходимости использовать язык структурированных запросов (SQL)<sup class="footnote" id="fnref:6.3"><a href="#fn:6.3">3</a></sup> применяемый <a  href="http://ru.wikipedia.org/wiki/Реляционная_база_данных">реляционными базами данных</a>. Кроме того, у Rails есть функции, называемые <em>миграциями</em> которые позволяют писать определения данных на чистом Ruby, без необходимости изучать язык определения данных (DDL).<sup class="footnote" id="fnref:6.4"><a href="#fn:6.4">4</a></sup> Как результат,  Rails почти полностью изолирует вас от деталей хранения данных. В этой книге, благодаря использованию SQLite для разработки и Heroku для развертывания (<a class="ref" href="beginning#sec:deploying">Раздел&nbsp;1.4</a>), мы проработали эту тему еще дальше, до точки, где нам едва ли когда-нибудь придется задумываться о том, как Rails хранит данные, даже для рабочих приложений.<sup class="footnote" id="fnref:6.5"><a href="#fn:6.5">5</a></sup></p>

<div class="label" id="sec:database_migrations"></div>


<h3><a id="sec:6.1.1" href="modeling-and-viewing-users-one#sec:database_migrations" class="heading"><span class="number">6.1.1</span> Миграции базы данных</a></h3>


<p>Можно вспомнить из <a class="ref" href="rails-flavored-ruby#sec:a_user_class">Раздела&nbsp;4.4.5</a>, что мы уже встречали, в сделанном нами классе <code>User</code> объекты user с атрибутами <code>name</code> и <code>email</code>. Тот класс служил полезным примером, но он испытывал недостаток в критическом свойстве <em>персистентности</em>: когда мы создали объект User в консоли Rails, он исчез, как только мы вышли. Наша цель в этом Разделе состоит в том, чтобы создать модель для пользователей, которые не будут исчезать так легко.</p>

<p>Как и с классом User в <a class="ref" href="rails-flavored-ruby#sec:a_user_class">Разделе&nbsp;4.4.5</a>, мы начнем с моделирования пользователя с двумя атрибутами: <code>name</code> и <code>email</code>, последний мы будем использовать в качестве уникального имени пользователя.<sup class="footnote" id="fnref:6.6"><a href="#fn:6.6">6</a></sup> (Мы добавим атрибут пароля в <a class="ref" href="modeling-and-viewing-users-two#sec:insecure_passwords">Разделе&nbsp;7.1</a>.) В <a class="ref" href="rails-flavored-ruby#code:example_user">Листинге&nbsp;4.8</a>мы сделали это с помощью Ruby-метода <code>attr_accessor</code>:</p>

<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span>
  <span class="kp">attr_accessor</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div>


<p>Напротив, при использовании Rails, чтобы смоделировать пользователей мы не должны идентифицировать атрибуты явно. Как было кратко отмечено выше, для хранения данных Rails  по умолчанию использует реляционные базы данных, которые состоят из <em>таблиц</em> составленных из <em>строк</em>, данных, где у каждой строки есть <em>столбцы</em> атрибутов данных. Например, для того, чтобы сохранить пользователей с именами и адресами электронной почты, мы составим таблицу <code>users</code> со столбцами <code>name</code> и <code>email</code> (с каждой строкой, соответствующей одному пользователю). Называя столбцы таким образом, мы позволим Active Record выводить атрибуты объектов User для нас.</p>

<p>Давайте посмотрим, как это работает. (Если это обсуждение становится слишком абстрактным на ваш взгляд, будьте терпеливы; консольные примеры, начинающиеся в <a class="ref" href="modeling-and-viewing-users-one#sec:creating_user_objects">Разделе&nbsp;6.1.3</a> и скриншоты браузера базы данных в <a class="ref" href="modeling-and-viewing-users-one#fig:sqlite_database_browser">Рис.&nbsp;6.3</a> и <a class="ref" href="modeling-and-viewing-users-one#fig:sqlite_user_row">Рис.&nbsp;6.8</a> должны многое прояснить.) Вспомните из <a class="ref" href="filling-in-the-layout#sec:users_controller">Раздела&nbsp;5.3.1</a>  (<a class="ref" href="filling-in-the-layout#code:generate_users_controller">Листинг&nbsp;5.23</a>), что мы создавали контроллер  Users  (наряду с <code>new</code> действием) используя команду</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> rails generate controller Users new
</pre></div>
</div>


<p>Есть аналогичная команда для создания модели: <code>generate model</code>; <a class="ref" href="modeling-and-viewing-users-one#code:generate_user_model">Листинг&nbsp;6.1</a> показывает команду для генерации модели User с двумя атрибутами, <code>name</code> и <code>email</code>.</p>

<div class="label" id="code:generate_user_model"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.1.</span> <span class="description">Генерирование модели User.</span> </div>
<div class="code"><div class="highlight"><pre><span class="gp">$</span> rails generate model User name:string email:string
<span class="go">      invoke  active_record</span>
<span class="go">      create    db/migrate/&lt;timestamp&gt;_create_users.rb</span>
<span class="go">      create    app/models/user.rb</span>
<span class="go">      invoke    rspec</span>
<span class="go">      create      spec/models/user_spec.rb</span>
</pre></div>
</div></div>


<p>(Обратите внимание, что, в отличие от множественного соглашения для имен контроллеров, названия моделей - в ед. числе: контроллер Users, но модель User.) Передавая дополнительные параметры <code>name:string</code> и <code>email:string</code>, мы говорим Rails о двух желаемых атрибутах, наряду с тем, какого типа эти атрибуты должны быть (в данном случае, <code>string</code>). Сравните это с включением имен действий в <a class="ref" href="static-pages#code:generating_pages">Листинге&nbsp;3.4</a> и <a class="ref" href="filling-in-the-layout#code:generate_users_controller">Листинге&nbsp;5.23</a>.</p>

<p>Одним из результатов <code>generate</code> команды в  <a class="ref" href="modeling-and-viewing-users-one#code:generate_user_model">Листинге&nbsp;6.1</a> является новый файл, названный <em>migration</em>.  Миграции обеспечивают возможность постепенного изменения структуры базы данных, так, чтобы наша модель данных могла адаптироваться к изменяющимся требованиям. В случае модели User, миграция создается автоматически сценарием генерации модели; что создает таблицу <code>users</code> с двумя столбцами, <code>name</code> и <code>email</code>, как это показано в <a class="ref" href="modeling-and-viewing-users-one#code:users_migration">Листинге&nbsp;6.2</a>. (Мы увидим в <a class="ref" href="modeling-and-viewing-users-one#sec:uniqueness_validation">Разделе&nbsp;6.2.4</a> как сделать миграцию с нуля.)</p>

<div class="label" id="code:users_migration"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.2.</span> <span class="description">Миграция для модели User (создающая таблицу <code>users</code>) <br /> <code>db/migrate/&lt;timestamp&gt;_create_users.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CreateUsers</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">up</span>
    <span class="n">create_table</span> <span class="ss">:users</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="o">.</span><span class="n">string</span> <span class="ss">:name</span>
      <span class="n">t</span><span class="o">.</span><span class="n">string</span> <span class="ss">:email</span>

      <span class="n">t</span><span class="o">.</span><span class="n">timestamps</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">down</span>
    <span class="n">drop_table</span> <span class="ss">:users</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Обратите внимание, что имя миграции снабжается префиксом с <em>временнОй отметкой</em>, обозначающей время когда была сгенерирована миграция. В первые дни миграций, имена файлов снабжались префиксом из постепенно увеличивающихся целых чисел, что приводило к конфликтам внутри команд разработчиков, при совпадении номеров миграций у разных программистов. Барьер, использующий временнЫе метки и опирающийся на невозможность сценария при котором миграции будут сгенерированы одновременно, с точностью до секунды,  помогает легко избегать таких коллизий.</p>

<p>Давайте сосредоточимся на <code>self.up</code> методе, который использует метод Rails, называемый <code>create_table</code> чтобы создать <em>таблицу</em> в базе данных для хранения пользователей. (Использование <code>self (сам)</code> в <code>self.up</code> идентифицирует его как <em>метод класса</em>. Это не имеет значения сейчас, но мы узнаем о методах класса, когда сделаем собственный в  <a class="ref" href="modeling-and-viewing-users-two#sec:an_authenticate_method">Разделе&nbsp;7.2.4</a>.) <code>Сreate_table</code> метод принимает блок (<a class="ref" href="rails-flavored-ruby#sec:blocks">Раздел&nbsp;4.3.2</a>) с одной блоковой переменной, в данном случае названной <code>t</code> (от &ldquo;tаблица&rdquo;). Внутри блока <code>create_table</code> метод использует <code>t</code>&nbsp;объект для создания <code>name</code> и <code>email</code> столбцов в базе данных, оба типа <code>string</code>.<sup class="footnote" id="fnref:6.7"><a href="#fn:6.7">7</a></sup> Здесь имя таблицы является множественным (<code>users</code>) даже при том, что название модели в ед. числе (User), что отражает лингвистическое соглашение которому следует Rails: модель представляет единственного (отдельного) пользователя, тогда как таблица базы данных состоит из многих пользователей. Заключительная строка в блоке, <code>t.timestamps</code>, является специальной командой, которая создает два <em>волшебных столбца</em>, называемые <code>created_at</code> и <code>updated_at</code>, которые являются временнЫми отметками, которые автоматически записывают, когда данный пользователь создается и обновляется. (Мы увидим конкретные примеры волшебных столбцов в <a class="ref" href="modeling-and-viewing-users-one#sec:creating_user_objects">Разделе&nbsp;6.1.3</a>.) Полная модель данных, представленная этой миграцией, показана в <a class="ref" href="modeling-and-viewing-users-one#fig:user_model_initial">Рис.&nbsp;6.2</a>.</p>

<div class="label" id="fig:user_model_initial"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/user_model_initial.png" alt="user_model_initial" /></span></div><div class="caption"><span class="header">Рисунок  6.2: </span><span class="description">Модель данных "пользователи", произведенная <a class="ref" href="modeling-and-viewing-users-one#code:users_migration">Листингом&nbsp;6.2</a>.</span></div></div>


<p>Мы можем запустить миграцию, известную как &ldquo;migrating up&rdquo;, используя команду <code>rake</code> (<a class="ref" href="a-demo-app#sidebar:rake">Блок&nbsp;2.1</a>) следующим образом:<sup class="footnote" id="fnref:6.8"><a href="#fn:6.8">8</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rake db:migrate
</pre></div>
</div>

<p>(Можно вспомнить, что мы запускали эту команду прежде, в <a class="ref" href="beginning#sec:rails_server">Разделе&nbsp;1.2.5</a> и еще раз в <a class="ref" href="a-demo-app#top">Главе&nbsp;2</a>.) При первом запуске <code>db:migrate</code> она создает файл <code>db/development.sqlite3</code>, который является базой данных <a href="http://sqlite.org/">SQLite</a><sup class="footnote" id="fnref:6.9"><a href="#fn:6.9">9</a></sup> Мы можем увидеть структуру базы данных, используя превосходный <a href="http://sqlitebrowser.sourceforge.net/">SQLite Database Browser</a> чтобы открыть файл <code>db/development.sqlite3</code> (<a class="ref" href="modeling-and-viewing-users-one#fig:sqlite_database_browser">Рис.&nbsp;6.3</a>); сравните со схемой в  <a class="ref" href="modeling-and-viewing-users-one#fig:user_model_initial">Рис.&nbsp;6.2</a>.  Вы могли отметить, что есть один столбец в <a class="ref" href="modeling-and-viewing-users-one#fig:sqlite_database_browser">Рис.&nbsp;6.3</a> неучтенный в миграции: столбец <code>id</code>. Как было вкратце отмечено в <a class="ref" href="a-demo-app#sec:demo_users_resource">Разделе&nbsp;2.2</a>, этот столбец создается автоматически, и используется Rails в качестве уникального идентификатора каждой строки.</p>

<div class="label" id="fig:sqlite_database_browser"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/sqlite_database_browser.png" alt="sqlite_database_browser" /></span></div><div class="caption"><span class="header">Рисунок  6.3: </span><span class="description"><a href="http://sqlitebrowser.sourceforge.net/">SQLite Database Browser</a> с нашей новой <code>users</code> таблицей.&nbsp;<a href="http://railstutorial.org/images/figures/sqlite_database_browser-full.png">(полный размер)</a></span></div></div>


<p>Вы, вероятно, заметили, что запуск <code>db:migrate</code> выполняет <code>self.up</code> команду в файле миграции. Что, тогда делает <code>self.down</code>? Как вы могли бы предположить, <code>down</code> миграции <em>down</em>, ликвидируя последствия migrating up. В нашем случае это означает <em>сброс</em>  <code>users</code> таблицы в базе данных:</p>

<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CreateUsers</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">down</span>
    <span class="n">drop_table</span> <span class="ss">:users</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>


<p>Вы можете выполнить <code>down</code> с <code>rake</code> используя аргумент <code>db:rollback</code>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rake db:rollback
</pre></div>
</div>


<p>Это часто бывает полезным, если вы понимаете, что есть другой столбец, который вы хотите добавить, но при этом не желаете связываться с новой миграцией: можно откатить миграцию, добавить требуемый столбец, и затем мигрировать back up. (Это не всегда удобно, и мы узнаем, как добавить столбцы к существующей таблице в <a class="ref" href="modeling-and-viewing-users-two#sec:password_migration">Разделе&nbsp;7.1.2</a>.)</p>

<p>Если вы откатывали базу данных, migrate up снова перед продолжением:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rake db:migrate
</pre></div>
</div>




<div class="label" id="sec:the_model_file"></div>


<h3><a id="sec:6.1.2" href="modeling-and-viewing-users-one#sec:the_model_file" class="heading"><span class="number">6.1.2</span> Файл модели</a></h3>


<p>Мы видели, как генерация модели User в  <a class="ref" href="modeling-and-viewing-users-one#code:generate_user_model">Листинге&nbsp;6.1</a> сгенерировала файл миграции (<a class="ref" href="modeling-and-viewing-users-one#code:users_migration">Листинг&nbsp;6.2</a>) и мы видели в <a class="ref" href="modeling-and-viewing-users-one#fig:sqlite_database_browser">Рис.&nbsp;6.3</a> результаты выполнения этой миграции: это обновило файл <code>development.sqlite3</code>, создав таблицу <code>users</code> со столбцами <code>id</code>, <code>name</code>, <code>email</code>, <code>created_at</code> и <code>updated_at</code>. <a class="ref" href="modeling-and-viewing-users-one#code:generate_user_model">Листинг&nbsp;6.1</a> также создал саму модель; остальная часть этого раздела посвящена ее изучению.</p>

<p>Мы начнем с рассмотрения кода для модели User, которая живет в файле <code>user.rb</code> в каталоге <code>app/models/</code> это, мягко выражаясь, очень компактно (<a class="ref" href="modeling-and-viewing-users-one#code:raw_user_model">Листинг&nbsp;6.3</a>).</p>

<div class="label" id="code:raw_user_model"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.3.</span> <span class="description">Совершенно новая модель User. <br /> <code>app/models/user.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Вспомните из <a class="ref" href="rails-flavored-ruby#sec:a_class_of_our_own">Раздела&nbsp;4.4.2</a> что синтаксис <code>class User &lt; ActiveRecord::Base</code> означает, что класс <code>User</code>  <em>наследует</em> от <code>ActiveRecord::Base</code>, таким образом у модели User автоматически есть вся функциональность <code>ActiveRecord::Base</code> класса. Конечно, знание этого наследования не приносит пользы, если мы не знаем что содержит <code>ActiveRecord::Base</code> и мы это узнаем через мгновение. Прежде, чем мы двинемся дальше, тем не менее, необходимо закончить с двумя задачами.</p>

<div class="label" id="sec:model_annotation"></div>


<h4><a id="sec:6.1.2.1" href="modeling-and-viewing-users-one#sec:model_annotation" class="heading">Аннотация модели</a></h4>


<p>Хотя это и не является строго необходимым, вы могли бы счесть удобным <em>аннотировать</em> ваши Rails модели, используя <tt>annotate</tt> гем  (<a class="ref" href="modeling-and-viewing-users-one#code:gemfile_annotate">Листинг&nbsp;6.4</a>).</p>

<div class="label" id="code:gemfile_annotate"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.4.</span> <span class="description">Добавление <tt>annotate</tt> гема в <code>Gemfile</code>.</span>
</div>
<div class="code"><div class="highlight"><pre><span class="n">source</span> <span class="s1">&#39;http://rubygems.org&#39;</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="n">group</span> <span class="ss">:development</span> <span class="k">do</span>
  <span class="n">gem</span> <span class="s1">&#39;rspec-rails&#39;</span><span class="p">,</span> <span class="s1">&#39;2.6.1&#39;</span>
  <span class="n">gem</span> <span class="s1">&#39;annotate&#39;</span><span class="p">,</span> <span class="s1">&#39;2.4.0&#39;</span>
<span class="k">end</span>

<span class="n">group</span> <span class="ss">:test</span> <span class="k">do</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>(Мы поместили <tt>annotate</tt> gem в блок <code>group :development</code> (аналогичный <code>group :test</code>) потому что аннотации не нужны  в production  приложениях.) Затем мы устанавливаем его с <code>bundle</code>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle install
</pre></div>
</div>


<p>Это дает нам команду <code>annotate</code>, которая просто добавляет комментарии, содержащие модель данных к файлу модели:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>annotate --position before
<span class="go">Annotated (1): User</span>
</pre></div>
</div>


<p>Результат представлен в <a class="ref" href="modeling-and-viewing-users-one#code:annotated_user_model">Листинге&nbsp;6.5</a>.</p>

<div class="label" id="code:annotated_user_model"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.5.</span> <span class="description">Аннотированная модель User. <br /> <code>app/models/user.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="c1"># == Schema Information</span>
<span class="c1">#</span>
<span class="c1"># Table name: users</span>
<span class="c1">#</span>
<span class="c1">#  id         :integer         not null, primary key</span>
<span class="c1">#  name       :string(255)</span>
<span class="c1">#  email      :string(255)</span>
<span class="c1">#  created_at :datetime</span>
<span class="c1">#  updated_at :datetime</span>
<span class="c1">#</span>

<span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
<span class="k">end</span>
</pre></div>
</div></div>




<p>Наличие модели данных, видимой в файлах модели, помогает мне вспомнить, какие атрибуты имеет модель, но будущие листинги кода будут обычно опускать аннотации для краткости.</p>

<div class="label" id="sec:accessible_attributes"></div>


<h4><a id="sec:6.1.2.2" href="modeling-and-viewing-users-one#sec:accessible_attributes" class="heading">Доступные атрибуты</a></h4>


<p>Другой необязательный, но полезный шаг должен сказать Rails, какие атрибуты модели доступны, то есть, какие атрибуты могут быть изменены внешними пользователями (такими как пользователи, подающие запросы с интернет браузера). Мы сделаем это с <code>attr_accessible</code> методом (<a class="ref" href="modeling-and-viewing-users-one#code:attr_accessible">Листинг&nbsp;6.6</a>). Мы увидим в  <a class="ref" href="updating-showing-and-deleting-users#top">Главе&nbsp;10</a> что использование <code>attr_accessible</code> важно для предотвращения уязвимости <a href="http://www.rusrails.ru/ruby-on-rails-security-guide/mass-assignment"><em>массового назначения</em></a>, к сожалению распространенной и часто серьезной дыре в системе безопасности во многих Rails приложениях.</p>

<div class="label" id="code:attr_accessible"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.6.</span> <span class="description">Листинг 6.6.</span> <span class="description">Открытие доступа к <code>name</code> и <code>email</code> атрибутам. <br /> <code>app/models/user.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>
<span class="k">end</span>
</pre></div>
</div></div>




<div class="label" id="sec:creating_user_objects"></div>


<h3><a id="sec:6.1.3" href="modeling-and-viewing-users-one#sec:creating_user_objects" class="heading"><span class="number">6.1.3</span> Создание объектов user</a></h3>


<p>Мы проделали хорошую подготовительную работу, и теперь пора воспользоваться ее результатами и узнать об Active Record, играя с нашей недавно созданной моделью User. Как и  в  <a class="ref" href="rails-flavored-ruby#top">Главе&nbsp;4</a>, наш инструмент - консоль Rails. Так как мы (пока) не хотим производить какие либо изменения в нашей базе данных, мы запустим консоль в <em>sandbox (песочнице)</em>:</p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console --sandbox</span>
<span class="go">Loading development environment in sandbox (Rails 3.0.9)</span>
<span class="go">Any modifications you make will be rolled back on exit</span>
<span class="gp">&gt;&gt; </span>
</pre></div>
</div>


<p>Как обозначено полезным сообщением “Любые модификации которые вы сделаете откатятся при выходе”, при работе в песочнице, консоль будет "откатывать" (то есть, отменять) любые изменения базы данных, созданные во время сеанса.</p>

<p>Работая в консоли, полезно следить за <em>development log</em>, который записывает актуальные низкоуровневые операторы SQL, выдаваемые Active Record, как показано в <a class="ref" href="modeling-and-viewing-users-one#fig:development_log">Рис.&nbsp;6.4</a>. Для того, чтобы получить этот вывод в командной строке Unix выполните команду:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> tail -f log/development.log
</pre></div>
</div>


<p>Флаг <code>-f</code> гарантирует, что <code>tail</code> выведет на экран дополнительные строки, по мере их написания. Я рекомендую оставить открытым окно терминала для того, чтобы следить за журналом, работая в консоли.</p>

<div class="label" id="fig:development_log"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/development_log.png" alt="development_log" /></span></div><div class="caption"><span class="header">Рисунок  6.4: </span><span class="description">Слежение за development log.&nbsp;<a href="http://railstutorial.org/images/figures/development_log-full.png">(полный размер)</a></span></div></div>


<p>В консольной сессии в <a class="ref" href="rails-flavored-ruby#sec:a_user_class">Разделе&nbsp;4.4.5</a>, мы создали новый объект user с <code>User.new</code>, к которому у нас был доступ только после запроса файла example user  в <a class="ref" href="rails-flavored-ruby#code:example_user">Листинге&nbsp;4.8</a>. С моделями ситуация иная; как можно вспомнить из <a class="ref" href="rails-flavored-ruby#sec:a_controller_class">Раздела&nbsp;4.4.4</a>, консоль Rails автоматически загружает среду Rails, которая включает модели. Это означает, что мы можем просто сделать новый объект пользователя:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">new</span>
<span class="go">=&gt; #&lt;User id: nil, name: nil, email: nil, created_at: nil, updated_at: nil&gt;</span>
</pre></div>
</div>


<p>Мы видим здесь дефолтное консольное представление объекта user, которое печатает те же самые атрибуты что и показанные в <a class="ref" href="modeling-and-viewing-users-one#fig:sqlite_database_browser">Рис.&nbsp;6.3</a> и <a class="ref" href="modeling-and-viewing-users-one#code:annotated_user_model">Листинге&nbsp;6.5</a>.</p>

<p>Вызванный без параметров, <code>User.new</code> возвращает объект с <code>nil</code> атрибутами. В <a class="ref" href="rails-flavored-ruby#sec:a_user_class">Разделе&nbsp;4.4.5</a>, мы спроектировали пример класса User таким образом, чтобы он принимал <em>инициализационный хэш</em> для установки атрибутов объекта; такое решение было обусловлено библиотекой Active Record, которая позволяет инициализировать объекты тем же способом:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Michael Hartl&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;mhartl@example.com&quot;</span><span class="p">)</span>
<span class="go">=&gt; #&lt;User id: nil, name: &quot;Michael Hartl&quot;, email: &quot;mhartl@example.com&quot;,</span>
<span class="go">created_at: nil, updated_at: nil&gt;</span>
</pre></div>
</div>


<p>Здесь мы видим, что, как и ожидалось, атрибуты имени и адреса электронной почты были установлены.</p>

<p>Если вы следили за development log, вы, возможно, заметили, что новые строки еще не обнаружились. Это связано с тем, что вызов <code>User.new</code> не касается базы данных; он просто создает новый Ruby объект в памяти. Чтобы сохранить объект user в базе данных, мы вызовем метод <code>save</code> на переменной <code>user</code>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">save</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>Метод <code>save</code>возвращает <code>true</code> если сохранение успешно выполнилось и <code>false</code> если сохранение не выполнено. (Сейчас все сохранения, должны успешно выполняться; но в <a class="ref" href="modeling-and-viewing-users-one#sec:user_validations">Разделе&nbsp;6.2</a> мы увидим случаи, когда некоторые из них не сработают.), После сохранения в development log должна появиться строка с командой SQL <code>INSERT INTO "users"</code>. Из-за множества методов, предоставляемых Active Record, в этой книге нам не потребуется необработанный SQL, и я опущу обсуждение команд SQL с этого времени. Но вы можете многому научиться, наблюдая за development log.</p>

<p>Вы, возможно, заметили, что у нового объекта  user  были <code>nil</code> значения для атрибутов <code>id</code> и волшебных столбцов <code>created_at</code> и <code>updated_at</code>. Давайте посмотрим, изменило ли наше <code>save</code> что-нибудь:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span>
<span class="go">=&gt; #&lt;User id: 1, name: &quot;Michael Hartl&quot;, email: &quot;mhartl@example.com&quot;,</span>
<span class="go">created_at: &quot;2010-01-05 00:57:46&quot;, updated_at: &quot;2010-01-05 00:57:46&quot;&gt;</span>
</pre></div>
</div>


<p>Мы видим, что <code>id</code> было присвоено значение&nbsp;<code>1</code>, в то время как волшебным столбцам были присвоены текущие время и дата.<sup class="footnote" id="fnref:6.10"><a href="#fn:6.10">10</a></sup> В настоящий момент, метки "создан" (created) и "обновлен" (updated) идентичны; мы увидим, что они отличаются в <a class="ref" href="modeling-and-viewing-users-one#sec:updating_user_objects">Разделе&nbsp;6.1.5</a>.</p>

<p>Как и с классом User в <a class="ref" href="rails-flavored-ruby#sec:a_user_class">Разделе&nbsp;4.4.5</a>, экземпляры модели User предоставляют доступ к своим атрибутам, используя точку:<sup class="footnote" id="fnref:6.11"><a href="#fn:6.11">11</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">name</span>
<span class="go">=&gt; &quot;Michael Hartl&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">email</span>
<span class="go">=&gt; &quot;mhartl@example.com&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">updated_at</span>
<span class="go">=&gt; Tue, 05 Jan 2010 00:57:46 UTC +00:00</span>
</pre></div>
</div>


<p>Как мы увидим в <a class="ref" href="sign-up#top">Главе&nbsp;8</a>, часто бывает удобно создать и сохранить модель в два приема, как мы это сделали выше, но Active Record также позволяет вам объединить эти действия в один шаг с <code>User.create</code>:</p>


<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;A Nother&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;another@example.org&quot;</span><span class="p">)</span>
<span class="go">=&gt; #&lt;User id: 2, name: &quot;A Nother&quot;, email: &quot;another@example.org&quot;, created_at:</span>
<span class="go">&quot;2010-01-05 01:05:24&quot;, updated_at: &quot;2010-01-05 01:05:24&quot;&gt;</span>
<span class="gp">&gt;&gt; </span><span class="n">foo</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Foo&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;foo@bar.com&quot;</span><span class="p">)</span>
<span class="go">=&gt; #&lt;User id: 3, name: &quot;Foo&quot;, email: &quot;foo@bar.com&quot;, created_at: &quot;2010-01-05</span>
<span class="go">01:05:42&quot;, updated_at: &quot;2010-01-05 01:05:42&quot;&gt;</span>
</pre></div>
</div>


<p>Обратите внимание, что <code>User.create</code>, вместо того, чтобы возвратить <code>true</code> или <code>false</code>, возвращает сам объект User который мы можем дополнительно присвоить переменной (такой как <code>foo</code> во второй команде выше).</p>

<p>Команда, обратная <code>create</code> это <code>destroy</code>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">foo</span><span class="o">.</span><span class="n">destroy</span>
<span class="go">=&gt; #&lt;User id: 3, name: &quot;Foo&quot;, email: &quot;foo@bar.com&quot;, created_at: &quot;2010-01-05</span>
<span class="go">01:05:42&quot;, updated_at: &quot;2010-01-05 01:05:42&quot;&gt;</span>
</pre></div>
</div>


<p>Странно, <code>destroy</code>, как и <code>create</code>, возвращает рассматриваемый объект, хотя я не могу вспомнить что когда-либо использовал значение, возвращаемое <code>destroy</code>. Еще более странно то, что <code>destroy</code>енный объект все еще существует в памяти:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">foo</span>
<span class="go">=&gt; #&lt;User id: 3, name: &quot;Foo&quot;, email: &quot;foo@bar.com&quot;, created_at: &quot;2010-01-05</span>
<span class="go">01:05:42&quot;, updated_at: &quot;2010-01-05 01:05:42&quot;&gt;</span>
</pre></div>
</div>


<p>Как мы узнаем, уничтожили ли мы в действительности объект? И как мы можем получить сохраненные и неуничтоженные объекты user из базы данных? Пора узнать, как использовать Active Record, для поиска объектов user.</p>

<div class="label" id="sec:finding_user_objects"></div>


<h3><a id="sec:6.1.4" href="modeling-and-viewing-users-one#sec:finding_user_objects" class="heading"><span class="number">6.1.4</span> Поиск объектов user</a></h3>


<p>Active Record предоставляет несколько способов поиска объектов. Давайте используем их, для того, чтобы найти первого пользователя, которого мы создали, и чтобы проверить, что третий пользователь (<code>foo</code>) был уничтожен. Мы начнем с существующего пользователя:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">=&gt; #&lt;User id: 1, name: &quot;Michael Hartl&quot;, email: &quot;mhartl@example.com&quot;,</span>
<span class="go">created_at: &quot;2010-01-05 00:57:46&quot;, updated_at: &quot;2010-01-05 00:57:46&quot;&gt;</span>
</pre></div>
</div>


<p>Здесь мы передали id пользователя в <code>User.find</code>; Active Record вернула пользователя с этим атрибутом <code>id</code>.</p>

<p>Давайте посмотрим, существует ли пользователь с <code>id</code>&nbsp;<code>3</code> в базе данных:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">ActiveRecord::RecordNotFound: Couldn&#39;t find User with ID=3</span>
</pre></div>
</div>


<p>Так как мы уничтожили нашего третьего пользователя в  <a class="ref" href="modeling-and-viewing-users-one#sec:creating_user_objects">Разделе&nbsp;6.1.3</a>, Active Record не может найти его в базе данных. Вместо этого <code>find</code> вызывает <em>exception (исключение)</em>, которое является способом указать на исключительное событие при выполнении программы, в данном случае, несуществующий Active Record id вызывает исключение <code>ActiveRecord::RecordNotFound</code>.<sup class="footnote" id="fnref:6.12"><a href="#fn:6.12">12</a></sup></p>

<p>В дополнение к универсальному <code>find</code>, Active Record также позволяет нам искать пользователей по определенным атрибутами:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">find_by_email</span><span class="p">(</span><span class="s2">&quot;mhartl@example.com&quot;</span><span class="p">)</span>
<span class="go">=&gt; #&lt;User id: 1, name: &quot;Michael Hartl&quot;, email: &quot;mhartl@example.com&quot;,</span>
<span class="go">created_at: &quot;2010-01-05 00:57:46&quot;, updated_at: &quot;2010-01-05 00:57:46&quot;&gt;</span>
</pre></div>
</div>


<p>Так как мы будем использовать адреса электронной почты в качестве имен пользователей, этот вид поиска будет полезен, когда мы узнаем, как позволить пользователям регистрироваться на нашем сайте (<a class="ref" href="sign-up#top">Глава&nbsp;8</a>).<sup class="footnote" id="fnref:6.13"><a href="#fn:6.13">13</a></sup></p>

<p>Мы закончим несколькими более общими способами поиска пользователей. Во-первых, <code>first</code>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">first</span>
<span class="go">=&gt; #&lt;User id: 1, name: &quot;Michael Hartl&quot;, email: &quot;mhartl@example.com&quot;,</span>
<span class="go">created_at: &quot;2010-01-05 00:57:46&quot;, updated_at: &quot;2010-01-05 00:57:46&quot;&gt;</span>
</pre></div>
</div>


<p>Естественно, <code>first</code> просто возвращает первого пользователя в базе данных. Есть также <code>all</code>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">all</span>
<span class="go">=&gt; [#&lt;User id: 1, name: &quot;Michael Hartl&quot;, email: &quot;mhartl@example.com&quot;,</span>
<span class="go">created_at: &quot;2010-01-05 00:57:46&quot;, updated_at: &quot;2010-01-05 00:57:46&quot;&gt;,</span>
<span class="go">#&lt;User id: 2, name: &quot;A Nother&quot;, email: &quot;another@example.org&quot;, created_at:</span>
<span class="go">&quot;2010-01-05 01:05:24&quot;, updated_at: &quot;2010-01-05 01:05:24&quot;&gt;]</span>
</pre></div>
</div>


<p>Не сюрприз, что <code>all</code> возвращает массив (<a class="ref" href="rails-flavored-ruby#sec:arrays_and_ranges">Раздел&nbsp;4.3.1</a>) всех пользователей в базе данных.</p>

<div class="label" id="sec:updating_user_objects"></div>


<h3><a id="sec:6.1.5" href="modeling-and-viewing-users-one#sec:updating_user_objects" class="heading"><span class="number">6.1.5</span> Обновление объектов user</a></h3>


<p>После создания объектов, мы часто хотим обновить их. Есть два основных способа сделать это. Во-первых, мы можем присвоить атрибуты индивидуально, как мы это делали в  <a class="ref" href="rails-flavored-ruby#sec:a_user_class">Разделе&nbsp;4.4.5</a>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span>           <span class="c1"># Just a reminder about our user&#39;s attributes</span>
<span class="go">=&gt; #&lt;User id: 1, name: &quot;Michael Hartl&quot;, email: &quot;mhartl@example.com&quot;,</span>
<span class="go">created_at: &quot;2010-01-05 00:57:46&quot;, updated_at: &quot;2010-01-05 00:57:46&quot;&gt;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="s2">&quot;mhartl@example.net&quot;</span>
<span class="go">=&gt; &quot;mhartl@example.net&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">save</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>Обратите внимание, что заключительный шаг необходим, для того чтобы записать изменения в базу данных. Мы можем увидеть, что произойдет без сохранения, используя <code>reload</code>, которая перезагружает объекты, опираясь на информацию в базе данных:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">email</span>
<span class="go">=&gt; &quot;mhartl@example.net&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="s2">&quot;foo@bar.com&quot;</span>
<span class="go">=&gt; &quot;foo@bar.com&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">reload</span><span class="o">.</span><span class="n">email</span>
<span class="go">=&gt; &quot;mhartl@example.net&quot;</span>
</pre></div>
</div>


<p>Теперь, когда мы обновили пользователя, волшебные столбцы отличаются, как и обещалось в <a class="ref" href="modeling-and-viewing-users-one#sec:creating_user_objects">Разделе&nbsp;6.1.3</a>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">created_at</span>
<span class="go">=&gt; &quot;2010-01-05 00:57:46&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">updated_at</span>
<span class="go">=&gt; &quot;2010-01-05 01:37:32&quot;</span>
</pre></div>
</div>


<p>Второй способ обновить атрибуты заключается в использовании <code>update_attributes</code>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">update_attributes</span><span class="p">(</span><span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;The Dude&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;dude@abides.org&quot;</span><span class="p">)</span>
<span class="go">=&gt; true</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">name</span>
<span class="go">=&gt; &quot;The Dude&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">email</span>
<span class="go">=&gt; &quot;dude@abides.org&quot;</span>
</pre></div>
</div>


<p><code>Update_attributes</code> метод принимает хеш атрибутов, и в случае успеха выполняет и обновление и сохранение за один шаг (возвращающая <code>true</code> чтобы указать, что сохранение произошло). Стоит отметить, что, после того как вы определили некоторые атрибуты как доступные, используя <code>attr_accessible</code>  (<a class="ref" href="modeling-and-viewing-users-one#sec:accessible_attributes">Раздел&nbsp;6.1.2.2</a>), <em>только</em> эти атрибуты могут быть включены в вызов <code>update_attributes</code>. Если вы когда-либо обнаружите, что ваши модели загадочным образом начинают отказываться обновлять определенные столбцы, удостоверьтесь, что эти столбцы включаются в вызов <code>attr_accessible</code>.</p>

<div class="label" id="sec:user_validations"></div>


<h2><a id="sec:6.2" href="modeling-and-viewing-users-one#sec:user_validations" class="heading"><span class="number">6.2</span> Валидации User</a></h2>


<p>У модели User, которую мы создали в  <a class="ref" href="modeling-and-viewing-users-one#sec:user_model">Разделе&nbsp;6.1</a> теперь есть рабочие атрибуты <code>name</code> и <code>email</code>, но они абсолютно универсальны: любая строка (включая пустую) в настоящий момент допустима. И все же, имена и адреса электронной почты это нечто более определенное. Например, <code>name</code> не должно быть пробелом, <code>email</code> должен соответствовать определенному формату, характерному для адресов электронной почты. Кроме того, так как мы будем использовать адреса электронной почты в качестве уникальных имен пользователей при регистрации, мы не должны позволять дублироваться адресам электронной почты в базе данных.</p>

<p>Короче говоря, мы не должны позволить <code>name</code> и <code>email</code> быть просто любыми строками; мы должны реализовать определенные ограничения для их значений. Active Record позволяет нам налагать такие ограничения, с помощью <a  rel="nofollow" href="http://ru.wikipedia.org/wiki/Валидация"><em>validations</em></a>. В этом разделе мы рассмотрим несколько из наиболее распространенных случаев, применив валидации для <em>наличия</em>, <em>длины</em>, <em>формата</em> и <em>уникальностьи</em>. В <a class="ref" href="modeling-and-viewing-users-two#sec:password_validations">Разделе&nbsp;7.1.1</a> мы добавим заключительную общепринятую валидацию, <em>подтверждение</em>. И мы увидим в <a class="ref" href="sign-up#sec:signup_failure">Разделе&nbsp;8.2</a> как валидации дают нам удобные сообщения об ошибках, когда пользователи предоставляют данные, которые нарушают их.</p>

<p>Как и с другими функциями нашего примера приложения, мы добавим валидации модели User, используя разработку через тестирование. Так как мы изменили модель данных, хорошей идеей будет подготовить тестовую базу данных перед продолжением:</p>


<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rake db:test:prepare
</pre></div>
</div>


<p>Это просто обеспечивает отражение модели данных из базы данных разработки, <code>db/development.sqlite3</code>,  в тестовой базе данных, <code>db/test.sqlite3</code>.</p>

<div class="label" id="sec:presence_validation"></div>


<h3><a id="sec:6.2.1" href="modeling-and-viewing-users-one#sec:presence_validation" class="heading"><span class="number">6.2.1</span> Валидация наличия</a></h3>


<p>Мы начнем с теста для наличия атрибута <code>name</code>. Хотя первым шагом в TDD должно быть написание <em>провального</em> теста (<a class="ref" href="static-pages#sec:TDD">Раздел&nbsp;3.2.2</a>), в данном случае мы еще не достаточно знаем  о валидациях, чтобы написать надлежащий тест, таким образом, мы сначала напишем валидацию, используя консоль, чтобы понять ее. Затем мы закомментируем валидацию, напишем провальный тест, и проверим, что раскомментирование валидации позволяет тесту пройти. Эта процедура может казаться излишне педантичной для такого простого теста, но я видел<sup class="footnote" id="fnref:6.14"><a href="#fn:6.14">14</a></sup> <em>много</em> &ldquo;простых&rdquo; тестов которые тестируют неправильную вещь; дотошность в TDD это <em>единственный</em> способ, позволяющий быть уверенными, в том что мы тестируем правильную вещь. (Этот метод комментария также полезен при спасении приложения, код  которого уже написан, но&mdash;<a href="http://en.wiktionary.org/wiki/quelle_horreur"><em>quelle horreur!</em></a>&mdash;(# какой ужас - фр.) не имеет тестов.)</p>

<p>Способ валидации наличия атрибута имени заключается в применении метода <code>validates</code> с аргументом <code>:presence =&gt; true</code>, как показано в <a class="ref" href="modeling-and-viewing-users-one#code:validates_presence_of_name">Листинге&nbsp;6.7</a>. <code>:presence =&gt; true</code> аргумент является одноэлементным <em>хэшем опций</em>; вспомните из <a class="ref" href="rails-flavored-ruby#sec:css_revisited">Раздела&nbsp;4.3.4</a> что фигурные скобки являются необязательными при передаче хеша в качестве последнего аргумента в методе. (Как отмечено в <a class="ref" href="filling-in-the-layout#sec:adding_to_the_layout">Разделе&nbsp;5.1.1</a>, использование хэшэй опций это очень распространенный прием в Rails.)</p>

<div class="label" id="code:validates_presence_of_name"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.7.</span> <span class="description">Валидация наличия <code>name</code> атрибута. <br /> <code>app/models/user.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>

  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:presence</span> <span class="o">=&gt;</span> <span class="kp">true</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Как вкратце обсуждалось в <a class="ref" href="a-demo-app#sec:putting_the_micro_in_microposts">Разделе&nbsp;2.3.2</a>, использование <code>validates</code> характерно для Rails&nbsp;3. (В Rails&nbsp;2.3, мы написали бы <code>validates_presence_of :name</code> вместо этого.)</p>

<p><a class="ref" href="modeling-and-viewing-users-one#code:validates_presence_of_name">Листинг&nbsp;6.7</a> может быть похожим на волшебство, но <code>validates</code> только метод, как и  <code>attr_accessible</code>. Эквивалентная <a class="ref" href="modeling-and-viewing-users-one#code:validates_presence_of_name">Листингу&nbsp;6.7</a> формулировка  с использованием круглых скобок:</p>

<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">attr_accessible</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span><span class="p">)</span>

  <span class="n">validates</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">:presence</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>


<p>Давайте заскочим в консоль, чтобы увидеть эффект добавления валидации к нашей модели User:<sup class="footnote" id="fnref:6.15"><a href="#fn:6.15">15</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console --sandbox</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;mhartl@example.com&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">save</span>
<span class="go">=&gt; false</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">valid?</span>
<span class="go">=&gt; false</span>
</pre></div>
</div>


<p>Здесь <code>user.save</code> возвращает <code>false</code>, указывая на провальное сохранение. В заключительной команде мы используем <code>valid?</code> метод, который возвращает <code>false</code> когда объект приводит к сбою одной или более валидаций, и <code>true</code> когда все валидации проходят. (Вспомните из <a class="ref" href="rails-flavored-ruby#sec:objects_and_message_passing">Раздела&nbsp;4.2.3</a> что Ruby использует вопросительный знак, чтобы указать на такие истинные/ложные <em>булевы</em> методы.) В данном случае у нас есть только одна валидация, таким образом, мы знаем, какая именно провалилась, но все же не лишним будет в этом убедиться с помощью объекта <code>errors</code>, генерируемого при отказе:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">full_messages</span>
<span class="go">=&gt; [&quot;Name can&#39;t be blank&quot;]</span>
</pre></div>
</div>


<p>(Сообщение об ошибке - подсказка, что Rails проверяет наличие атрибута, используя <code>blank?</code> метод, который мы видели в конце  <a class="ref" href="rails-flavored-ruby#sec:modifying_built_in_classes">Раздела&nbsp;4.4.3</a>.)</p>

<p>Теперь о провальном тесте. Чтобы гарантировать, что наш начинающийся тест перестанет работать, давайте закомментируем валидацию (<a class="ref" href="modeling-and-viewing-users-one#code:commented_out_validation">Листинг&nbsp;6.8</a>).</p>

<div class="label" id="code:commented_out_validation"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.8.</span> <span class="description">Закомментирование валидации для обеспечения провальности теста. <br /> <code>app/models/user.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>

  <span class="c1"># validates :name, :presence =&gt; true</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Как и  в случае генерации контроллера (например, в <a class="ref" href="filling-in-the-layout#code:generate_users_controller">Листинге&nbsp;5.23</a>), model generate команда в <a class="ref" href="modeling-and-viewing-users-one#code:generate_user_model">Листинге&nbsp;6.1</a> производит начальный spec для того, чтобы протестировать пользователей, но в данном случае он фактически пуст (<a class="ref" href="modeling-and-viewing-users-one#code:default_user_spec">Листинг&nbsp;6.9</a>).</p>

<div class="label" id="code:default_user_spec"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.9.</span> <span class="description">Практически пустой дефолтный User spec. <br /> <code>spec/models/user_spec.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>
  <span class="n">pending</span> <span class="s2">&quot;add some examples to (or delete) </span><span class="si">#{</span><span class="bp">__FILE__</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Это просто использует метод <code>pending</code> ("ожидающий решения") чтобы указать, что мы должны заполнить spec чем-то полезным. Мы можем увидеть его эффект запустив User model spec:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rspec spec/models/user_spec.rb
<span class="go">*</span>


<span class="go">Finished in 0.01999 seconds</span>
<span class="go">1 example, 0 failures, 1 pending</span>

<span class="go">Pending:</span>
<span class="go">  User add some examples to (or delete)</span>
<span class="go">  /Users/mhartl/rails_projects/sample_app/spec/models/user_spec.rb</span>
<span class="go">  (Not Yet Implemented)</span>
</pre></div>
</div>


<p>Мы последуем совету дефолтного spec, заполнив его некоторыми примерами RSpec, показанными в  <a class="ref" href="modeling-and-viewing-users-one#code:raw_user_spec">Листинге&nbsp;6.10</a>.</p>

<div class="label" id="code:raw_user_spec"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.10.</span> <span class="description">Начальный user spec. <br /> <code>spec/models/user_spec.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span> <span class="k">do</span>
    <span class="vi">@attr</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;user@example.com&quot;</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="n">it</span> <span class="s2">&quot;should create a new instance given valid attributes&quot;</span> <span class="k">do</span>
    <span class="no">User</span><span class="o">.</span><span class="n">create!</span><span class="p">(</span><span class="vi">@attr</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">it</span> <span class="s2">&quot;should require a name&quot;</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Мы последний раз видели <code>require</code> и <code>describe</code> в <a class="ref" href="filling-in-the-layout#code:user_signup_spec">Листинге&nbsp;5.28</a>. Следующая строка это <code>before(:each)</code> block; это было описано кратко в упражнении (<a class="ref" href="static-pages#code:pages_controller_spec_exercise">Листинг&nbsp;3.33</a>), и единственное, что он делает, это запуск кода в блоке перед каждым примером, в данном случае, он запускает код устанавливающий <code>@attr</code> переменную экземпляра в хеше инициализации.</p>

<p>Первый пример - только проверка работоспособности, проверяющая, что модель User является в основном рабочей. Здесь используется <code>User.create!</code> (читайте &ldquo;create bang&rdquo;), который работает точно так же как <code>create</code> метод, который мы видели в <a class="ref" href="modeling-and-viewing-users-one#sec:creating_user_objects">Разделе&nbsp;6.1.3</a> отличаясь лишь тем, что он вызывает исключение <code>ActiveRecord::RecordInvalid</code> если <code>create</code> перестало работать (подобно <code>ActiveRecord::RecordNotFound</code> которое мы видели в <a class="ref" href="modeling-and-viewing-users-one#sec:finding_user_objects">Разделе&nbsp;6.1.4</a>). Пока атрибуты валидны, это не будет вызывать исключений, и тесты будут проходить.</p>

<p>Заключительная строка это тест для наличия атрибута <code>name</code> или, скорее, это <em>было бы</em> тестом, если бы в ней что нибудь было. Вместо этого тест это лишь заглушка, но полезная заглушка: это <em>pending spec</em> ("ожидающий spec"), который является способом написать описание поведения приложения, не волнуясь пока о реализации.  <a class="ref" href="modeling-and-viewing-users-one#code:default_user_spec">Листинг&nbsp;6.9</a> показывает пример ожидающего spec, используя явный вызов <code>pending</code> метода; в данном случае, так как мы включали только&nbsp;<code>it</code> часть примера,</p>

<div class="code"><div class="highlight"><pre><span class="n">it</span> <span class="s2">&quot;should require a name&quot;</span>
</pre></div>
</div>


<p>RSpec делает вывод о существовании ожидающего spec (теста).</p>

<p>Ожидающие тесты хорошо обрабатываются программами для запуска тестов, как видно для Автотеста в <a class="ref" href="modeling-and-viewing-users-one#fig:autotest_pending_spec">Рис.&nbsp;6.5</a>, (к <code>rspec spec/</code> это тоже относится). Ожидающие тесты полезны как заглушки для тестов, о которых мы знаем, что должны их написать в какой-то момент, но не хотим иметь с ними дело прямо сейчас.</p>

<div class="label" id="fig:autotest_pending_spec"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/autotest_pending_spec.png" alt="autotest_pending_spec" /></span></div><div class="caption"><span class="header">Рисунок  6.5: </span><span class="description">Autotest (через <code>autotest</code>) с ожидающим User тестом.&nbsp;<a href="http://railstutorial.org/images/figures/autotest_pending_spec-full.png">(полный размер)</a></span></div></div>


<p>Чтобы заполнить ожидающий тест, мы нуждаемся в способе который сделает хэш атрибутов с недопустимым именем. (Хэш <code>@attr</code> валиден по определению, с не-чистым <code>name</code> атрибутом.) <code>Hash</code> метод <code>merge</code> добивается цели, как мы можем увидеть в <code>rails console</code>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="vi">@attr</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;user@example.com&quot;</span> <span class="p">}</span>
<span class="go">=&gt; {:name =&gt; &quot;Example User&quot;, :email =&gt; &quot;user@example.com&quot;}</span>
<span class="gp">&gt;&gt; </span><span class="vi">@attr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="go">=&gt; {:name =&gt; &quot;&quot;, :email =&gt; &quot;user@example.com&quot;}</span>
</pre></div>
</div>


<p>С <code>merge</code> в руке мы готовы сделать новый spec (использующий прием, который я объясню через мгновение), как видно в <a class="ref" href="modeling-and-viewing-users-one#code:failing_validates_name_spec">Листинг&nbsp;6.11</a>.</p>

<div class="label" id="code:failing_validates_name_spec"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.11.</span> <span class="description">Провальный тест валидации <code>name</code> атрибута. <br /> <code>spec/models/user_spec.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span> <span class="k">do</span>
    <span class="vi">@attr</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;user@example.com&quot;</span> <span class="p">}</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">it</span> <span class="s2">&quot;should require a name&quot;</span> <span class="k">do</span>
    <span class="n">no_name_user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="vi">@attr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
    <span class="n">no_name_user</span><span class="o">.</span><span class="n">should_not</span> <span class="n">be_valid</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Здесь мы используем <code>merge</code> чтобы сделать нового пользователя названного <code>no_name_user</code> с пустым именем. Вторая строка затем использует RSpec метод <code>should_not</code>, чтобы проверить, что получающийся пользователь <em>не</em> валиден. Прием, на который я ссылался выше, связан с <code>be_valid</code>: мы знаем из этого раздела, что объект User отвечает на булев метод <code>valid?</code>. RSpec принимает полезное соглашение разрешая нам протестировать <em>любой</em> булев метод, отбрасывая вопросительный знак и подставив <code>be_</code>. Другими словами,</p>

<div class="code"><div class="highlight"><pre><span class="n">no_name_user</span><span class="o">.</span><span class="n">should_not</span> <span class="n">be_valid</span>
</pre></div>
</div>


<p>эквивалентно</p>

<div class="code"><div class="highlight"><pre><span class="n">no_name_user</span><span class="o">.</span><span class="n">valid?</span><span class="o">.</span><span class="n">should_not</span> <span class="o">==</span> <span class="kp">true</span>
</pre></div>
</div>


<p>Так как это звучит более похожим, на естественный язык, написание <code>should_not be_valid</code> является определенно более идиоматически корректным RSpec.</p>

<p>С этим наш новый тест должен быть провальным, что мы можем проверить с Автотестом или запустив <code>user_spec.rb</code> файл, используя скрипт <code>spec</code>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rspec spec/models/user_spec.rb
<span class="go">.F</span>

<span class="go">1)</span>
<span class="go">'User should require a name' FAILED</span>
<span class="go">expected valid? to return false, got true</span>
<span class="go">./spec/models/user_spec.rb:14:</span>

<span class="go">2 examples, 1 failure</span>
</pre></div>
</div>


<p>Теперь раскомментируйте валидацию (т.е., вернитесь от <a class="ref" href="modeling-and-viewing-users-one#code:commented_out_validation">Листинга&nbsp;6.8</a> обратно к <a class="ref" href="modeling-and-viewing-users-one#code:validates_presence_of_name">Листингу&nbsp;6.7</a>) чтобы заставить тест пройти:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rspec spec/models/user_spec.rb
<span class="go">..</span>

<span class="go">2 examples, 0 failures</span>
</pre></div>
</div>


<p>Конечно, мы также хотим валидировать наличие адресов электронной почты. Тест (<a class="ref" href="modeling-and-viewing-users-one#code:validates_email_spec">Листинг&nbsp;6.12</a>) походит на аналогичный тест для атрибута <code>name</code>.</p>

<div class="label" id="code:validates_email_spec"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.12.</span> <span class="description">Тест для наличия атрибута <code>email</code>.<br /> <code>spec/models/user_spec.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span> <span class="k">do</span>
    <span class="vi">@attr</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;user@example.com&quot;</span> <span class="p">}</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">it</span> <span class="s2">&quot;should require an email address&quot;</span> <span class="k">do</span>
    <span class="n">no_email_user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="vi">@attr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
    <span class="n">no_email_user</span><span class="o">.</span><span class="n">should_not</span> <span class="n">be_valid</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Реализация практически та же, что и в <a class="ref" href="modeling-and-viewing-users-one#code:validates_presence_of_email">Листинге&nbsp;6.13</a>.</p>

<div class="label" id="code:validates_presence_of_email"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.13.</span> <span class="description">Валидация наличия атрибутов <code>name</code> и <code>email</code>.<br /> <code>app/models/user.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>

  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span>  <span class="ss">:presence</span> <span class="o">=&gt;</span> <span class="kp">true</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:presence</span> <span class="o">=&gt;</span> <span class="kp">true</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Теперь все тесты должны проходить, и валидации &ldquo;наличия&rdquo; готовы.</p>

<div class="label" id="sec:length_validation"></div>


<h3><a id="sec:6.2.2" href="modeling-and-viewing-users-one#sec:length_validation" class="heading"><span class="number">6.2.2</span> Валидация длины</a></h3>


<p>Мы ограничили нашу модель User требованием имени для каждого пользователя, но мы должны пойти еще дальше: имена пользователей будут отображаться на  сайте, таким образом, мы должны будем реализовать некоторое ограничение их длины. С работой, проделанной в <a class="ref" href="modeling-and-viewing-users-one#sec:presence_validation">Разделе&nbsp;6.2.1</a>, этот шаг легок.</p>

<p>Мы начнем с теста. В выборе максимальной длины нет ничего хитрого; мы просто примем&nbsp;<code>50</code> как разумную верхнюю границу, что означает, что имена длиной в&nbsp;<code>51</code> символ будут слишком длинными (<a class="ref" href="modeling-and-viewing-users-one#code:length_validation_test">Листинг&nbsp;6.14</a>).</p>

<div class="label" id="code:length_validation_test"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.14.</span> <span class="description">Тест для валидации длины <code>name</code>. <br /> <code>spec/models/user_spec.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span> <span class="k">do</span>
    <span class="vi">@attr</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;user@example.com&quot;</span> <span class="p">}</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">it</span> <span class="s2">&quot;should reject names that are too long&quot;</span> <span class="k">do</span>
    <span class="n">long_name</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span> <span class="o">*</span> <span class="mi">51</span>
    <span class="n">long_name_user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="vi">@attr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="ss">:name</span> <span class="o">=&gt;</span> <span class="n">long_name</span><span class="p">))</span>
    <span class="n">long_name_user</span><span class="o">.</span><span class="n">should_not</span> <span class="n">be_valid</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Для удобства мы использовали &ldquo;мультипликацию строки&rdquo; в <a class="ref" href="modeling-and-viewing-users-one#code:length_validation_test">Листинге&nbsp;6.14</a> для создания строки длиной в 51 символ. Мы можем увидеть как это работает, используя консоль:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span> <span class="o">*</span> <span class="mi">51</span>
<span class="go">=&gt; &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">length</span>
<span class="go">=&gt; 51</span>
</pre></div>
</div>


<p>Тест в <a class="ref" href="modeling-and-viewing-users-one#code:length_validation_test">Листинге&nbsp;6.14</a> должен провалиться. Чтобы заставить его пройти, мы должны знать об аргументе валидации, ограничивающим длину, <code>:length</code>, наряду с <code>:maximum</code> параметром реализуют верхнюю границу (<a class="ref" href="modeling-and-viewing-users-one#code:length_validation">Листинг&nbsp;6.15</a>).</p>

<div class="label" id="code:length_validation"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.15.</span> <span class="description">Добавление валидации длины для <code>name</code> атрибута.<br /> <code>app/models/user.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>

  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span>  <span class="ss">:presence</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
                    <span class="ss">:length</span>   <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:maximum</span> <span class="o">=&gt;</span> <span class="mi">50</span> <span class="p">}</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:presence</span> <span class="o">=&gt;</span> <span class="kp">true</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>С нашим комплектом тестов, вновь проходящим, мы можем идти дальше, к более интересной валидации: валидации формата электронной почты.</p>

<div class="label" id="sec:format_validation"></div>


<h3><a id="sec:6.2.3" href="modeling-and-viewing-users-one#sec:format_validation" class="heading"><span class="number">6.2.3</span> Валидация формата</a></h3>


<p>Наши валидации для атрибута <code>name</code> реализуют только минимальные ограничения: любое непустое имя длиной до 51 символов пройдет; но, конечно, атрибут <code>email</code> должен соответствовать более строгим требованиям. До сих пор мы отклоняли только пустой адрес электронной почты; в этом разделе мы потребуем, чтобы адреса электронной почты соответствовали знакомому образцу <code>user@example.com</code>.</p>

<p>Ни тесты, ни валидации не будут исчерпывающими - лишь достаточно хорошими, чтобы принять большую часть допустимых адресов электронной почты и отклонить большинство недопустимых. Мы начнем с пары тестов, включающих наборы допустимых и недопустимых адресов. Чтобы сделать эти наборы, стоит узнать о полезной технике создания массивов строк, как показано в этом консольном сеансе:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="sx">%w[foo bar baz]</span>
<span class="go">=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="n">addresses</span> <span class="o">=</span> <span class="sx">%w[user@foo.com THE_USER@foo.bar.org first.last@foo.jp]</span>
<span class="go">=&gt; [&quot;user@foo.com&quot;, &quot;THE_USER@foo.bar.org&quot;, &quot;first.last@foo.jp&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="n">addresses</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">address</span><span class="o">|</span>
<span class="gp">?&gt; </span>  <span class="nb">puts</span> <span class="n">address</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">user@foo.com</span>
<span class="go">THE_USER@foo.bar.org</span>
<span class="go">first.last@foo.jp</span>
</pre></div>
</div>


<p>Здесь мы выполнили итерации по элементам массива <code>addresses</code> используя <code>each</code> метод (<a class="ref" href="rails-flavored-ruby#sec:blocks">Раздел&nbsp;4.3.2</a>). С этой техникой, мы готовы написать несколько базовых тестов для валидации формата электронной почты (<a class="ref" href="modeling-and-viewing-users-one#code:email_format_validation_tests">Листинг&nbsp;6.16</a>).</p>

<div class="label" id="code:email_format_validation_tests"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.16.</span> <span class="description">Тесты для валидации формата адреса электронной почты. <br /> <code>spec/models/user_spec.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span> <span class="k">do</span>
    <span class="vi">@attr</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;user@example.com&quot;</span> <span class="p">}</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">it</span> <span class="s2">&quot;should accept valid email addresses&quot;</span> <span class="k">do</span>
    <span class="n">addresses</span> <span class="o">=</span> <span class="sx">%w[user@foo.com THE_USER@foo.bar.org first.last@foo.jp]</span>
    <span class="n">addresses</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">address</span><span class="o">|</span>
      <span class="n">valid_email_user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="vi">@attr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="ss">:email</span> <span class="o">=&gt;</span> <span class="n">address</span><span class="p">))</span>
      <span class="n">valid_email_user</span><span class="o">.</span><span class="n">should</span> <span class="n">be_valid</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">it</span> <span class="s2">&quot;should reject invalid email addresses&quot;</span> <span class="k">do</span>
    <span class="n">addresses</span> <span class="o">=</span> <span class="sx">%w[user@foo,com user_at_foo.org example.user@foo.]</span>
    <span class="n">addresses</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">address</span><span class="o">|</span>
      <span class="n">invalid_email_user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="vi">@attr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="ss">:email</span> <span class="o">=&gt;</span> <span class="n">address</span><span class="p">))</span>
      <span class="n">invalid_email_user</span><span class="o">.</span><span class="n">should_not</span> <span class="n">be_valid</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Как было отмечено выше, они не являются исчерпывающими, но мы проверили обычные допустимые формы электронной почты <code>user@foo.com</code>, <code>THE_USER@foo.bar.org </code> (верхний регистр, подчеркивание и соединенные домены) и <code>first.last@foo.jp</code> (стандартное корпоративное имя пользователя <code>first.last</code>, с двухбуквенным высокоуровневым доменом&nbsp;<code>jp</code>), наряду с несколькими недопустимыми формами.</p>

<p>Код приложения для валидации формата электронной почты использует <em>регулярное выражение</em> (или <em>regex</em>) для определения формата, наряду с <code>:format</code> аргументом для <code>validates</code> метода (<a class="ref" href="modeling-and-viewing-users-one#code:validates_format_of_email">Листинг&nbsp;6.17</a>).</p>

<div class="label" id="code:validates_format_of_email"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.17.</span> <span class="description">Валидация формата адреса электронной почты с регулярным выражением. <br /> <code>app/models/user.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>

  <span class="n">email_regex</span> <span class="o">=</span> <span class="sr">/\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i</span>

  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span>  <span class="ss">:presence</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
                    <span class="ss">:length</span>   <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:maximum</span> <span class="o">=&gt;</span> <span class="mi">50</span> <span class="p">}</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:presence</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
                    <span class="ss">:format</span>   <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="n">email_regex</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Здесь <code>email_regex</code> это <em>регулярное выражение</em>, также известное как <em>regex</em>. Код</p>

<div class="code"><div class="highlight"><pre>  <span class="n">email_regex</span> <span class="o">=</span> <span class="sr">/\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:presence</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
                    <span class="ss">:format</span>   <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="n">email_regex</span> <span class="p">}</span>
</pre></div>
</div>


<p>обеспечивает, что только адреса электронной почты, которые соответствуют образцу, будут считаться допустимыми.</p>

<p>Так, откуда появился образец? Регулярные выражения состоят из краткого (некоторые сказали бы  <a href="http://catb.org/jargon/html/L/line-noise.html">нечитаемого</a>) языка для сравнения текстовых шаблонов; обучение построению регулярных выражений это искусство, и для начала я разбил <code>email_regex</code> на мелкие куски  (<a class="ref" href="modeling-and-viewing-users-one#table:email_regex">Таблица&nbsp;6.1</a>).<sup class="footnote" id="fnref:6.16"><a href="#fn:6.16">16</a></sup> Я считаю что замечательный онлайн редактор регулярных выражений <a href="http://www.rubular.com/">Rubular</a>  (<a class="ref" href="modeling-and-viewing-users-one#fig:rubular">Рис.&nbsp;6.6</a>) просто незаменим для изучения  регулярных выражений.<sup class="footnote" id="fnref:6.17"><a href="#fn:6.17">17</a></sup> Cайт Rubular имеет красивый интерактивный интерфейс для создания регулярных выражений, а также удобную Regex справку. Я призываю вас изучать <a class="ref" href="modeling-and-viewing-users-one#table:email_regex">Таблицу&nbsp;6.1</a> с открытым в браузере Rubular-ом. Никакое чтение о регулярных выражениях не может заменить пару часов игры с Rubular.</p>

<div class="label" id="table:email_regex"></div>


<div class="table"><div class="center"><table class="tabular"><tr><th class="align_left"><strong>Выражение</strong></th><th class="align_left"><strong>Значение</strong></th></tr><tr class="top_bar"><td class="align_left"><tt class="verb">/\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i </tt></td><td class="align_left"> полное regex</td></tr><tr><td class="align_left"><tt class="verb">/</tt></td><td class="align_left">начало regex</td></tr><tr><td class="align_left"><tt class="verb">\A</tt></td><td class="align_left">начало соответствия строки</td></tr><tr><td class="align_left"><tt class="verb">[\w+\-.]+</tt></td><td class="align_left">по крайней мере один символ слова, плюс, дефис или точка</td></tr><tr><td class="align_left"><tt class="verb">@</tt></td><td class="align_left">буквально &ldquo;знак собаки&rdquo;</td></tr><tr><td class="align_left"><tt class="verb">[a-z\d\-.]+</tt></td><td class="align_left">по крайней мере одна буква, цифра, дефис или точка</td></tr><tr><td class="align_left"><tt class="verb">\.</tt></td><td class="align_left">буквальная точка</td></tr><tr><td class="align_left"><tt class="verb">[a-z]+</tt></td><td class="align_left">по крайней мере одна буква</td></tr><tr><td class="align_left"><tt class="verb">\z</tt></td><td class="align_left">конец соответствия строки</td></tr><tr><td class="align_left"><tt class="verb">/</tt></td><td class="align_left">конец regex</td></tr><tr><td class="align_left"><tt class="verb">i</tt></td><td class="align_left">нечувствительность к регистру</td></tr></table></div><div class="caption"><span class="header">Таблица 6.1: </span><span class="description">Элементы regex электронной почты  из <a class="ref" href="modeling-and-viewing-users-one#code:validates_format_of_email">Листинга&nbsp;6.17</a>.</span></div></div>


<p>Кстати, на самом деле существует полное регулярное выражение для сопоставления адресов электронной почты в соответствии с официальным стандартом, но волноваться не стоит. Экземпляр из <a class="ref" href="modeling-and-viewing-users-one#code:validates_format_of_email">Листинга&nbsp;6.17</a> тоже хорош, возможно даже лучше чем официальный.<sup class="footnote" id="fnref:6.18"><a href="#fn:6.18">18</a></sup></p>

<div class="label" id="fig:rubular"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/rubular.png" alt="rubular" /></span></div><div class="caption"><span class="header">Рисунок  6.6: </span><span class="description">Удивительный редактор регулярных выражений  <a href="http://www.rubular.com/">Rubular</a>.&nbsp;<a href="http://railstutorial.org/images/figures/rubular-full.png">(полный размер)</a></span></div></div>


<p>Теперь тесты должны пройти. (Фактически, тесты для валидных адресов электронной почты должны были проходить все время; так как регулярные выражения, как известно, подвержены ошибкам, действительные испытания электронной почты в основном заключаются в санитарной проверке на <code>email_regex</code>.) Это означает, что осталось только одно ограничение: обеспечение уникальности адресов электронной почты.</p>

<div class="label" id="sec:uniqueness_validation"></div>


<h3><a id="sec:6.2.4" href="modeling-and-viewing-users-one#sec:uniqueness_validation" class="heading"><span class="number">6.2.4</span> Валидация уникальности</a></h3>

<p>Чтобы осуществить уникальность адресов электронной почты (так, чтобы мы могли использовать их в качестве имен пользователей), мы будем использовать <code>:unique</code> опцию для, <code>validates</code> метода. Но предупреждаю: есть <em>важное</em> предостережение, так что не просто просмотрите раздел, а прочитайте его внимательно.</p>

<p>Мы начнем, как обычно, с наших тестов. В наших предыдущих тестах модели мы, главным образом, использовали <code>User.new</code>, который только создает объект Ruby в памяти, но для тестов уникальности мы фактически должны поместить запись в базу данных.<sup class="footnote" id="fnref:6.19"><a href="#fn:6.19">19</a></sup> (Первый) тест дублирования электронной почты представлен в  <a class="ref" href="modeling-and-viewing-users-one#code:validates_uniqueness_of_email_test">Листинге&nbsp;6.18</a>.</p>

<div class="label" id="code:validates_uniqueness_of_email_test"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.18.</span> <span class="description">Тест на отклонение повторяющихся адресов электронной почты.<br /> <code>spec/models/user_spec.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span> <span class="k">do</span>
    <span class="vi">@attr</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;user@example.com&quot;</span> <span class="p">}</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">it</span> <span class="s2">&quot;should reject duplicate email addresses&quot;</span> <span class="k">do</span>
    <span class="c1"># Put a user with given email address into the database.</span>
    <span class="no">User</span><span class="o">.</span><span class="n">create!</span><span class="p">(</span><span class="vi">@attr</span><span class="p">)</span>
    <span class="n">user_with_duplicate_email</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="vi">@attr</span><span class="p">)</span>
    <span class="n">user_with_duplicate_email</span><span class="o">.</span><span class="n">should_not</span> <span class="n">be_valid</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Здесь метод должен создать пользователя и затем попытаться сделать другого с тем же самым адресом электронной почты. (Мы используем шумный метод, <code>create!</code>, впервые замеченный в <a class="ref" href="modeling-and-viewing-users-one#code:raw_user_spec">Листинге&nbsp;6.10</a>, чтобы он вызвал исключение, если что-то пойдет не так как надо. Используя <code>create</code>, без bang&nbsp;<code>!</code>, мы рискуем иметь тихую ошибку в нашем тесте - потенциальный источник неуловимых багов.) Мы можем заставить этот тест пройти с кодом в <a class="ref" href="modeling-and-viewing-users-one#code:validates_uniqueness_of_email">Листинге&nbsp;6.19</a>.<sup class="footnote" id="fnref:6.20"><a href="#fn:6.20">20</a></sup></p>

<div class="label" id="code:validates_uniqueness_of_email"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.19.</span> <span class="description">Валидация уникальности адресов электронной почты. <br /> <code>app/models/user.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:presence</span>   <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
                    <span class="ss">:format</span>     <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="n">email_regex</span> <span class="p">},</span>
                    <span class="ss">:uniqueness</span> <span class="o">=&gt;</span> <span class="kp">true</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>И все же мы не закончили. Адреса электронной почты не чувствительны к регистру &mdash; <code>foo@bar.com</code> равен <code>FOO@BAR.COM</code> или <code>FoO@BAr.coM</code> &mdash; и наша валидация должна учитывать и этот случай. Мы тестируем на это с помощью кода из <a class="ref" href="modeling-and-viewing-users-one#code:validates_uniqueness_of_email_case_insensitive_test">Листинга&nbsp;6.20</a>.</p>

<div class="label" id="code:validates_uniqueness_of_email_case_insensitive_test"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.20.</span> <span class="description">Нечувствительный к регистру тест на отклонение дублирующихся адресов электронной почты. <br /> <code>spec/models/user_spec.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span> <span class="k">do</span>
    <span class="vi">@attr</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;user@example.com&quot;</span> <span class="p">}</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">it</span> <span class="s2">&quot;should reject email addresses identical up to case&quot;</span> <span class="k">do</span>
    <span class="n">upcased_email</span> <span class="o">=</span> <span class="vi">@attr</span><span class="o">[</span><span class="ss">:email</span><span class="o">].</span><span class="n">upcase</span>
    <span class="no">User</span><span class="o">.</span><span class="n">create!</span><span class="p">(</span><span class="vi">@attr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="ss">:email</span> <span class="o">=&gt;</span> <span class="n">upcased_email</span><span class="p">))</span>
    <span class="n">user_with_duplicate_email</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="vi">@attr</span><span class="p">)</span>
    <span class="n">user_with_duplicate_email</span><span class="o">.</span><span class="n">should_not</span> <span class="n">be_valid</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Здесь мы используем <code>upcase</code> метод на строках (описан кратко в <a class="ref" href="rails-flavored-ruby#sec:blocks">Разделе&nbsp;4.3.2</a>). Этот тест то же что и первый тест на дублирование адресов электронной почты, но с прописным адресом электронной почты. Если этот тест кажется немного абстрактным, запустите консоль:</p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console --sandbox</span>
<span class="gp">&gt;&gt; </span><span class="vi">@attr</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;user@example.com&quot;</span> <span class="p">}</span>
<span class="go">=&gt; {:name =&gt; &quot;Example User&quot;, :email =&gt; &quot;user@example.com&quot;}</span>
<span class="gp">&gt;&gt; </span><span class="n">upcased_email</span> <span class="o">=</span> <span class="vi">@attr</span><span class="o">[</span><span class="ss">:email</span><span class="o">].</span><span class="n">upcase</span>
<span class="go">=&gt; &quot;USER@EXAMPLE.COM&quot;</span>
<span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">create!</span><span class="p">(</span><span class="vi">@attr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="ss">:email</span> <span class="o">=&gt;</span> <span class="n">upcased_email</span><span class="p">))</span>
<span class="gp">&gt;&gt; </span><span class="n">user_with_duplicate_email</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="vi">@attr</span><span class="p">)</span>
<span class="gp">&gt;&gt; </span><span class="n">user_with_duplicate_email</span><span class="o">.</span><span class="n">valid?</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>Конечно, сейчас <code>user_with_duplicate_email.valid?</code> является <code>true</code>, так как это провальный тест, но мы хотим, чтобы оно было <code>false</code>. К счастью, <code>:uniqueness</code> принимает опцию, <code>:case_sensitive</code>, как раз для этой цели (<a class="ref" href="modeling-and-viewing-users-one#code:validates_uniqueness_of_email_case_insensitive">Листинг&nbsp;6.21</a>).</p>

<div class="label" id="code:validates_uniqueness_of_email_case_insensitive"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.21.</span> <span class="description">Валидация уникальности адресов электронной почты, игнорирующая регистр. <br /> <code>app/models/user.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">validates</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:presence</span>   <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
                    <span class="ss">:format</span>     <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="n">email_regex</span> <span class="p">},</span>
                    <span class="ss">:uniqueness</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:case_sensitive</span> <span class="o">=&gt;</span> <span class="kp">false</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Обратите внимание, что мы просто заменили <code>true</code> на <code>:case_sensitive =&gt; false</code>; Rails в этом случае делает вывод, что <code>:uniqueness</code> должно быть <code>true</code>. В этой точке наше приложение обеспечивает уникальность адресов электронной почты и наш набор тестов должен пройти.</p>

<div class="label" id="sec:the_caveat"></div>


<h4><a id="sec:6.2.4.1" href="modeling-and-viewing-users-one#sec:the_caveat" class="heading">Предостережение уникальности</a></h4>


<p>Есть одна небольшая проблема, предостережение, на которое я ссылался выше:</p>

<p><strong>Использование <code>validates :uniqueness</code> не гарантирует уникальности.</strong></p>

<p>D&rsquo;oh! Но что может может пойти не так? А вот что:</p><br/>

<ol>
<li>Алиса регистрируется на сайте, с адресом <code>alice@wonderland.com</code>.</li>
<li>Алиса случайно кликает, &ldquo;Submit&rdquo; <em>дважды</em>, отправляя два запроса в быстрой последовательности.</li>
<li>Затем происходит следующее: первый запрос создает пользователя в памяти, который проходит проверку, второй запрос делает то же самое, первый запрос пользователя сохраняется, второй запрос пользователя сохраняется.</li>
<li>Результат: две пользовательские записи с одинаковыми  адресами электронной почты, несмотря на валидацию уникальности.</li>
</ol><br/>




<p>Если вышеописанная последовательность  кажется вам неправдоподобной, поверьте мне, это не так: это происходит на любом Rails сайте со значительным трафиком.<sup class="footnote" id="fnref:6.21"><a href="#fn:6.21">21</a></sup> К счастью, решение просто в реализации, нам просто необходимо обеспечить уникальность также на уровне базы данных. Наш метод заключается в создании в базе данных <em>индекса</em> столбца электронной почты и последующем требовании уникальности <em>индекса</em>.</p>

<p>Индекс адреса электронной почты представляет собой обновление требований к нашей модели данных, что (как обсуждалось в <a class="ref" href="modeling-and-viewing-users-one#sec:database_migrations">Разделе&nbsp;6.1.1</a>) делается в Rails посредством миграций. Мы видели в <a class="ref" href="modeling-and-viewing-users-one#sec:database_migrations">Разделе&nbsp;6.1.1</a> что генерация модели User автоматически создает новую миграцию (<a class="ref" href="modeling-and-viewing-users-one#code:users_migration">Листинг&nbsp;6.2</a>); в данном случае мы добавляем структуру к существующей модели, таким образом, мы должны создать миграцию непосредственно, используя <code>migration</code> генератор:</p>


<div class="code"><div class="highlight"><pre><span class="gp">$</span> rails generate migration add_email_uniqueness_index
</pre></div>
</div>


<p>В отличие от миграции для пользователей, миграция уникальности электронной почты не предопределена, таким образом, мы должны заполнить ее содержание кодом из <a class="ref" href="modeling-and-viewing-users-one#code:email_uniqueness_index">Листинга&nbsp;6.22</a>.<sup class="footnote" id="fnref:6.22"><a href="#fn:6.22">22</a></sup></p>

<div class="label" id="code:email_uniqueness_index"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.22.</span> <span class="description">Миграция для реализации уникальности адреса электронной почты. <br /> <code>db/migrate/&lt;timestamp&gt;_add_email_uniqueness_index.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">AddEmailUniquenessIndex</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">up</span>
    <span class="n">add_index</span> <span class="ss">:users</span><span class="p">,</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:unique</span> <span class="o">=&gt;</span> <span class="kp">true</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">down</span>
    <span class="n">remove_index</span> <span class="ss">:users</span><span class="p">,</span> <span class="ss">:email</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Здесь используется Rails метод <code>add_index</code> для добавления индекса на столбце <code>email</code> таблицы <code>users</code>. Индекс сам по себе не обеспечивает уникальность, но это делает опция <code>:unique =&gt; true</code>.</p>

<p>Заключительный шаг должен переместить базу данных:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rake db:migrate
</pre></div>
</div>


<p>Теперь вышеописанный сценарий с Алисой  будет хорошо работать: база данных сохранит запись пользователя, основанную на первом запросе, и отвергнет второе сохранение за нарушение уникальности. (Ошибка появится в логе Rails, но в этом нет ничего плохого. Можно фактически поймать <code>ActiveRecord::StatementInvalid</code> исключение &mdash; см. <a href="http://github.com/insoshi/insoshi/blob/master/app/controllers/people_controller.rb">Insoshi</a> для примера &mdash; но в этом учебном руководстве мы не будем заморачиваться этим шагом.) Добавление этого индекса на атрибут адреса электронной почты преследует вторую цель, кратко рассмотренную в <a class="ref" href="modeling-and-viewing-users-one#sec:finding_user_objects">Разделе&nbsp;6.1.4</a>: он решает проблему эффективности <code>find_by_email</code> (<a class="ref" href="modeling-and-viewing-users-one#sidebar:database_indices">Блок&nbsp;6.2</a>).</p>

<div class="label" id="sidebar:database_indices"></div>


<div class="sidebar"><span class="title"><span class="header">Блок 6.2.</span><span class="description">Индексы базы данных</span></span>
<p>При создании столбца в базе данных, важно учитывать, что нам нужно будет <em>найти</em> записи по этому столбцу. Рассмотрим, например, <code>email</code> атрибут созданый миграцией в <a class="ref" href="modeling-and-viewing-users-one#code:users_migration">Листинге&nbsp;6.2</a>. Когда мы позволим пользователям регистрироваться на сайте, начиная с <a class="ref" href="sign-up#top">Главы&nbsp;8</a>, нам нужно будет найти запись пользователя соответствующую предоставленному адресу электронной почты; в базе данных, основанной, к сожалению, на наивной модели данных, единственный способ найти пользователя по его адресу электронной почты, это просмотреть строку <em>каждого</em> пользователя в базе данных и сравнить его адрес электронной почты с атрибутом предоставленного адреса электронной почты. Это известно в бизнесе баз данных, как <em>full-table scan</em> (полное сканирование таблицы), а для реального сайта с тысячами пользователей это <a href="http://catb.org/jargon/html/B/Bad-Thing.html">Bad Thing</a>.</p>

<p>Добавление индекса к столбцу электронной почты решает проблему. Чтобы понять индекс базы данных, полезно рассмотреть аналогию с индексом книги. В книге, чтобы найти все вхождения заданной строки, например &ldquo;foobar&rdquo;, вам придется сканировать каждую страницу в поиске &ldquo;foobar&rdquo;. С индексом книги, с другой стороны, вы можете просто посмотреть &ldquo;foobar&rdquo; в индексе, чтобы увидеть все страницы, содержащие &ldquo;foobar&rdquo;. Индекс базы данных работает, по сути, аналогичным образом.</p>
</div>




<div class="label" id="sec:viewing_users"></div>


<h2><a id="sec:6.3" href="modeling-and-viewing-users-one#sec:viewing_users" class="heading"><span class="number">6.3</span> Просмотр пользователей</a></h2>


<p>Мы не совсем закончили с базовой моделью user нам все еще необходимо добавить пароли, это задача для <a class="ref" href="modeling-and-viewing-users-two#top">Главы&nbsp;7</a>&mdash;но у нас есть достаточно места, чтобы сделать минималистскую страницу для того, чтобы показать информацию о пользователе. Это позволит мягко ввести REST стиль организации действий для пользователей нашего сайта. Так как это пока только грубая демонстрация, в этом разделе нет тестов; мы их добавим, когда детализируем представление пользователя в  <a class="ref" href="modeling-and-viewing-users-two#sec:better_user_views">Разделе&nbsp;7.3</a>.</p>

<div class="label" id="sec:rails_environments"></div>


<h3><a id="sec:6.3.1" href="modeling-and-viewing-users-one#sec:rails_environments" class="heading"><span class="number">6.3.1</span> Отладка и окружения Rails</a></h3>

<p>В качестве подготовки к добавлению динамических страниц в наш пример приложения, сейчас хорошее время, чтобы добавить некоторую отладочную информацию к шаблону нашего сайта  (<a class="ref" href="modeling-and-viewing-users-one#code:rails_debug">Листинг&nbsp;6.23</a>). Это отображает некоторую полезную информацию о каждой странице с помощью встроенного <code>debug</code> метода и <code>params</code> переменной (о которой мы узнаем больше в <a class="ref" href="modeling-and-viewing-users-one#sec:users_show">Разделе&nbsp;6.3.2</a>), как показано на <a class="ref" href="modeling-and-viewing-users-one#fig:home_page_with_debug_rails_3">Рис.&nbsp;6.7</a>.</p>

<div class="label" id="code:rails_debug"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.23.</span> <span class="description">Добавление отладочной информации к макету сайта. <br /> <code>app/views/layouts/application.html.erb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
  .
  .
  .
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;container&quot;</span><span class="nt">&gt;</span>
      .
      .
      .
      <span class="cp">&lt;%=</span> <span class="n">render</span> <span class="s1">&#39;layouts/footer&#39;</span> <span class="cp">%&gt;</span>
      <span class="cp">&lt;%=</span> <span class="n">debug</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="k">if</span> <span class="no">Rails</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">development?</span> <span class="cp">%&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>
</div></div>


<p>Так как мы не хотим выводить на экран отладочную информацию пользователям развернутого приложения, мы используем</p>

<div class="code"><div class="highlight"><pre><span class="k">if</span> <span class="no">Rails</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">development?</span>
</pre></div>
</div>


<p>чтобы ограничить отладочную информацию <em>development environment</em> (средой разработки). Хотя мы видели признаки окружений Rails и прежде (последний раз в <a class="ref" href="modeling-and-viewing-users-one#sec:creating_user_objects">Разделе&nbsp;6.1.3</a>), они впервые имеют для нас какое-то значение.</p>

<div class="label" id="fig:home_page_with_debug_rails_3"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/home_page_with_debug_rails_3.png" alt="home_page_with_debug_rails_3" /></span></div><div class="caption"><span class="header">Рисунок  6.7: </span><span class="description">Home страница примера приложения (<a href="http://localhost:3000/"><tt>/</tt></a>) с отладочной информацией в нижней части.&nbsp;<a href="http://railstutorial.org/images/figures/home_page_with_debug_rails_3-full.png">(полный размер)</a></span></div></div>


<p>К Rails прилагается три окружения: <code>test</code>, <code>development</code>, и <code>production</code> ("тест, разработка, и производство").<sup class="footnote" id="fnref:6.23"><a href="#fn:6.23">23</a></sup> дефолтным окружением для консоли Rails является <code>development</code>:</p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console </span>
<span class="go">Loading development environment (Rails 3.0.9)</span>
<span class="gp">&gt;&gt; </span><span class="no">Rails</span><span class="o">.</span><span class="n">env</span>
<span class="go">=&gt; &quot;development&quot;</span>
<span class="gp">&gt;&gt; </span><span class="no">Rails</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">development?</span>
<span class="go">=&gt; true</span>
<span class="gp">&gt;&gt; </span><span class="no">Rails</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">test?</span>
<span class="go">=&gt; false</span>
</pre></div>
</div>


<p>Как вы можете видеть, Rails предоставляет <code>Rails</code> объект с <code>env</code> атрибутом и связанными с окружением булевыми методами. В частности, <code>Rails.env.development?</code> является <code>true</code> только в окружении разработки, так Embedded Ruby</p>

<div class="code"><div class="highlight"><pre><span class="cp">&lt;%=</span> <span class="n">debug</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="k">if</span> <span class="no">Rails</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">development?</span> <span class="cp">%&gt;</span>
</pre></div>
</div>


<p>не будет вставлен в production приложения или tests. (Включение отладочной информации в tests, вероятно, не причинит никакого вреда, но и, вероятно, не принесет никакой пользы,  поэтому лучше ограничить и показывать отладки только для  development.)</p>

<p>Если вам когда-нибудь понадобится запустить консоль в другой среде (для отладки теста, например), вы можете включить окружение  в качестве параметра для <code>console</code> скрипта:</p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console test</span>
<span class="go">Loading test environment (Rails 3.0.9)</span>
<span class="gp">&gt;&gt; </span><span class="no">Rails</span><span class="o">.</span><span class="n">env</span>
<span class="go">=&gt; &quot;test&quot;</span>
</pre></div>
</div>


<p>Как и в случае с консолью, <code>development</code> является дефолтным окружением для локального сервера Rails, но вы также можете запустить его в другой среде:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> rails server --environment production
</pre></div>
</div>


<p>Если вы просмотрите ваше приложение в production, оно не будет работать без production  базы данных, которую мы можем создать, запустив <code>rake db:migrate</code> в production:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rake db:migrate <span class="nv">RAILS_ENV</span><span class="o">=</span>production
</pre></div>
</div>


<p>(Я нахожу запутывающим, когда console, server, и migrate команды определяют нестандартное окружение тремя взаимно несовместимыми способами, и именно поэтому я потрудился показать все три.)</p>

<p>Кстати, если вы развернули ваш пример приложения в Heroku, вы можете увидеть его  окружение, используя команду <code>heroku</code> которая предоставляет свою собственную (удаленную) консоль:</p>

<div class="code"><div class="highlight"><pre><span class="go">$ heroku console</span>
<span class="go">Ruby console for yourapp.heroku.com</span>
<span class="gp">&gt;&gt; </span><span class="no">Rails</span><span class="o">.</span><span class="n">env</span>
<span class="go">=&gt; &quot;production&quot;</span>
<span class="gp">&gt;&gt; </span><span class="no">Rails</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">production?</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>Естественно, так как Heroku это платформа для production сайтов, она запускает каждое приложение в production окружении.</p>

<div class="label" id="sec:users_show"></div>


<h3><a id="sec:6.3.2" href="modeling-and-viewing-users-one#sec:users_show" class="heading"><span class="number">6.3.2</span> User модель, представление, контроллер</a></h3>

<p>Для того, чтобы сделать страницу для просмотра пользователя, мы будем использовать <em>модель</em> User чтобы внести его в базу данных, сделаем <em>представление</em> чтобы демонстрировать некоторую информацию о пользователе, а затем добавим действие в <em>контроллер</em> Users для обработки браузером. Иными словами, в первый раз в этом учебнике, мы будем видеть в одном месте все три элемента модель-представление-контроллер архитектуры, впервые обсуждавшейся в <a class="ref" href="beginning#sec:mvc">Разделе&nbsp;1.2.6</a>.</p>

<p>Наш первый шаг состоит в создании пользователя с помощью консоли, позаботимся, о том чтобы <em>не</em> работать в песочнице с этого времени, чтобы сохранить запись в базе данных:</p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console</span>
<span class="go">Loading development environment (Rails 3.0.9)</span>
<span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">create!</span><span class="p">(</span><span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Michael Hartl&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;mhartl@example.com&quot;</span><span class="p">)</span>
<span class="go">=&gt; #&lt;User id: 1, name: &quot;Michael Hartl&quot;, email: &quot;mhartl@example.com&quot;,</span>
<span class="go">created_at: &quot;2010-01-07 23:05:14&quot;, updated_at: &quot;2010-01-07 23:05:14&quot;&gt;</span>
</pre></div>
</div>


<p>Чтобы перепроверить, что это работает, давайте посмотрим на строку в development базе данных с помощью SQLite Database Browser (<a class="ref" href="modeling-and-viewing-users-one#fig:sqlite_user_row">Рис.&nbsp;6.8</a>). Обратите внимание, что столбцы соответствуют атрибутам модели данных, определеной в <a class="ref" href="modeling-and-viewing-users-one#sec:user_model">Разделе&nbsp;6.1</a>.</p>

<div class="label" id="fig:sqlite_user_row"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/sqlite_user_row.png" alt="sqlite_user_row" /></span></div><div class="caption"><span class="header">Рисунок  6.8: </span><span class="description">Строка user в базе данных SQLite <code>db/development.sqlite3</code>..&nbsp;<a href="http://railstutorial.org/images/figures/sqlite_user_row-full.png">(полный размер)</a></span></div></div>


<p>Далее идет представление, которое отличается минимализмом, чтобы подчеркнуть, что это просто демонстрация (<a class="ref" href="modeling-and-viewing-users-one#code:stub_user_view">Листинг&nbsp;6.24</a>). Мы используем стандартное расположение Rails для представления show, <code>app/views/users/show.html.erb</code>; в отличие от представления <code>new.html.erb</code> которое мы создали генератором в <a class="ref" href="filling-in-the-layout#code:generate_users_controller">Листинге&nbsp;5.23</a>, <code>show.html.erb</code> файл в настоящее время не существует, так что вам придется создать его вручную.</p>

<div class="label" id="code:stub_user_view"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.24.</span> <span class="description">Представление–заглушка  для отображения информации о пользователе. <br /> <code>app/views/users/show.html.erb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="cp">&lt;%=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">name</span> <span class="cp">%&gt;</span>, <span class="cp">&lt;%=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">email</span> <span class="cp">%&gt;</span>
</pre></div>
</div></div>


<p>Это представление использует Embedded Ruby для отображения имени пользователя и адреса электронной почты, предполагая существование переменной экземпляра <code>@user</code>. Конечно, в итоге реальная страница для отображения пользователя будет выглядеть совсем иначе, и не будет показывать публично адрес электронной почты.</p>

<p>Наконец, мы добавим <code>show</code> действие в контроллер Users (направляющий в <code>show.html.erb</code> представление) с кодом в <a class="ref" href="modeling-and-viewing-users-one#code:user_show_action">Листинге&nbsp;6.25</a>, который определяет переменную экземпляра <code>@user</code>, необходимую представлению.</p>

<div class="label" id="code:user_show_action"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.25.</span> <span class="description">Users контроллер с <code>show</code> действием. <br /> <code>app/controllers/users_controller.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">UsersController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">show</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:id</span><span class="o">]</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">new</span>
    <span class="vi">@title</span> <span class="o">=</span> <span class="s2">&quot;Sign up&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Здесь мы немного забежали вперед, использовав стандартный Rails объект <code>params</code> для получения &nbsp;id пользователя. Когда мы сделаем соответствующий запрос в контроллер Users, <code>params[:id]</code> id&nbsp;пользователя  будет&nbsp;<code>1</code>, так что эффект такой же, как от <code>find</code> команды</p>

<div class="code"><div class="highlight"><pre><span class="no">User</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>


<p>которую мы видели в <a class="ref" href="modeling-and-viewing-users-one#sec:finding_user_objects">Разделе&nbsp;6.1.4</a>.</p>

<p>Хотя представление и действие для <code>show</code> определены, мы все еще не имеем способа увидеть саму страницу. Это требует определения надлежащего правила в Rails файле routes.rb, как мы увидим в следующем разделе.</p>

<div class="label" id="sec:a_users_resource"></div>


<h3><a id="sec:6.3.3" href="modeling-and-viewing-users-one#sec:a_users_resource" class="heading"><span class="number">6.3.3</span> Ресурс Users</a></h3>

<p>Наш метод для отображения страницы пользователя будет следовать  соглашениям  REST архитектуры, одобренной в приложениях Rails. Этот стиль основан на идеях <em>передачи состояния представления</em> определенный и названный ученым  <a href="http://en.wikipedia.org/wiki/Roy_Fielding">Roy Fielding</a>  в его докторской диссертации <em>Architectural Styles and the Design of Network-based Software Architectures</em>.<sup class="footnote" id="fnref:6.24"><a href="#fn:6.24">24</a></sup> REST стиль подчеркивает представление данных как <em>ресурсов</em> которые могут быть созданы, показаны, обновлены, или уничтожены&mdash;четыре действия, соответствующие четырем фундаментальным операциям <tt>POST</tt>, <tt>GET</tt>, <tt>PUT</tt>, и <tt>DELETE</tt> определенным <a href="http://ru.wikipedia.org/wiki/HTTP">стандартом HTTP</a> (<a class="ref" href="static-pages#sidebar:get_etc">Блок&nbsp;3.1</a>).</p>

<p>Следуя принципам REST, на ресурсы обычно ссылаются, используя имя ресурса и уникальный идентификатор. Что это означает в контексте пользователей&mdash;о которых мы теперь думаем, как о <em>ресурсе</em> Users&mdash;то, что мы должны показать пользователя с id&nbsp;<code>1</code> выдав <tt>GET</tt> запрос к URL <tt>/users/1</tt>. Здесь <code>show</code> действие <em>неявно</em> в типе запроса&mdash;когда Rails&rsquo; функции REST активированы, <tt>GET</tt> запросы автоматически обрабатываются <code>show</code> действием.</p>

<div class="label" id="fig:user_show_exception_caught"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/user_show_exception_caught.png" alt="user_show_exception_caught" /></span></div><div class="caption"><span class="header">Рисунок  6.9: </span><span class="description">Начальный эффект посещения  <a href="http://localhost:3000/users/1"><tt>/users/1</tt></a>.&nbsp;<a href="http://railstutorial.org/images/figures/user_show_exception_caught-full.png">(полный размер)</a></span></div></div>


<p>К сожалению, URL  <a href="http://localhost:3000/users/1"><tt>/users/1</tt></a> еще не работает из-за ошибки маршрутизации (<a class="ref" href="modeling-and-viewing-users-one#fig:user_show_exception_caught">Рис.&nbsp;6.9</a>). Мы можем получить REST-style Users URL на работу, добавив пользователей в качестве ресурса для <code>config/routes.rb</code>, как видно в <a class="ref" href="modeling-and-viewing-users-one#code:users_resource">Листинге&nbsp;6.26</a>.</p>

<div class="label" id="code:users_resource"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 6.26.</span> <span class="description">Добавление ресурса Users в файл маршрутов. <br /> <code>config/routes.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="no">SampleApp</span><span class="o">::</span><span class="no">Application</span><span class="o">.</span><span class="n">routes</span><span class="o">.</span><span class="n">draw</span> <span class="k">do</span>
  <span class="n">resources</span> <span class="ss">:users</span>

  <span class="n">match</span> <span class="s1">&#39;/signup&#39;</span><span class="p">,</span>  <span class="ss">:to</span> <span class="o">=&gt;</span> <span class="s1">&#39;users#new&#39;</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>После добавления маршрутов для ресурса Users, URL <a href="http://localhost:3000/users/1"><tt>/users/1</tt></a> работает отлично (<a class="ref" href="modeling-and-viewing-users-one#fig:user_show_rails_3">Рис.&nbsp;6.10</a>).</p>

<div class="label" id="fig:user_show_rails_3"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/user_show_rails_3.png" alt="user_show_rails_3" /></span></div><div class="caption"><span class="header">Рисунок  6.10: </span><span class="description">Страница, демонстрирующая пользователя  <a href="http://localhost:3000/users/1"><tt>/users/1</tt></a> после добавления ресурса Users.&nbsp;<a href="http://railstutorial.org/images/figures/user_show_rails_3-full.png">(полный размер)</a></span></div></div>


<p>Вы, возможно, заметили, что <a class="ref" href="modeling-and-viewing-users-one#code:users_resource">Листинг&nbsp;6.26</a> удалил строку</p>

<div class="code"><div class="highlight"><pre><span class="n">get</span> <span class="s2">&quot;users/new&quot;</span>
</pre></div>
</div>


<p>последний раз замеченную в <a class="ref" href="filling-in-the-layout#code:signup_route">Листинге&nbsp;5.29</a>.  Это потому что одна дополнительная строка ресурса в <a class="ref" href="modeling-and-viewing-users-one#code:users_resource">Листинге&nbsp;6.26</a> не просто добавляет работающий <tt>/users/1</tt> URL; она обеспечивает наш пример приложения всеми действиями, необходимыми для RESTful (полностью REST) ресурса Users,<sup class="footnote" id="fnref:6.25"><a href="#fn:6.25">25</a></sup> наряду с большим количеством именованных маршрутов (<a class="ref" href="filling-in-the-layout#sec:named_routes">Раздел&nbsp;5.2.3</a>) для того, чтобы генерировать URL пользователя. Получившееся  соответствие URL, действий, и именованных маршрутов показано в <a class="ref" href="modeling-and-viewing-users-one#table:RESTful_users">Таблице&nbsp;6.2</a>. (сравните с <a class="ref" href="a-demo-app#table:demo_RESTful_users">Таблицей&nbsp;2.2</a>.) В течение следующих трех глав, мы охватим остальные записи в <a class="ref" href="modeling-and-viewing-users-one#table:RESTful_users">Таблице&nbsp;6.2</a> поскольку мы заполним все действия, необходимые, чтобы сделать Users полностью RESTful ресурсом.</p>

<div class="label" id="table:RESTful_users"></div>


<div class="table"><div class="center"><table class="tabular"><tr><th class="align_left"><strong> HTTP запрос </strong></th><th class="align_left"><strong> URL </strong></th><th class="align_left"><strong> Действие </strong> </th><th class="align_left"><strong> Именованный маршрут </strong></th><th class="align_left"><strong> Назначение </strong></th></tr>	<tr class="top_bar"><td class="align_left"><tt> GET </tt></td><td class="align_left"><tt> /users </tt></td><td class="align_left"><code> index </code></td><td class="align_left"><code> users_path </code></td><td class="align_left"> страница, показывающая список пользователей </td></tr><tr><td class="align_left"><tt> GET </tt></td>	  <td class="align_left"><tt> /users/1 </tt></td><td class="align_left"><code> show </code></td><td class="align_left"><code> user_path(1) </code></td><td class="align_left"> страница показывающая пользователя с id <code>1</code> </td></tr><tr>	  <td class="align_left"><tt> GET </tt></td><td class="align_left"><tt> /users/new </tt></td><td class="align_left"><code> new </code></td> <td class="align_left"><code> new_user_path </code></td><td class="align_left"> страница для создания нового пользователя (signup) </td></tr><tr><td class="align_left"><tt> POST </tt></td> <td class="align_left"><tt> /users </tt></td>  <td class="align_left"><code> create </code></td><td class="align_left"><code> users_path </code></td><td class="align_left"> создание нового пользователя </td></tr><tr><td class="align_left"><tt> GET </tt></td><td class="align_left"><tt>/users/1/edit</tt></td><td class="align_left"><code> edit </code></td><td class="align_left"><code> edit_user_path(1) </code></td><td class="align_left"> страница для редактирования пользователя с id <code>1</code> </td></tr><tr><td class="align_left"><tt> PUT </tt></td><td class="align_left"><tt> /users/1 </tt></td><td class="align_left"><code> update </code></td><td class="align_left"><code> user_path(1) </code></td><td class="align_left"> обновление пользователя с id <code>1</code> </td></tr><tr><td class="align_left"><tt> DELETE </tt></td><td class="align_left"><tt> /users/1 </tt></td> <td class="align_left"><code> destroy </code></td> <td class="align_left"><code> user_path(1) </code></td><td class="align_left"> удаление пользователя с id <code>1</code> </td></tr></table></div><div class="caption"><span class="header">Таблица 6.2: </span><span class="description">RESTful маршруты, обеспеченные ресурсом Users в <a class="ref" href="modeling-and-viewing-users-one#code:users_resource">Листинге&nbsp;6.26</a>.</span></div></div>




<div class="label" id="sec:params_in_debug"></div>


<h4><a id="sec:6.3.3.1" href="modeling-and-viewing-users-one#sec:params_in_debug" class="heading"><code>params</code> в <code>debug</code></a></h4>


<p>Прежде, чем оставить страницу, показывающую пользователя, мы займем одну минуту, чтобы исследовать отладочную информацию, произведенную <a class="ref" href="modeling-and-viewing-users-one#code:rails_debug">Листинге&nbsp;6.23</a>. Если вы присмотритесь к <a class="ref" href="modeling-and-viewing-users-one#fig:user_show_rails_3">Рис.&nbsp;6.10</a>, то вы увидите, что он включает полезную информацию об отображаемой странице:<sup class="footnote" id="fnref:6.26"><a href="#fn:6.26">26</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="nn">---</span> <span class="kt">!map</span><span class="l-Scalar-Plain">:ActiveSupport::HashWithIndifferentAccess</span>
<span class="l-Scalar-Plain">action</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">show</span>
<span class="l-Scalar-Plain">id</span><span class="p-Indicator">:</span> <span class="s">&quot;1&quot;</span>
<span class="l-Scalar-Plain">controller</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">users</span>
</pre></div>
</div>


<p>Это YAML<sup class="footnote" id="fnref:6.27"><a href="#fn:6.27">27</a></sup> представление <code>params</code>, которое (как намекает название <code>HashWithIndifferentAccess</code>) в основном хэш.  Мы видим, что его контроллер это <code>users</code>, его действие это <code>show</code>, и его <code>id</code> атрибут это <code>"1"</code>. Хотя вы будете редко иметь возможность использовать <code>params[:controller]</code> или <code>params[:action]</code>, использование <code>params[:id]</code> для вытаскивания&nbsp;id из URL является общепринятой идиомой Rails. В частности, мы использовали код</p>

<div class="code"><div class="highlight"><pre><span class="no">User</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:id</span><span class="o">]</span><span class="p">)</span>
</pre></div>
</div>


<p>в <a class="ref" href="modeling-and-viewing-users-one#code:user_show_action">Листинге&nbsp;6.25</a> чтобы найти пользователя с id&nbsp;<code>1</code>. (<code>find</code> метод знает, как преобразовать строку&nbsp;<code>"1"</code> в целое число&nbsp;<code>1</code>.)</p>

<p><code>Debug</code> информация часто обеспечивает полезную обратную связь, при разработке приложений Rails, и я предлагаю привыкнуть проверять ее всякий раз, когда ваше приложение ведет себя не так как ожидалось.</p>

<h2><a id="sec:6.4" href="modeling-and-viewing-users-one#sec:6.4" class="heading"><span class="number">6.4</span> Заключение</a></h2>


<p>Эта глава - первая половина двухступенчатого процесса создания рабочей модели User. У наших пользователей теперь есть атрибуты <code>name</code> и <code>email</code> вместе с валидациями, обеспечивающими несколько важных ограничений для их значений. Мы также предприняли первый маленький шаг к рабочей  странице показывающей пользователя и ресурсу Users, основанному на принципах REST. В <a class="ref" href="modeling-and-viewing-users-two#top">Главе&nbsp;7</a>, мы завершим процесс, добавив пароли пользователя и более полезное  представлениение пользователя.</p>

<p>Если вы используете Git, теперь было бы неплохо зафиксировать внесенные изменения, если вы не сделали этого ранее:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> git add .
<span class="gp">$</span> git commit -m <span class="s2">&quot;Finished first cut of the User model&quot;</span>
</pre></div>
</div>


<h2><a id="sec:6.5" href="modeling-and-viewing-users-one#sec:6.5" class="heading"><span class="number">6.5</span> Упражнения</a></h2>



<ol>
<li>Прочитайте  Rails  API вступление для <code>ActiveRecord::Base</code>, чтобы получить представление о его возможностях.</li>
<li>Изучите вступление в Rails API для <code>validates</code> метода способ узнать больше о его возможностях и опциях.</li>
<li>Потратьте пару часов, играя с <a href="http://www.rubular.com/">Rubular</a>.</li>
</ol>





<div class="navigation">  <a class="prev_page" href="filling-in-the-layout#top">
    &laquo;&nbsp;<span class="number">Глава 5</span> Заполнение макета
  </a>
  <a class="next_page" href="modeling-and-viewing-users-two#top">
    <span class="number">Глава 7</span> Моделирование и просмотр пользователей, часть II&nbsp;&raquo;
  </a>
</div><div class="footnotes">
<ol>
<li id="fn:6.1"><a href="http://gomockingbird.com/">Mockingbird</a> не поддерживает пользовательские изображения как  в <a class="ref" href="modeling-and-viewing-users-one#fig:profile_mockup">Рис.&nbsp;6.1</a>; я вставил его вручную, используя <a href="http://www.adobe.com/products/fireworks/">Adobe Fireworks</a>. Гиппопотам здесь из <a href="http://www.flickr.com/photos/43803060@N00/24308857/">http://www.flickr.com/photos/43803060@N00/24308857/</a>.&nbsp;<a class="arrow" href="#fnref:6.1">&uarr;</a></li>
<li id="fn:6.2">Название происходит от &ldquo;<a href="http://en.wikipedia.org/wiki/Active_record_pattern">active record pattern</a>&rdquo;, идентифицированное и названное в <em>Patterns of Enterprise Application Architecture</em>  Martin Fowler.&nbsp;<a class="arrow" href="#fnref:6.2">&uarr;</a></li>
<li id="fn:6.3">Произносится &ldquo;ess-cue-ell&rdquo;, хотя альтернативное произношение &ldquo;sequel&rdquo; также принято.&nbsp;<a class="arrow" href="#fnref:6.3">&uarr;</a></li>
<li id="fn:6.4">В своих самых ранних воплощениях Rails действительно требовал знания SQL&nbsp;DDL.  Даже после того, как Rails добавил миграции, все равно требовалась установка старой дефолтной базы данных (MySQL). К счастью, как отмечено в <a class="ref" href="beginning#sec:rails_server">Разделе&nbsp;1.2.5</a>, Rails теперь использует по умолчанию SQLite, которая хранит его данные как простой файл&mdash;не требуя установки.&nbsp;<a class="arrow" href="#fnref:6.4">&uarr;</a></li>
<li id="fn:6.5">Иногда, необходимо проникнуть в этот уровень абстракции, но одна из целей  этого учебного руководства состоит в том, чтобы сделать весь код независимым от базы данных. (Действительно, это достойная цель вообще.) В случае, если вам когда либо придется писать специфичный для базы данных код, для развертывания на Heroku, следует знать, что они используют превосходную  <a href="http://www.postgresql.org/">PostgreSQL</a> (&ldquo;post-gres-cue-ell&rdquo;) базу данных. PostgreSQL бесплатна, open-source, и кросплатформенна; если вы разрабатываете PostgreSQL-специфичные приложения, можно установить ее локально, и сконфигурировать Rails, для использования ее в разработке, отредактировав <code>config/database.yml</code> файл. Такая конфигурация выходит за рамки этого учебного руководства, но есть много ресурсов в сети; используйте поисковую систему, чтобы найти самую актуальную информацию для вашей платформы.&nbsp;<a class="arrow" href="#fnref:6.5">&uarr;</a></li>
<li id="fn:6.6">Используя адреса электронной почты в качестве имени пользователя мы открываем теоретическую возможность связи с нашими пользователями в будущем.&nbsp;<a class="arrow" href="#fnref:6.6">&uarr;</a></li>
<li id="fn:6.7">Не волнуйтесь о том, как объект <code>t</code>&nbsp;делает это; красота <em>уровней абстракции</em> (the beauty of abstraction layers) состоит в том, что мы не должны этого знать. Мы можем только доверить объекту <code>t</code>&nbsp;выполнить его работу.&nbsp;<a class="arrow" href="#fnref:6.7">&uarr;</a></li>
<li id="fn:6.8">Мы увидим, как migrate up на удаленном сервере Heroku в <a class="ref" href="modeling-and-viewing-users-two#sec:heroku_deploy">Разделе&nbsp;7.4.2</a>.&nbsp;<a class="arrow" href="#fnref:6.8">&uarr;</a></li>
<li id="fn:6.9">Официально произносится как &ldquo;ess-cue-ell-ite&rdquo;, тем не менее, вариант произношения  &ldquo;sequel-ite&rdquo; также возможен.&nbsp;<a class="arrow" href="#fnref:6.9">&uarr;</a></li>
<li id="fn:6.10">На случай, если <code>"2010-01-05 00:57:46"</code>, вызвало ваше любопытство - я не пишу это после полуночи; метки времени записаны в <a href="http://en.wikipedia.org/wiki/Coordinated_Universal_Time">Coordinated Universal Time</a> (UTC), которое для многих гражданских целей является аналогом  <a href="http://en.wikipedia.org/wiki/Greenwich_Mean_Time">Greenwich Mean Time</a>. Из <a href="http://tf.nist.gov/general/misc.htm">NIST Time and Frequency FAQ</a>:   <strong>Q:</strong> Почему UTC используется в качестве акронима к Coordinated Universal Time вместо CUT? <strong>A:</strong> В 1970 система Coordinated Universal Time была разработана международной консультативной группой технических экспертов в рамках International Telecommunication Union (ITU). ITU чувствовал, что было лучше определить единственное сокращение для использования на всех языках, чтобы минимизировать беспорядок. Так как единогласное соглашение не могло быть достигнуто при использовании английского порядка слов, CUT, или французского порядка слов, TUC, акроним, UTC был выбран в качестве компромисса.&nbsp;<a class="arrow" href="#fnref:6.10">&uarr;</a></li>
<li id="fn:6.11">Отметьте что значение <code>user.updated_at</code>. Говорит вам что метка времени была в UTC.&nbsp;<a class="arrow" href="#fnref:6.11">&uarr;</a></li>
<li id="fn:6.12">Исключения и обработка исключений - несколько более продвинутые предметы Ruby, и мы не сильно будем нуждаться в них в этой книге. Они важны, тем не менее, и я предлагаю узнать о них используя одну из книг, рекомендованных в <a class="ref" href="beginning#sec:comments_for_various_readers">Разделе&nbsp;1.1.1</a>.&nbsp;<a class="arrow" href="#fnref:6.12">&uarr;</a></li>
<li id="fn:6.13">Для тех кто взволнован, что <code>find_by_email</code> будет неэффективен, если будет большое количество пользователей, you&rsquo;re ahead of the game (??). Мы обсудим эту проблему и ее решение через индексы базы данных в <a class="ref" href="modeling-and-viewing-users-one#sec:uniqueness_validation">Разделе&nbsp;6.2.4</a>.&nbsp;<a class="arrow" href="#fnref:6.13">&uarr;</a></li>
<li id="fn:6.14">(и писал)&nbsp;<a class="arrow" href="#fnref:6.14">&uarr;</a></li>
<li id="fn:6.15">Я опускаю выводы консольных команд, когда они не особенно поучительны например, результат <code>User.new</code>.&nbsp;<a class="arrow" href="#fnref:6.15">&uarr;</a></li>
<li id="fn:6.16">Отметьте, что в <a class="ref" href="modeling-and-viewing-users-one#table:email_regex">Таблице&nbsp;6.1</a>, &ldquo;буква&rdquo; на самом деле означает &ldquo;строчную букву&rdquo;, но <code>i</code> в конце regex осуществляет нечувствительное к регистру соответствие.&nbsp;<a class="arrow" href="#fnref:6.16">&uarr;</a></li>
<li id="fn:6.17">Если вы считаете это столь же полезным, как я, я призываю вас <a href="http://bit.ly/donate-to-rubular">donate (дарить, жертвовать) to Rubular</a> чтобы вознаградить разработчика <a href="http://lovitt.net/">Michael Lovitt</a> за его замечательную работу.&nbsp;<a class="arrow" href="#fnref:6.17">&uarr;</a></li>
<li id="fn:6.18">Знаете ли вы, что <code>"Michael Hartl"@example.com</code>, с кавычками и пробелом в середине, является допустимым адресом электронной почты согласно стандарту? Невероятно,- но абсурдно. Если у вас нет адреса электронной почты, который содержит только буквы, номера, подчеркивания, и точки, то получите. N.B. regex в <a class="ref" href="modeling-and-viewing-users-one#code:validates_format_of_email">Листинге&nbsp;6.17</a> позволяет знаки "плюс", также, потому что Gmail (и возможно другие сервисы электронной почты) делает что-то полезное с ними: например, чтобы фильтровать заказы от Amazon, можно использовать <tt>username+amazon@gmail.com</tt>, который пойдет в адрес <tt>username@gmail.com</tt>, разрешая вам фильтровать по строке <tt>amazon</tt>.&nbsp;<a class="arrow" href="#fnref:6.18">&uarr;</a></li>
<li id="fn:6.19">Как отмечено кратко во введении в этот раздел, есть выделенная тестовая база данных, <code>db/test.sqlite3</code>, для этой цели.&nbsp;<a class="arrow" href="#fnref:6.19">&uarr;</a></li>
<li id="fn:6.20">Если вы задаетесь вопросом почему <code>create!</code> строка в <a class="ref" href="modeling-and-viewing-users-one#code:raw_user_spec">Листинге&nbsp;6.10</a> не заставляет это перестать работать, создавая двойного пользователя, это потому что тесты Rails являются <em>transactional</em>: каждый тест обертывается в <a href="http://ru.wikipedia.org/wiki/Транзакция">транзакцию</a>, которая <em>откатывает</em> базу данных после того, как тест выполняется. Таким образом, каждый прогон тестов происходит в свежей базе данных.&nbsp;<a class="arrow" href="#fnref:6.20">&uarr;</a></li>
<li id="fn:6.21">Да, это произошло со мной. А как вы думали я узнал об этом?&nbsp;<a class="arrow" href="#fnref:6.21">&uarr;</a></li>
<li id="fn:6.22">Конечно, мы могли только отредактировать файл миграции для таблицы <code>users</code> в <a class="ref" href="modeling-and-viewing-users-one#code:users_migration">Листинге&nbsp;6.2</a> but that would require rolling back and then migrating back up.(??) Rails Путь состоит в том, чтобы использовать миграции каждый раз, когда  мы обнаруживаем, что наша модель данных должна измениться.&nbsp;<a class="arrow" href="#fnref:6.22">&uarr;</a></li>
<li id="fn:6.23">Можно также определить свои собственные окружения; подробности см. в <a href="http://railscasts.com/episodes/72-adding-an-environment">Railscast on adding an environment</a> for details.&nbsp;<a class="arrow" href="#fnref:6.23">&uarr;</a></li>
<li id="fn:6.24">Fielding, Roy Thomas. <em>Architectural Styles and the Design of Network-based Software Architectures</em>. Doctoral dissertation, University of California, Irvine, 2000.&nbsp;<a class="arrow" href="#fnref:6.24">&uarr;</a></li>
<li id="fn:6.25">Это означает, что <em>маршрутизация</em> работает, но соответствующие страницы не обязательно работают в этой точке. Например, <tt>/users/1/edit</tt> направляется должным образом к <code>edit</code> действию контроллера Users, но так как <code>edit</code> действие еще не существует, фактически, вызов этого URL возвратит ошибку.&nbsp;<a class="arrow" href="#fnref:6.25">&uarr;</a></li>
<li id="fn:6.26">Некоторые из скриншотов этого учебного руководства показывают отладочную информацию с выводом похожим на <code>!map:HashWithIndifferentAccess</code> вместо <code>!map:ActiveSupport::HashWithIndifferentAccess</code>. Это просто незначительные различия между Rails&nbsp;2.3 и Rails&nbsp;3. Так как визуализация веб-страниц идентична между версиями Rails эта сноска избавляет меня от необходимости переделывать все скриншоты.&nbsp;<a class="arrow" href="#fnref:6.26">&uarr;</a></li>
<li id="fn:6.27">Rails <code>debug</code> информация показана как <a  href="http://www.yaml.org/">YAML</a> ( <a   href="http://catb.org/jargon/html/R/recursive-acronym.html">recursive acronym</a> (или <a href="http://ru.wikipedia.org/wiki/Рекурсивный_акроним">рекурсивный акроним)</a>)  обозначающий &ldquo;<a href="http://ru.wikipedia.org/wiki/YAML">YAML</a> Ain&rsquo;t Markup Language&rdquo;), который является дружественным форматом данных, разработанным, чтобы быть удобочитаемым и для машин и для людей.&nbsp;<a class="arrow" href="#fnref:6.27">&uarr;</a></li>
</ol>
</div>

