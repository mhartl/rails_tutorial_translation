<div id="top"></div>


<h1 class="chapter"><a id="sec:4" href="rails-flavored-ruby#top" class="heading"><span class="number">Глава 4</span> Rails&nbsp;&mdash;&nbsp;приправленный Ruby</a></h1>


<p>Основанная на примерах из <a class="ref" href="static-pages#top">Главы&nbsp;3</a>, эта глава рассматривает некоторые элементы Ruby важные для Rails. Ruby многогранен, но, к счастью, нам нужна относительно малая его часть, чтобы быть продуктивным Rails-разработчиком. Более того, эта малая часть <em>отличается</em> от той, которая вам понадобится в Ruby для обычных задач, поэтому, если вашей целью является создание динамических веб-приложений, я рекомендую изучать Rails первым, собирая биты Ruby на этом пути. Чтобы стать <em>экспертом</em> Rails, вы должны понимать Ruby более глубоко, и эта книга дает вам хорошую основу для развития.  Как отмечалось в <a class="ref" href="beginning#sec:comments_for_various_readers">Разделе&nbsp;1.1.1</a>, после окончания <em>Rails Tutorial</em> я советую почитать книги о чисто Ruby, такие как <a href="http://www.amazon.com/gp/product/1430223634?ie=UTF8&amp;tag=httpwwwrailst-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1430223634"><em>Beginning Ruby</em></a>, <a href="http://www.amazon.com/gp/product/1933988657?ie=UTF8&amp;tag=httpwwwrailst-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1933988657"><em>The Well-Grounded Rubyist</em></a>, или <a href="http://www.amazon.com/gp/product/B000P28V8Q?ie=UTF8&amp;tag=httpwwwrailst-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B000P28V8Q"><em>The Ruby Way</em></a>.</p>

<p>В этой главе рассматриваются много материала, и это нормально&nbsp;&mdash;&nbsp;не понять его весь с первого раза. Я буду часто возвращаться к нему в последующих главах.</p>

<div class="label" id="sec:motivation"></div>


<h2><a id="sec:4.1" href="rails-flavored-ruby#sec:motivation" class="heading"><span class="number">4.1</span> Причины</a></h2>


<p>Как мы видели в предыдущей главе, можно развить скелет приложения Rails, и даже начать тестирование, практически без знания основ языка Ruby.  Мы сделали это, опираясь на сгенерированный контроллер и код тестов, следуя примерам (кода) которые мы там увидели.  Тем не менее, такая ситуация не может длиться вечно, и мы откроем эту главу парой дополнений к сайту, которые поставят нас лицом к лицу с нашим ограниченным знанием Ruby.</p>

<div class="label" id="sec:title_helper"></div>


<h3><a id="sec:4.1.1" href="rails-flavored-ruby#sec:title_helper" class="heading"><span class="number">4.1.1</span> <code>Тitle</code> хелпер</a></h3>


<p>Когда мы в последний раз видели наше новое приложение, мы только что обновили наши, в  основном статические, страницы использовав Rails шаблон для устранения дублирования в наших представлениях (<a class="ref" href="rails-flavored-ruby#code:application_layout_redux">Листинг&nbsp;4.1</a>).</p>

<div class="label" id="code:application_layout_redux"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 4.1.</span> <span class="description">Шаблон сайта Пример приложения. <br /> <code>app/views/layouts/application.html.erb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span>Ruby on Rails Tutorial Sample App | <span class="cp">&lt;%=</span> <span class="vi">@title</span> <span class="cp">%&gt;</span><span class="nt">&lt;/title&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">csrf_meta_tag</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="cp">&lt;%=</span> <span class="k">yield</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>
</div></div>


<p>Этот шаблон хорошо работает, но есть одна его часть, которую можно немного отполировать.  Напомним, что строка заголовка (тайтла)</p>

<div class="code"><div class="highlight"><pre>Ruby on Rails Tutorial Sample App | <span class="cp">&lt;%=</span> <span class="vi">@title</span> <span class="cp">%&gt;</span>
</pre></div>
</div>


<p>опирается на определение <code>@title</code> в действии (actions), такое как</p>

<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">PagesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">home</span>
    <span class="vi">@title</span> <span class="o">=</span> <span class="s2">&quot;Home&quot;</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
</pre></div>
</div>


<p>Но что, если мы не определим <code>@title</code> переменную? Это хорошее соглашение - иметь <em>базовый заголовок</em>, который мы используем на каждой странице, с дополнительным переменным заголовком (тайтлом), если мы хотим быть более конкретными. Мы уже <em>почти</em> достигли этого с нашей текущей схемой, с одним маленьким недостатком: как вы можете видеть, если вы удалите назначение <code>@title</code> в одном из действий, в отсутствие <code>@title</code> переменной название будет выглядеть следующим образом:</p>

<div class="code"><div class="highlight"><pre>Ruby on Rails Tutorial Sample App |
</pre></div>
</div>


<p>Другими словами, есть подходящий базовый заголовок (тайтл), но есть также  прицепленная вертикальная черта <code>|</code> в конце заголовка.</p>

<p>Одним принятым способом справиться с этим случаем, является определение <em>helper</em> (помощник, хелпер), который является функцией предназначенной для использования в представлениях. Давайте определим <code>title</code> помощник, который возвращает базовый заголовок, &ldquo;Ruby on Rails Tutorial Sample App&rdquo;, если <code>@title</code> переменная не определена и добавляет вертикальную черту перед переменным заголовком, если <code>@title</code> определена (<a class="ref" href="rails-flavored-ruby#code:title_helper">Листинг&nbsp;4.2</a>).<sup class="footnote" id="fnref:4.1"><a href="#fn:4.1">1</a></sup></p>

<div class="label" id="code:title_helper"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 4.2.</span> <span class="description">Определение <code>title</code> помощника (хелпера).<br /> <code>app/helpers/application_helper.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">module</span> <span class="nn">ApplicationHelper</span>

  <span class="c1"># Return a title on a per-page basis.</span>
  <span class="k">def</span> <span class="nf">title</span>
    <span class="n">base_title</span> <span class="o">=</span> <span class="s2">&quot;Ruby on Rails Tutorial Sample App&quot;</span>
    <span class="k">if</span> <span class="vi">@title</span><span class="o">.</span><span class="n">nil?</span>
      <span class="n">base_title</span>
    <span class="k">else</span>
      <span class="s2">&quot;</span><span class="si">#{</span><span class="n">base_title</span><span class="si">}</span><span class="s2"> | </span><span class="si">#{</span><span class="vi">@title</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Этот код может выглядеть довольно просто для глаз опытного разработчика Rails, но он <em>полон</em> новых идей Ruby: модули, комментарии, назначение локальной переменной, булевые выражения, управление потоком, интерполяция строки и возвращение значений. Мы рассмотрим каждую из этих идей в этой главе.</p>

<p>Теперь у нас есть помощник (хелпер), и мы можем использовать его для упрощения нашего макета, заменив</p>

<div class="code"><div class="highlight"><pre><span class="nt">&lt;title&gt;</span>Ruby on Rails Tutorial Sample App | <span class="cp">&lt;%=</span> <span class="vi">@title</span> <span class="cp">%&gt;</span><span class="nt">&lt;/title&gt;</span>
</pre></div>
</div>


<p>на</p>

<div class="code"><div class="highlight"><pre><span class="nt">&lt;title&gt;</span><span class="cp">&lt;%=</span> <span class="n">title</span> <span class="cp">%&gt;</span><span class="nt">&lt;/title&gt;</span>
</pre></div>
</div>


<p>как видно в <a class="ref" href="rails-flavored-ruby#code:application_layout_full_title">Листинге&nbsp;4.3</a>.
Обратите внимание, в частности, на переход от переменной экземпляра <code>@title</code> к  методу помощника <code>title</code> (без знака&nbsp;<code>@</code>). Используя Autotest или <code>rspec spec/</code>, вы можете убедиться, что тесты из  <a class="ref" href="static-pages#top">Главы&nbsp;3</a> все еще проходят.</p>

<div class="label" id="code:application_layout_full_title"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 4.3.</span> <span class="description">Макет сайта Пример приложения. <br /> <code>app/views/layouts/application.html.erb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span><span class="cp">&lt;%=</span> <span class="n">title</span> <span class="cp">%&gt;</span><span class="nt">&lt;/title&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">csrf_meta_tag</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="cp">&lt;%=</span> <span class="k">yield</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>
</div></div>




<div class="label" id="sec:cascading_style_sheets"></div>


<h3><a id="sec:4.1.2" href="rails-flavored-ruby#sec:cascading_style_sheets" class="heading"><span class="number">4.1.2</span> Каскадные Таблицы Стилей (CSS)</a></h3>


<p>Это второе дополнение к нашему сайту, оно покажется простым, но добавит несколько новых концепций Ruby: в том числе таблицы стилей в шаблон нашего сайта. Хотя эта книга о веб-разработке, а не о веб-дизайне, мы будем использовать каскадные таблицы стилей (CSS), чтобы придать примеру приложения некоторый минимальный стиль, и мы будем использовать фрэймворк <a href="http://www.blueprintcss.org/">Blueprint CSS</a> в качестве основы для этого стиля.</p>

<p>Для начала,  <a href="http://github.com/joshuaclayton/blueprint-css/zipball/master">скачайте последнюю версию Blueprint CSS</a>. (Для простоты я буду считать, что вы скачали Blueprint в папку <code>Downloads</code>, но вы можете использовать любую другую.) Используя командную строку либо графический инструмент, скопируйте папку Blueprint CSS <code>blueprint</code> в <code>public/stylesheets</code> - это специальный каталог, в котором Rails держит таблицы стилей. На моем Mac, команды выглядели так, но ваши команды могут отличаться:</p>

<div class="code"><div class="highlight"><pre><span class="nv">$ </span>cp -r ~/Downloads/joshuaclayton-blueprint-css-&lt;version number&gt;/blueprint <span class="se">\</span>
&gt; public/stylesheets/
</pre></div>
</div>


<p>Здесь <code>cp</code> является командой копирования Unix, и <code>-r</code>&nbsp;&mdash;&nbsp;флаг  рекурсивного копирования (необходимый для копирования директорий). (Как уже упоминалось вкратце в <a class="ref" href="static-pages#sec:autotest">Разделе&nbsp;3.2.1.1</a>, тильда <tt class="verb">~</tt> означает &ldquo;home directory&rdquo; в Unix.) <em>Примечание:</em> вы <em>не</em> должны вставлять символ&nbsp;<tt class="verb">&gt;</tt> в терминал. Если вы вставите первую строку с обратным слэшем (&ldquo; \&rdquo;) и нажмете Enter, вы увидите&nbsp;<tt class="verb">&gt;</tt>, указывающий на продолжение строки. Вам следует вставить вторую строку и снова нажать Enter, чтобы выполнить команду.  Отметим также, что вы должны будете заполнить номер версии вручную, т. к. он меняется при обновлении Blueprint. (<span class="c1"># я просто скопировал название папки, включающее и номер версии тоже, и  заменил им  «joshuaclayton-blueprint-css-&lt;номер версии&gt;»</span>) Наконец, убедитесь, что вы <em>не вводите</em></p>

<div class="code"><div class="highlight"><pre><span class="nv">$ </span>cp -r ~/Downloads/joshuaclayton-blueprint-css-&lt;version number&gt;/blueprint/ <span class="se">\</span>
&gt; public/stylesheets/
</pre></div>
</div>


<p>имеющее косую черту в <code>&hellip;/blueprint/</code>. Это вставит <em>содержимое</em> папки Blueprint в каталог <code>public/stylesheets</code> вместо перемещения всей папки.</p>

<p>После того как вы заполучили таблицы стилей в соответствующий каталог, Rails предоставляет помощника для включения их на наших страницах с помощью Embedded (встроенного) Ruby (<a class="ref" href="rails-flavored-ruby#code:layout_with_stylesheets">Листинг&nbsp;4.4</a>).</p>

<div class="label" id="code:layout_with_stylesheets"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 4.4.</span> <span class="description">Добавление таблиц стилей в макет примера приложения.<br /> <code>app/views/layouts/application.html.erb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span><span class="cp">&lt;%=</span> <span class="n">title</span> <span class="cp">%&gt;</span><span class="nt">&lt;/title&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">csrf_meta_tag</span> <span class="cp">%&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/screen&#39;</span><span class="p">,</span> <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;screen&#39;</span> <span class="cp">%&gt;</span>
    <span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/print&#39;</span><span class="p">,</span>  <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;print&#39;</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="cp">&lt;%=</span> <span class="k">yield</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>
</div></div>


<p>Обратим внимание на новые строки:</p>

<div class="code"><div class="highlight"><pre><span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/screen&#39;</span><span class="p">,</span> <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;screen&#39;</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/print&#39;</span><span class="p">,</span>  <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;print&#39;</span> <span class="cp">%&gt;</span>
</pre></div>
</div>


<p>Они используют встроенный в Rails помощник <code>stylesheet_link_tag</code>, о котором вы можете прочитать больше на Rails API.<sup class="footnote" id="fnref:4.2"><a href="#fn:4.2">2</a></sup> Первая <code>stylesheet_link_tag</code> строка включает таблицу стилей <code>blueprint/screen.css</code> для экранов (например, компьютерных мониторов), а вторая включает в себя <code>blueprint/print.css</code> для печати.   (Помощник автоматически добавляет <code>.css</code> расширение к именам файлов, если оно отсутствует, поэтому я опустил его для краткости). Как и с <code>title</code> помощником (хелпером), для опытного Rails разработчика эти строки выглядят просто, но в них есть по крайней мере четыре новых Ruby идеи: встроенные в Rails методы, вызов метода с отсутствующими скобками, символы и хэши.  В этой главе мы рассмотрим эти новые идеи. (Мы увидим, HTML произведенный включением этих таблиц стилей в <a class="ref" href="rails-flavored-ruby#code:css_source">Листинге&nbsp;4.6</a>  <a class="ref" href="rails-flavored-ruby#sec:css_revisited">Раздела&nbsp;4.3.4</a>.)</p>

<p>Кстати, с новыми таблицами стилей сайт не сильно изменился, но это только начало (<a class="ref" href="rails-flavored-ruby#fig:home_with_stylesheet">Рис.&nbsp;4.1</a>). Мы будем строить на этой основе, начиная с <a class="ref" href="filling-in-the-layout#top">Главы&nbsp;5</a>.<sup class="footnote" id="fnref:4.3"><a href="#fn:4.3">3</a></sup></p>

<div class="label" id="fig:home_with_stylesheet"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/home_with_stylesheet.png" alt="home_with_stylesheet" /></span></div><div class="caption"><span class="header">Рисунок  4.1: </span><span class="description">Home страница с новыми Blueprint таблицами стилей.&nbsp;<a href="http://railstutorial.org/images/figures/home_with_stylesheet-full.png">(полный размер)</a></span></div></div>




<div class="label" id="sec:strings_and_methods"></div>


<h2><a id="sec:4.2" href="rails-flavored-ruby#sec:strings_and_methods" class="heading"><span class="number">4.2</span> Строки и методы</a></h2>


<p>Нашим основным инструментом для изучения Ruby будет <em>Rails консоль</em>, которая является утилитой командной строки для работы с Rails приложениями.  Сама консоль построена на интерактивном Ruby (<code>irb</code>), и таким образом, имеет доступ ко всей мощности Ruby. (Как мы увидим в <a class="ref" href="rails-flavored-ruby#sec:a_controller_class">Разделе&nbsp;4.4.4</a>, консоль также имеет доступ к среде Rails.) Запуск консоли в командной строке происходит следующим образом:<sup class="footnote" id="fnref:4.4"><a href="#fn:4.4">4</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console</span>
<span class="go">Loading development environment (Rails 3.0.9)</span>
<span class="gp">&gt;&gt; </span>
</pre></div>
</div>


<p>По умолчанию консоль запускается в <em>окружении разработки (development environment)</em>, которое является одним из трех отдельных окружений определенных в Rails (другие&nbsp;&mdash;&nbsp;<em>тестирование</em> и <em>производство</em> (<em>test</em> и <em>production</em>)). Это различие не будет иметь важного значения в этой главе, мы узнаем больше об окружениях в <a class="ref" href="modeling-and-viewing-users-one#sec:rails_environments">Разделе&nbsp;6.3.1</a>.</p>

<p>Консоль это замечательный инструмент обучения, и вы  можете чувствовать себя свободно при ее использовании&nbsp;&mdash;&nbsp;не волнуйтесь, вы (вероятно) ничего не сломаете. При использовании консоли, нажмите Ctrl-C, если вы застряли, или Ctrl-D для выхода из консоли в целом.</p>

<p>На протяжении оставшейся части этой главы, вы, возможно, найдете полезным консультироваться с Ruby API.<sup class="footnote" id="fnref:4.5"><a href="#fn:4.5">5</a></sup> Она упакована (возможно, даже <em>слишком</em> упакована) информацией, например, чтобы узнать больше о строках Ruby вы можете посмотреть на Ruby API вступление для <code>String</code> класса.</p>

<div class="label" id="sec:comments"></div>


<h3><a id="sec:4.2.1" href="rails-flavored-ruby#sec:comments" class="heading"><span class="number">4.2.1</span> Комментарии</a></h3>


<p>Ruby <em>комментарии</em> начинаются со знака <a href="http://ru.wikipedia.org/wiki/%D0%9E%D0%BA%D1%82%D0%BE%D1%82%D0%BE%D1%80%D0%BF">фунт&nbsp;<code>#</code></a> и распространяются до конца строки. Ruby (и, следовательно, Rails) игнорирует коментарии, но они полезны для читателей (в том числе, часто, для самого автора!). В коде</p>

<div class="code"><div class="highlight"><pre>  <span class="c1"># Return a title on a per-page basis.</span>
  <span class="k">def</span> <span class="nf">title</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
</pre></div>
</div>


<p>первая строка является комментарием с указанием цели последующего определения функции.</p>

<p>Обычно, вам не нужно включать комментарии в консольные сессии, но в учебных целях, я в дальнейшем буду включать некоторые коментарии, например:</p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console</span>
<span class="gp">&gt;&gt; </span><span class="mi">17</span> <span class="o">+</span> <span class="mi">42</span>   <span class="c1"># Integer addition</span>
<span class="go">=&gt; 59</span>
</pre></div>
</div>


<p>Если вы,  двигаясь по этому разделу, будете набирать или копипастить команды в вашу консоль, вы можете, конечно, опустить комментарии, если хотите; консоль будет игнорировать их в любом случае.</p>

<div class="label" id="sec:strings"></div>


<h3><a id="sec:4.2.2" href="rails-flavored-ruby#sec:strings" class="heading"><span class="number">4.2.2</span> Строки</a></h3>


<p><em>Строки</em> это, вероятно, наиболее важная структура данных для веб-приложений, так как веб-страницы, в конечном счете, состоят из строк символов отправленных с сервера в браузер. Давайте начнем изучение строк с консолью, в этот раз запустив ее командой <code>rails&nbsp;c</code>, что является сокращением для <code>rails console</code>:</p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails c</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;&quot;</span>         <span class="c1"># An empty string</span>
<span class="go">=&gt; &quot;&quot;</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;foo&quot;</span>      <span class="c1"># A nonempty string</span>
<span class="go">=&gt; &quot;foo&quot;</span>
</pre></div>
</div>


<p>Это <em>string literals (буквальная (литеральная) строка)</em> (также, забавно называемая <em>текстовая строка</em>), созданная с использованием двойной кавычки&nbsp;<code>"</code>. Консоль печатает результат вычисления каждой строки, который, в случае буквальной (литеральной) строки, и есть сама строка.</p>

<p>Мы можем также объединить строки <code>+</code> оператором:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s2">&quot;foo&quot;</span> <span class="o">+</span> <span class="s2">&quot;bar&quot;</span>    <span class="c1"># String concatenation</span>
<span class="go">=&gt; &quot;foobar&quot;</span>
</pre></div>
</div>


<p>Результат вычисления <code>"foo"</code> плюс <code>"bar"</code> это строка <code>"foobar"</code>.<sup class="footnote" id="fnref:4.6"><a href="#fn:4.6">6</a></sup></p>

<p>Другой  способ создания строк&nbsp;&mdash;&nbsp;через <em>интерполяцию</em> с помощью специального синтаксиса <code>#{}</code>:<sup class="footnote" id="fnref:4.7"><a href="#fn:4.7">7</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">first_name</span> <span class="o">=</span> <span class="s2">&quot;Michael&quot;</span>    <span class="c1"># Variable assignment</span>
<span class="go">=&gt; &quot;Michael&quot;</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">first_name</span><span class="si">}</span><span class="s2"> Hartl&quot;</span>     <span class="c1"># String interpolation</span>
<span class="go">=&gt; &quot;Michael Hartl&quot;</span>
</pre></div>
</div>


<p>Здесь мы <em>присвоили</em> значение <code>"Michael"</code> переменной <code>first_name</code> а затем интерполировали ее в строку <code>"#{first_name} Hartl"</code>. Мы также можем присвоить имя обеим строкам:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">first_name</span> <span class="o">=</span> <span class="s2">&quot;Michael&quot;</span>
<span class="go">=&gt; &quot;Michael&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">last_name</span> <span class="o">=</span> <span class="s2">&quot;Hartl&quot;</span>
<span class="go">=&gt; &quot;Hartl&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">first_name</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">last_name</span>    <span class="c1"># Concatenation, with a space in between</span>
<span class="go">=&gt; &quot;Michael Hartl&quot;</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">first_name</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">last_name</span><span class="si">}</span><span class="s2">&quot;</span>    <span class="c1"># The equivalent interpolation</span>
<span class="go">=&gt; &quot;Michael Hartl&quot;</span>
</pre></div>
</div>


<p>Отметим, что последние два выражения являются эквивалентными, но я предпочитаю интерполированную версию; добавление одного пробела <code>"&nbsp;"</code> кажется мне немного неуклюжим.</p>

<div class="label" id="sec:printing"></div>


<h4><a id="sec:4.2.2.1" href="rails-flavored-ruby#sec:printing" class="heading">Печать</a></h4>


<p>Для того, чтобы <em>напечатать</em> строку, наиболее часто используется Ruby функция <code>puts</code> (произносится как &ldquo;put ess&rdquo;, от &ldquo;put string&rdquo;):</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="s2">&quot;foo&quot;</span>     <span class="c1"># put string</span>
<span class="go">foo</span>
<span class="go">=&gt; nil</span>
</pre></div>
</div>


<p><code>Puts</code> метод работает с <em>побочным эффектом</em>: выражение <code>puts "foo"</code> выводит строку на экран, а затем возвращает <a href="http://www.answers.com/nil">буквально ничего</a>: <code>nil</code> это особое обозначение Ruby для &ldquo;<a href="http://www.youtube.com/watch?v=AsZ9qFofOwo">вообще ничего</a>&rdquo;. (В дальнейшем, я буду иногда опускать <code>=&gt; nil</code> часть для простоты.)</p>

<p>Использование <code>puts</code> автоматически добавляет символ новой строки&nbsp;<tt class="verb">\n</tt> к выводу; связанный <code>print</code> метод&nbsp;&mdash;&nbsp;нет:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;foo&quot;</span>    <span class="c1"># print string (same as puts, but without the newline)</span>
<span class="go">foo=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;foo</span><span class="se">\n</span><span class="s2">&quot;</span>  <span class="c1"># Same as puts &quot;foo&quot;</span>
<span class="go">foo</span>
<span class="go">=&gt; nil</span>
</pre></div>
</div>




<div class="label" id="sec:single_quoted_strings"></div>


<h4><a id="sec:4.2.2.2" href="rails-flavored-ruby#sec:single_quoted_strings" class="heading">Строки в одиночных кавычках</a></h4>


<p>Все примеры до сих пор использовали <em>строки в двойных кавычках</em>, но Ruby также поддерживает <em>строки в одиночных кавычках</em>. Для многих целей, оба типа строк идентично эффективны:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s1">&#39;foo&#39;</span>          <span class="c1"># A single-quoted string</span>
<span class="go">=&gt; &quot;foo&quot;</span>
<span class="gp">&gt;&gt; </span><span class="s1">&#39;foo&#39;</span> <span class="o">+</span> <span class="s1">&#39;bar&#39;</span>
<span class="go">=&gt; &quot;foobar&quot;</span>
</pre></div>
</div>


<p>Хотя есть важное отличие: Ruby не будет интерполировать строки в одиночных кавычках:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s1">&#39;#{foo} bar&#39;</span>     <span class="c1"># Single-quoted strings don&#39;t allow interpolation</span>
<span class="go">=&gt; &quot;\#{foo} bar&quot;</span>
</pre></div>
</div>


<p>Обратите внимание, как консоль возвращает значения с использованием строк в двойных кавычках, которые  требуют обратной косой черты, чтобы <em>маскировать</em> специальные символы, такие как&nbsp;<code>#</code>.</p>

<p>Если строки в двойных кавычках могут делать все то же, что и одиночно закавыченные, и могут интерполировать, какой смысл в  одиночных кавычках? Они часто бывают полезны, потому что они действительно буквальные, и хранят в точности такие символы, как вы вводите. Например, &ldquo;обратный слэш&rdquo; (бэкслэш)&nbsp;&mdash;&nbsp;символ специальный в большинстве систем, например,  буквальной новой строке&nbsp;<tt class="verb">\n</tt>. Если вы хотите чтобы  переменная содержала буквально обратный слэш, в одиночных кавычках это сделать проще:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s1">&#39;\n&#39;</span>       <span class="c1"># A literal &#39;backslash n&#39; combination</span>
<span class="go">=&gt; &quot;\\n&quot;</span>
</pre></div>
</div>


<p>Как и с символом&nbsp;<code>#</code> в нашем предыдущем примере, Ruby необходимо маскировать обратный слэш; посредством дополнительного бэкслэша, внутри строки в двойных кавычках, буквальный бэкслэш представлен <em>двумя</em> бэкслэшами. Для небольшого примера, как этот, это небольшое спасение, но если есть много элементов, которые нужно маскировать, это может реально помочь:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s1">&#39;Newlines (\n) and tabs (\t) both use the backslash character \.&#39;</span>
<span class="go">=&gt; &quot;Newlines (\\n) and tabs (\\t) both use the backslash character \\.&quot;</span>
</pre></div>
</div>




<div class="label" id="sec:objects_and_message_passing"></div>


<h3><a id="sec:4.2.3" href="rails-flavored-ruby#sec:objects_and_message_passing" class="heading"><span class="number">4.2.3</span> Объекты и передача сообщений</a></h3>


<p>Все в Ruby, включая строки и даже <code>nil</code>, является <em>объектом</em>. Мы увидим технический смысл этого выражения в <a class="ref" href="rails-flavored-ruby#sec:a_class_of_our_own">Разделе&nbsp;4.4.2</a>, но я не думаю, что кто-нибудь когда-нибудь понял объекты, прочитав определение в книге, вы должны создать свое интуитивное понимание объектов, видя множество примеров.</p>

<p>Проще описать, что объекты <em>делают</em>, на какие сообщения реагируют.  Объект, типа строки, например, может реагировать на сообщение <code>length</code>, которое возвращает количество символов в строке:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s2">&quot;foobar&quot;</span><span class="o">.</span><span class="n">length</span>        <span class="c1"># Passing the &quot;length&quot; message to a string</span>
<span class="go">=&gt; 6</span>
</pre></div>
</div>


<p>Как правило, сообщения, которые передаются объектам, это <em>методы</em>, которые являются функциями, определенными для этих объектов.<sup class="footnote" id="fnref:4.8"><a href="#fn:4.8">8</a></sup> Строки также реагируют на <code>empty?</code> метод:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s2">&quot;foobar&quot;</span><span class="o">.</span><span class="n">empty?</span>
<span class="go">=&gt; false</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">empty?</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>Обратите внимание на знак вопроса в конце <code>empty?</code> метода. Это конвенция Ruby обозначающая, что возвращаемое значение&nbsp;&mdash;&nbsp;<em>boolean (булево, логика)</em>: <code>true (истина)</code> или <code>false (ложь)</code>. Булевые  особенно полезны для <em>управления потоком</em>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;foobar&quot;</span>
<span class="gp">&gt;&gt; </span><span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">empty?</span>
<span class="gp">&gt;&gt; </span>  <span class="s2">&quot;The string is empty&quot;</span>
<span class="gp">&gt;&gt; </span><span class="k">else</span>
<span class="gp">&gt;&gt; </span>  <span class="s2">&quot;The string is nonempty&quot;</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">=&gt; &quot;The string is nonempty&quot;</span>
</pre></div>
</div>


<p>Булевы также могут быть объединены с помощью <code>&amp;&amp;</code> (&ldquo;И&rdquo;), <code>||</code> (&ldquo;ИЛИ&rdquo;), и <code>!</code> (&ldquo;НЕ&rdquo;) операторов:</p>


<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span>
<span class="go">=&gt; &quot;foo&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="go">=&gt; &quot;&quot;</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="s2">&quot;Both strings are empty&quot;</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">empty?</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">.</span><span class="n">empty?</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="s2">&quot;One of the strings is empty&quot;</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">empty?</span> <span class="o">||</span> <span class="n">y</span><span class="o">.</span><span class="n">empty?</span>
<span class="go">&quot;One of the strings is empty&quot;</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="s2">&quot;x is not empty&quot;</span> <span class="k">if</span> <span class="o">!</span><span class="n">x</span><span class="o">.</span><span class="n">empty?</span>
<span class="go">&quot;x is not empty&quot;</span>
</pre></div>
</div>


<p>Поскольку все в Ruby является объектом, следовательно, <code>nil</code> тоже является объектом, поэтому он тоже может отвечать на методы. Одним из примеров является <code>to_s</code> метод, который может конвертировать практически любой объект в строку:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="kp">nil</span><span class="o">.</span><span class="n">to_s</span>
<span class="go">=&gt; &quot;&quot;</span>
</pre></div>
</div>


<p>Это, конечно, кажется, пустой строкой, что мы можем проверить, <em>цепочкой</em> сообщений, передаваемых к <code>nil</code>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="kp">nil</span><span class="o">.</span><span class="n">empty?</span>
<span class="go">NoMethodError: You have a nil object when you didn&#39;t expect it!</span>
<span class="go">You might have expected an instance of Array.</span>
<span class="go">The error occurred while evaluating nil.empty?</span>
<span class="gp">&gt;&gt; </span><span class="kp">nil</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">empty?</span>      <span class="c1"># Message chaining</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>Здесь мы видим, что <code>nil</code> объект сам по себе не реагирует на <code>empty?</code> метод, но <code>nil.to_s</code> реагирует.</p>

<p>Вот специальный метод для проверки на <code>nil</code>-ность, о котором вы могли догадаться:</p>



<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s2">&quot;foo&quot;</span><span class="o">.</span><span class="n">nil?</span>
<span class="go">=&gt; false</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">nil?</span>
<span class="go">=&gt; false</span>
<span class="gp">&gt;&gt; </span><span class="kp">nil</span><span class="o">.</span><span class="n">nil?</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>Если вы посмотрите на <a class="ref" href="rails-flavored-ruby#code:title_helper">Листинг&nbsp;4.2</a>, вы увидите, что <code>title</code> помощник тестирует, является ли <code>@title</code>&nbsp;&mdash;&nbsp;<code>nil</code>, используя <code>nil?</code> метод. Это намек на то, что есть что-то особенное в переменных экземпляра (переменных с&nbsp;<code>@</code> знаком), что может быть лучше понятым, противопоставлением их обычным переменным.  Например, предположим, что мы вводим <code>title</code> и <code>@title</code> переменные в консоли не определив их вначале:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">title</span>        <span class="c1"># Oops! We haven&#39;t defined a title variable.</span>
<span class="go">NameError: undefined local variable or method `title&#39; </span>
<span class="gp">&gt;&gt; </span><span class="vi">@title</span>       <span class="c1"># An instance variable in the console</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="s2">&quot;There is no such instance variable.&quot;</span> <span class="k">if</span> <span class="vi">@title</span><span class="o">.</span><span class="n">nil?</span>
<span class="go">There is no such instance variable.</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;</span><span class="si">#{</span><span class="vi">@title</span><span class="si">}</span><span class="s2">&quot;</span>  <span class="c1"># Interpolating @title when it&#39;s nil</span>
<span class="go">=&gt; &quot;&quot;</span>
</pre></div>
</div>


<p>Вы можете видеть из этого примера, что Ruby жалуется, если мы попытаемся оценить неопределенные локальные переменные, но не жалуется при обращении к переменной экземпляра, вместо этого, переменная экземпляра&nbsp;&mdash;&nbsp;<code>nil</code> если она не определена.  Это также объясняет, почему код</p>

<div class="code"><div class="highlight"><pre>Ruby on Rails Tutorial Sample App | <span class="cp">&lt;%=</span> <span class="vi">@title</span> <span class="cp">%&gt;</span>
</pre></div>
</div>


<p>становится</p>

<div class="code"><div class="highlight"><pre>Ruby on Rails Tutorial Sample App |
</pre></div>
</div>


<p>когда <code>@title</code> является <code>nil</code>: Embedded Ruby вставляет строку, соответствующую данной переменной, а строкой, соответствующей <code>nil</code> является&nbsp;<code>""</code>.</p>

<p>Последний пример также показывает альтернативное использование ключевого слова <code>if</code> Ruby позволяет писать утверждение, которое вычисляется только тогда, когда оператор, следующий за <code>if</code> это истина. Есть дополнительное ключевое слово <code>unless</code> которое работает так же:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;foobar&quot;</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="s2">&quot;The string &#39;</span><span class="si">#{</span><span class="n">string</span><span class="si">}</span><span class="s2">&#39; is nonempty.&quot;</span> <span class="k">unless</span> <span class="n">string</span><span class="o">.</span><span class="n">empty?</span>
<span class="go">The string &#39;foobar&#39; is nonempty.</span>
<span class="go">=&gt; nil</span>
</pre></div>
</div>


<p>Стоит отметить, что <code>nil</code> объект уникален, тем, что это <em>единственный</em> объект Ruby, который является ложью в булевом контексте, кроме, непосредственно, <code>false</code>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="k">if</span> <span class="kp">nil</span>
<span class="gp">&gt;&gt; </span>  <span class="kp">true</span>
<span class="gp">&gt;&gt; </span><span class="k">else</span>
<span class="gp">&gt;&gt; </span>  <span class="kp">false</span>        <span class="c1"># nil is false</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">=&gt; false</span>
</pre></div>
</div>


<p>В частности, все другие объекты Ruby являются <em>true</em>, даже 0:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="k">if</span> <span class="mi">0</span>
<span class="gp">&gt;&gt; </span>  <span class="kp">true</span>        <span class="c1"># 0 (and everything other than nil and false itself) is true</span>
<span class="gp">&gt;&gt; </span><span class="k">else</span>
<span class="gp">&gt;&gt; </span>  <span class="kp">false</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<div class="label" id="sec:method_definitions"></div>


<h3><a id="sec:4.2.4" href="rails-flavored-ruby#sec:method_definitions" class="heading"><span class="number">4.2.4</span> Определение метода</a></h3>


<p>Консоль позволяет определять методы точно так же, как мы это делали с <code>home</code> действием из <a class="ref" href="static-pages#code:pages_controller">Листинга&nbsp;3.6</a> или <code>title</code> помощником из <a class="ref" href="rails-flavored-ruby#code:title_helper">Листинга&nbsp;4.2</a>. (Определение методов в консоли - немного громоздкое мероприятие, и обычно вы будете использовать файл, но это удобно для демонстрационных целей.) Например, давайте определим функцию <code>string_message</code> которая принимает один <em>аргумент</em> и возвращает сообщение в зависимости от того, пустой аргумент или нет:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="k">def</span> <span class="nf">string_message</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
<span class="gp">&gt;&gt; </span>  <span class="k">if</span> <span class="n">string</span><span class="o">.</span><span class="n">empty?</span>
<span class="gp">&gt;&gt; </span>    <span class="s2">&quot;It&#39;s an empty string!&quot;</span>
<span class="gp">&gt;&gt; </span>  <span class="k">else</span>
<span class="gp">&gt;&gt; </span>    <span class="s2">&quot;The string is nonempty.&quot;</span>
<span class="gp">&gt;&gt; </span>  <span class="k">end</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="n">string_message</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="go">It&#39;s an empty string!</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="n">string_message</span><span class="p">(</span><span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
<span class="go">The string is nonempty.</span>
</pre></div>
</div>


<p>Обратите внимание, что Ruby функции имеют <em>неявное возвращение</em> (скрытый return) то есть, они возвращают последнее оцененное утверждение&nbsp;&mdash;&nbsp;в данном случае, одну из двух строк сообщения, в зависимости от того, пуст или нет аргумент <code>string</code>.  Ruby также имеет явный вариант возвращения (явный return); следующие функции эквивалентны приведенным выше:</p>


<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="k">def</span> <span class="nf">string_message</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
<span class="gp">&gt;&gt; </span>  <span class="k">return</span> <span class="s2">&quot;It&#39;s an empty string!&quot;</span> <span class="k">if</span> <span class="n">string</span><span class="o">.</span><span class="n">empty?</span>
<span class="gp">&gt;&gt; </span>  <span class="k">return</span> <span class="s2">&quot;The string is nonempty.&quot;</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
</pre></div>
</div>


<p>Внимательный читатель может заметить в этой точке, что второе <code>return</code> здесь фактически ненужно&nbsp;&mdash;&nbsp;состояние последнего выражения в функции, т.е. строки <code>"The string is nonempty."</code> будет возвращено независимо от ключевого слова <code>return</code>, но  использование <code>return</code> в обоих местах придает ему приятную симметрию.</p>

<div class="label" id="sec:back_to_the_title_helper"></div>


<h3><a id="sec:4.2.5" href="rails-flavored-ruby#sec:back_to_the_title_helper" class="heading"><span class="number">4.2.5</span> Возвращение к <code>title</code> хелперу</a></h3>


<p>Теперь мы в состоянии понять <code>title</code> помощника из <a class="ref" href="rails-flavored-ruby#code:title_helper">Листинга&nbsp;4.2</a>:<sup class="footnote" id="fnref:4.9"><a href="#fn:4.9">9</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="k">module</span> <span class="nn">ApplicationHelper</span>

  <span class="c1"># Return a title on a per-page basis.               # Documentation comment</span>
  <span class="k">def</span> <span class="nf">title</span>                                           <span class="c1"># Method definition</span>
    <span class="n">base_title</span> <span class="o">=</span> <span class="s2">&quot;Ruby on Rails Tutorial Sample App&quot;</span>  <span class="c1"># Variable assignment</span>
    <span class="k">if</span> <span class="vi">@title</span><span class="o">.</span><span class="n">nil?</span>                                    <span class="c1"># Boolean test for nil</span>
      <span class="n">base_title</span>                                      <span class="c1"># Implicit return</span>
    <span class="k">else</span>
      <span class="s2">&quot;</span><span class="si">#{</span><span class="n">base_title</span><span class="si">}</span><span class="s2"> | </span><span class="si">#{</span><span class="vi">@title</span><span class="si">}</span><span class="s2">&quot;</span>                     <span class="c1"># String interpolation</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>


<p>Все эти элементы&nbsp;&mdash;&nbsp;определение функции, присваивание переменной, логические тесты, управление потоком, и интерполяция строки&nbsp;&mdash;&nbsp;собраны вместе, чтобы сделать компактный вспомогательный метод для использования в макете нашего сайта. Последним элементом является <code>module ApplicationHelper</code>: код в модулях Ruby может быть <em>подмешан</em> в Ruby классы. При написании обычных Ruby, вы часто пишете модули и сами их явно включаете, но в данном случае Rails делает включение за нас, автоматически. Результатом является то, что <code>title</code> метод <a href="http://catb.org/jargon/html/A/automagically.html">автомагически</a> доступен во всех наших представлениях.</p>

<div class="label" id="sec:other_data_structures"></div>


<h2><a id="sec:4.3" href="rails-flavored-ruby#sec:other_data_structures" class="heading"><span class="number">4.3</span> Другие структуры данных</a></h2>


<p>Хотя веб-приложения, в конечном счете это строки, фактически, для <em>изготовления</em> этих строк требуется также использование других структур данных. В этом разделе мы узнаем о некоторых структурах данных Ruby, важных для написания приложений Rails.</p>

<div class="label" id="sec:arrays_and_ranges"></div>


<h3><a id="sec:4.3.1" href="rails-flavored-ruby#sec:arrays_and_ranges" class="heading"><span class="number">4.3.1</span> Массивы и диапазоны</a></h3>

<p>Массив это всего лишь список элементов в определенном порядке.  Мы еще не обсуждали массивы  в <em>Rails Tutorial</em>, но их понимание дает хорошую основу для понимания хэшей (<a class="ref" href="rails-flavored-ruby#sec:hashes_and_symbols">Раздел&nbsp;4.3.3</a>) и для аспектов Rails моделирования данных (таких как <code>has_many</code> ассоциации, которые мы  видели в <a class="ref" href="a-demo-app#sec:demo_user_has_many_microposts">Разделе&nbsp;2.3.3</a> и больше раскроем в <a class="ref" href="user-microposts#sec:user_micropost_associations">Разделе&nbsp;11.1.2</a>).</p>

<p>Мы потратили много времени на понимание строк, и есть естественный способ перейти от строк к массивам, используя <code>split</code> метод:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span> <span class="s2">&quot;foo bar     baz&quot;</span><span class="o">.</span><span class="n">split</span>     <span class="c1"># Split a string into a three-element array</span>
<span class="go">=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span>
</pre></div>
</div>


<p>Результатом этой операции является массив из трех строк. По умолчанию, <code>split</code> делит строку на массив путем разделения по пробелу, но вы можете разделить практически по чему угодно:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s2">&quot;fooxbarxbazx&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="go">=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span>
</pre></div>
</div>


<p>Как это принято в большинстве языков программирования, Ruby массивы&nbsp;&mdash;&nbsp;<em>нулевого сдвига</em>, что означает, что первый элемент массива имеет индекс&nbsp;0, второй имеет индекс&nbsp;1, и так далее:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="o">[</span><span class="mi">42</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">17</span><span class="o">]</span>
<span class="go">=&gt; [42, 8, 17]</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>               <span class="c1"># Ruby uses square brackets for array access.</span>
<span class="go">=&gt; 42</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
<span class="go">=&gt; 8</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span>
<span class="go">=&gt; 17</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">[-</span><span class="mi">1</span><span class="o">]</span>              <span class="c1"># Indices can even be negative!</span>
<span class="go">=&gt; 17</span>
</pre></div>
</div>


<p>Мы видим здесь, что Ruby использует квадратные скобки для доступа к элементам массива. В дополнение к этой скобковой записи, Ruby предлагает синонимы для некоторых часто используемых элементов:<sup class="footnote" id="fnref:4.10"><a href="#fn:4.10">10</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">a</span>                  <span class="c1"># Just a reminder of what &#39;a&#39; is</span>
<span class="go">=&gt; [42, 8, 17]</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">first</span>
<span class="go">=&gt; 42</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">second</span>
<span class="go">=&gt; 8</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">last</span>
<span class="go">=&gt; 17</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">last</span> <span class="o">==</span> <span class="n">a</span><span class="o">[-</span><span class="mi">1</span><span class="o">]</span>    <span class="c1"># Comparison using ==</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>Последняя строка вводит <a  href="http://ru.wikipedia.org/wiki/Сравнение_(программирование)">оператор проверки на равенство</a>  <code>==</code>, который Ruby разделяет со многими другими языками, как и связанные <code>!=</code> (&ldquo;не равно&rdquo;), и т.д.:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">length</span>       <span class="c1"># Like strings, arrays respond to the &#39;length&#39; method.</span>
<span class="go">=&gt; 3</span>
<span class="gp">&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="mi">3</span>
<span class="go">=&gt; true</span>
<span class="gp">&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span>
<span class="go">=&gt; false</span>
<span class="gp">&gt;&gt; </span><span class="n">x</span> <span class="o">!=</span> <span class="mi">1</span>
<span class="go">=&gt; true</span>
<span class="gp">&gt;&gt; </span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">1</span>
<span class="go">=&gt; true</span>
<span class="gp">&gt;&gt; </span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">1</span>
<span class="go">=&gt; false</span>
</pre></div>
</div>


<p>В дополнение к <code>length</code> (первая строка в приведенном выше примере), массивы отвечают на множество других методов:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sort</span>
<span class="go">=&gt; [8, 17, 42]</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">reverse</span>
<span class="go">=&gt; [17, 8, 42]</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">shuffle</span>
<span class="go">=&gt; [17, 42, 8]</span>
</pre></div>
</div>



<p>Вы также можете добавлять данные в массивы с помощью <code>push</code> (# отправить, толкнуть) метода или эквивалентного ему оператора <code>&lt;&lt;</code>:</p>


<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>                  <span class="c1"># Отправить 6 в массив</span>
<span class="go">=&gt; [42, 8, 17, 6]</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span>                     <span class="c1"># Отправить 7 в массив</span>
<span class="go">=&gt; [42, 8, 17, 6, 7]</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s2">"foo"</span> <span class="o">&lt;&lt;</span> <span class="s2">"bar"</span>        <span class="c1"># Сцепление отправляемых в массив данных</span>
<span class="go">=&gt; [42, 8, 17, 6, 7, "foo", "bar"]</span>
</pre></div>
</div>


<p>Последний пример показывает, что вы можете сцеплять добавления вместе, а также, что, в отличие от массивов во многих других языках, Ruby массивы могут содержать смесь различных типов (в данном случае, целые числа и строки).</p>

<p>Прежде, мы видели что <code>split</code> преобразовывает строку в массив. Мы также можем пойти другим путем с <code>join</code> методом:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">a</span>
<span class="go">=&gt; [42, 8, 17, 7, &quot;foo&quot;, &quot;bar&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">join</span>                       <span class="c1"># Join on nothing</span>
<span class="go">=&gt; &quot;428177foobar&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span>                 <span class="c1"># Join on comma-space</span>
<span class="go">=&gt; &quot;42, 8, 17, 7, foo, bar&quot;</span>
</pre></div>
</div>


<p>Тесно связаны с массивами <em>диапазоны</em>, которые проще всего понять посредством преобразования их в массивы, с помощью <code>to_a</code> метода:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">9</span>
<span class="go">=&gt; 0..9</span>
<span class="gp">&gt;&gt; </span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">9</span><span class="o">.</span><span class="n">to_a</span>              <span class="c1"># Oops, call to_a on 9</span>
<span class="go">ArgumentError: bad value for range</span>
<span class="gp">&gt;&gt; </span><span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span>            <span class="c1"># Use parentheses to call to_a on the range</span>
<span class="go">=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
</pre></div>
</div>


<p>Хотя <code>0..9</code> и является допустимым диапазоном, второе выражение показывает, что нам нужно добавить скобки для вызова метода на нем.</p>

<p>Диапазоны полезны для вытаскивания элементов из массива:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="sx">%w[foo bar baz quux]</span>         <span class="c1"># Use %w to make a string array.</span>
<span class="go">=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;quux&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">2</span><span class="o">]</span>
<span class="go">=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</span>
</pre></div>
</div>


<p>Диапазоны также работают с буквами:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">.</span><span class="n">.</span><span class="s1">&#39;e&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span>
<span class="go">=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span>
</pre></div>
</div>


<div class="label" id="sec:blocks"></div>


<h3><a id="sec:4.3.2" href="rails-flavored-ruby#sec:blocks" class="heading"><span class="number">4.3.2</span> Блоки</a></h3>


<p>И массивы и диапазоны отвечают на множество методов, которые принимают <em>блоки</em>, которые одновременно являются и самыми мощными и одними из самых непонятных  элементов Руби:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="nb">puts</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="p">}</span>
<span class="go">2</span>
<span class="go">4</span>
<span class="go">6</span>
<span class="go">8</span>
<span class="go">10</span>
<span class="go">=&gt; 1..5</span>
</pre></div>
</div>


<p>Этот код вызывает <code>each</code> метод на диапазоне <code>(1..5)</code> и передает ему блок <code>{ |i| puts 2 * i }</code>. Вертикальные линии вокруг имени переменной в&nbsp;<code>|i|</code> являются Ruby синтаксисом для блоковых переменных, и это позволяет методу узнать, что делать с блоком; в данном случае диапазонный <code>each</code> метод может обрабатывать блок с одной локальной переменной, которую мы называли&nbsp;<code>i</code>, и он просто выполняет блок для каждого значения в диапазоне.</p>

<p>Фигурные скобки это один из способов обозначить блок, но есть также второй способ:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
<span class="gp">?&gt; </span>  <span class="nb">puts</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">2</span>
<span class="go">4</span>
<span class="go">6</span>
<span class="go">8</span>
<span class="go">10</span>
<span class="go">=&gt; 1..5</span>
</pre></div>
</div>


<p>Блоки часто могут быть более чем из  одной строки. В <em>Rails Tutorial</em> мы будем следовать общей конвенции использования фигурных скобок только для коротких однострочных блоков и использовать <code>do..end</code> синтаксис для длинных однострочных и многострочных блоков:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">number</span><span class="o">|</span>
<span class="gp">?&gt; </span>  <span class="nb">puts</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">number</span>
<span class="gp">&gt;&gt; </span>  <span class="nb">puts</span> <span class="s1">&#39;--&#39;</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">2</span>
<span class="go">--</span>
<span class="go">4</span>
<span class="go">--</span>
<span class="go">6</span>
<span class="go">--</span>
<span class="go">8</span>
<span class="go">--</span>
<span class="go">10</span>
<span class="go">--</span>
<span class="go">=&gt; 1..5</span>
</pre></div>
</div>


<p>Здесь я использовал <code>number</code> вместо&nbsp;<code>i</code> просто чтобы подчеркнуть, что имя переменной может быть любым.</p>

<p>Если вы существенно не владеете основами программирования, нет короткой дороги к пониманию блоков; просто их нужно много увидеть, и, в конечном итоге, вы привыкнете к ним.<sup class="footnote" id="fnref:4.11"><a href="#fn:4.11">11</a></sup> К счастью, люди довольно хороши на обобщения на основе конкретных примеров; вот еще несколько примеров, в том числе пара с  использованием <code>map</code> метода:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="mi">3</span><span class="o">.</span><span class="n">times</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">&quot;Betelgeuse!&quot;</span> <span class="p">}</span>   <span class="c1"># 3.times takes a block with no variables.</span>
<span class="go">&quot;Betelgeuse!&quot;</span>
<span class="go">&quot;Betelgeuse!&quot;</span>
<span class="go">&quot;Betelgeuse!&quot;</span>
<span class="go">=&gt; 3</span>
<span class="gp">&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span><span class="o">**</span><span class="mi">2</span> <span class="p">}</span>          <span class="c1"># The ** notation is for &#39;power&#39;.</span>
<span class="go">=&gt; [1, 4, 9, 16, 25]</span>
<span class="gp">&gt;&gt; </span><span class="sx">%w[a b c]</span>                        <span class="c1"># Recall that %w makes string arrays.</span>
<span class="go">=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="sx">%w[a b c]</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">char</span><span class="o">|</span> <span class="n">char</span><span class="o">.</span><span class="n">upcase</span> <span class="p">}</span>
<span class="go">=&gt; [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span>
</pre></div>
</div>


<p>Как вы можете видеть, <code>map</code> метод возвращает результат применения данного блока для каждого элемента в массиве или диапазоне.</p>

<p>Кстати, теперь мы в состоянии понять строку Ruby, которую  я вбросил в <a class="ref" href="beginning#sec:heroku_commands">Разделе&nbsp;1.4.4</a> для генерации случайных субдоменов:</p>

<div class="code"><div class="highlight"><pre><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">.</span><span class="n">.</span><span class="s1">&#39;z&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span><span class="o">.</span><span class="n">shuffle</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">7</span><span class="o">].</span><span class="n">join</span>
</pre></div>
</div>


<p>Давайте разберем ее шаг за шагом:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">.</span><span class="n">.</span><span class="s1">&#39;z&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span>                     <span class="c1"># An alphabet array</span>
<span class="go">=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;,</span>
<span class="go">&quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">.</span><span class="n">.</span><span class="s1">&#39;z&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span><span class="o">.</span><span class="n">shuffle</span>             <span class="c1"># Shuffle it.</span>
<span class="go">=&gt; [&quot;c&quot;, &quot;g&quot;, &quot;l&quot;, &quot;k&quot;, &quot;h&quot;, &quot;z&quot;, &quot;s&quot;, &quot;i&quot;, &quot;n&quot;, &quot;d&quot;, &quot;y&quot;, &quot;u&quot;, &quot;t&quot;, &quot;j&quot;, &quot;q&quot;,</span>
<span class="go">&quot;b&quot;, &quot;r&quot;, &quot;o&quot;, &quot;f&quot;, &quot;e&quot;, &quot;w&quot;, &quot;v&quot;, &quot;m&quot;, &quot;a&quot;, &quot;x&quot;, &quot;p&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">.</span><span class="n">.</span><span class="s1">&#39;z&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span><span class="o">.</span><span class="n">shuffle</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">7</span><span class="o">]</span>       <span class="c1"># Pull out the first eight elements.</span>
<span class="go">=&gt; [&quot;f&quot;, &quot;w&quot;, &quot;i&quot;, &quot;a&quot;, &quot;h&quot;, &quot;p&quot;, &quot;c&quot;, &quot;x&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">.</span><span class="n">.</span><span class="s1">&#39;z&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span><span class="o">.</span><span class="n">shuffle</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">7</span><span class="o">].</span><span class="n">join</span>  <span class="c1"># Join them together to make one string.</span>
<span class="go">=&gt; &quot;mznpybuj&quot;</span>
</pre></div>
</div>




<div class="label" id="sec:hashes_and_symbols"></div>


<h3><a id="sec:4.3.3" href="rails-flavored-ruby#sec:hashes_and_symbols" class="heading"><span class="number">4.3.3</span> Хэши и символы </a></h3>


<p>Хэши, по существу, это объединение массивов: вы можете думать о хэшах в основном, как о массивах, но не ограничиваясь целочисленными индексами.  (В самом деле, некоторые языки, особенно Perl, иногда называют хэши <em>associative arrays (ассоциативными массивами)</em> по этой причине.) Вместо этого, хэш-индексами, <em>ключами</em>, могут быть практически любые объекты. Например, мы можем использовать строки в качестве ключей:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="p">{}</span>                          <span class="c1"># {} is an empty hash.</span>
<span class="go">=&gt; {}</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">[</span><span class="s2">&quot;first_name&quot;</span><span class="o">]</span> <span class="o">=</span> <span class="s2">&quot;Michael&quot;</span>     <span class="c1"># Key &quot;first_name&quot;, value &quot;Michael&quot;</span>
<span class="go">=&gt; &quot;Michael&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">[</span><span class="s2">&quot;last_name&quot;</span><span class="o">]</span> <span class="o">=</span> <span class="s2">&quot;Hartl&quot;</span>        <span class="c1"># Key &quot;last_name&quot;, value &quot;Hartl&quot;</span>
<span class="go">=&gt; &quot;Hartl&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">[</span><span class="s2">&quot;first_name&quot;</span><span class="o">]</span>                 <span class="c1"># Element access is like arrays.</span>
<span class="go">=&gt; &quot;Michael&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span>                               <span class="c1"># A literal representation of the hash</span>
<span class="go">=&gt; {&quot;last_name&quot;=&gt;&quot;Hartl&quot;, &quot;first_name&quot;=&gt;&quot;Michael&quot;}</span>
</pre></div>
</div>


<p>Хэши обозначаются фигурными скобками, содержащими пары ключ-значение; фигурные скобки, без пары ключ-значение, т. е. <code>{}</code>&nbsp;&mdash;&nbsp;это пустой хэш.  Важно отметить, что фигурные скобки для хэшей не имеют ничего общего с фигурными скобками для блоков.  (Да, это может привести к путанице.) Хотя хэши и напоминают массивы, одним важным отличием является то, что хэши не гарантируют сохранность их элементов в определенном порядке.<sup class="footnote" id="fnref:4.12"><a href="#fn:4.12">12</a></sup> Если порядок важен, используйте массив.</p>

<p>Вместо того, чтобы определять хэши попунктно, используя квадратные скобки, проще использовать их буквальное представление:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;first_name&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;Michael&quot;</span><span class="p">,</span> <span class="s2">&quot;last_name&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;Hartl&quot;</span> <span class="p">}</span>
<span class="go">=&gt; {&quot;last_name&quot;=&gt;&quot;Hartl&quot;, &quot;first_name&quot;=&gt;&quot;Michael&quot;}</span>
</pre></div>
</div>


<p>Здесь я использовал обычную конвенцию Ruby поместив дополнительные пробелы на двух концах хэша&nbsp;&mdash;&nbsp;конвенцию, игнорируемую при выводе на консоль.  (Не спрашивайте меня, почему пробелы попали в конвенцию; вероятно, раньше какому-то влиятельному Программисту Ruby понравился внешний вид лишних пробелов, и они застряли в конвенции)</p>

<p>До сих пор мы использовали строки в качестве хэш-ключей, но в Rails гораздо чаще вместо них используются <em>символы</em>. Символы выглядят как строки, но с префиксом двоеточие, а не в кавычках. Например, <code>:name</code> это символ. Вы можете думать о символах, в основном,  как о строках без дополнительного багажа:<sup class="footnote" id="fnref:4.13"><a href="#fn:4.13">13</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s2">&quot;name&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="go">=&gt; [&quot;n&quot;, &quot;a&quot;, &quot;m&quot;, &quot;e&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="ss">:name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="go">NoMethodError: undefined method `split&#39; for :name:Symbol</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;foobar&quot;</span><span class="o">.</span><span class="n">reverse</span>
<span class="go">=&gt; &quot;raboof&quot;</span>
<span class="gp">&gt;&gt; </span><span class="ss">:foobar</span><span class="o">.</span><span class="n">reverse</span>
<span class="go">NoMethodError: undefined method `reverse&#39; for :foobar:Symbol</span>
</pre></div>
</div>


<p>Символы это специальный тип данных Ruby, очень мало используемый в других языках, так что они могут показаться странными на первый взгляд, но Rails довольно часто их использует, так что вы быстро к ним привыкнете.</p>

<p>В терминах символов как хэш-ключей, мы можем определить <code>user</code> хэш следующим образом:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Michael Hartl&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;michael@example.com&quot;</span> <span class="p">}</span>
<span class="go">=&gt; {:name=&gt;&quot;Michael Hartl&quot;, :email=&gt;&quot;michael@example.com&quot;}</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">[</span><span class="ss">:name</span><span class="o">]</span>              <span class="c1"># Access the value corresponding to :name.</span>
<span class="go">=&gt; &quot;Michael Hartl&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">[</span><span class="ss">:password</span><span class="o">]</span>          <span class="c1"># Access the value of an undefined key.</span>
<span class="go">=&gt; nil</span>
</pre></div>
</div>


<p>Здесь мы видим из последнего примера, что хэш-значение для неопределенного ключа просто <code>nil</code>.</p>

<p>Хеш значениями может быть практически все, даже другие хэши, как видно в <a class="ref" href="rails-flavored-ruby#code:nested_hashes">Листинге&nbsp;4.5</a>.</p>

<div class="label" id="code:nested_hashes"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 4.5.</span> <span class="description">Вложенные хэши.</span> </div>
<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>        <span class="c1"># Define a hash called &#39;params&#39; (short for &#39;parameters&#39;).</span>
<span class="go">=&gt; {}</span>
<span class="gp">&gt;&gt; </span><span class="n">params</span><span class="o">[</span><span class="ss">:user</span><span class="o">]</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Michael Hartl&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;mhartl@example.com&quot;</span> <span class="p">}</span>
<span class="go">=&gt; {:name=&gt;&quot;Michael Hartl&quot;, :email=&gt;&quot;mhartl@example.com&quot;}</span>
<span class="gp">&gt;&gt; </span><span class="n">params</span>
<span class="go">=&gt; {:user=&gt;{:name=&gt;&quot;Michael Hartl&quot;, :email=&gt;&quot;mhartl@example.com&quot;}}</span>
<span class="gp">&gt;&gt; </span> <span class="n">params</span><span class="o">[</span><span class="ss">:user</span><span class="o">][</span><span class="ss">:email</span><span class="o">]</span>
<span class="go">=&gt; &quot;mhartl@example.com&quot;</span>
</pre></div>
</div></div>


<p>Этот вид хэшей-в-хэшах, или <em>вложенных хэшей</em>, интенсивно используется в Рельсах, как мы увидим в <a class="ref" href="sign-up#sec:signup_failure">Разделе&nbsp;8.2</a>.</p>

<p>Также как массивы и диапазоны, хэши реагируют на <code>each</code> метод. Рассмотрим, например, хэш с именем <code>flash</code> с ключами для двух условий <code>:success</code> и <code>:error</code>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">flash</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:success</span> <span class="o">=&gt;</span> <span class="s2">&quot;It worked!&quot;</span><span class="p">,</span> <span class="ss">:error</span> <span class="o">=&gt;</span> <span class="s2">&quot;It failed. :-(&quot;</span> <span class="p">}</span>
<span class="go">=&gt; {:success=&gt;&quot;It worked!&quot;, :error=&gt;&quot;It failed. :-(&quot;}</span>
<span class="gp">&gt;&gt; </span><span class="n">flash</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
<span class="gp">?&gt; </span>  <span class="nb">puts</span> <span class="s2">&quot;Key </span><span class="si">#{</span><span class="n">key</span><span class="o">.</span><span class="n">inspect</span><span class="si">}</span><span class="s2"> has value </span><span class="si">#{</span><span class="n">value</span><span class="o">.</span><span class="n">inspect</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">Key :success has value &quot;It worked!&quot;</span>
<span class="go">Key :error has value &quot;It failed. :-(&quot;</span>
</pre></div>
</div>


<p>Отметим, что в то время как <code>each</code> метод для массивов принимает блок только с одной переменной, <code>each</code> для хэшей принимает два&nbsp;&mdash;&nbsp;<em>ключ</em> и <em>значение</em>. Таким образом, <code>each</code> метод для хэшей итерирует по одной хэш <em>паре</em> ключ-значение за раз.</p>

<p>Последний пример использует полезный <code>inspect</code> метод, который возвращает строку с буквальным представлением объекта на котором он был вызван:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span>            <span class="c1"># Put an array as a string.</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">5</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span><span class="o">.</span><span class="n">inspect</span>    <span class="c1"># Put a literal array.</span>
<span class="go">[1, 2, 3, 4, 5]</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:name</span><span class="o">.</span><span class="n">inspect</span>
<span class="go">name</span>
<span class="go">:name</span>
<span class="gp">&gt;&gt; </span><span class="nb">puts</span> <span class="s2">&quot;It worked!&quot;</span><span class="p">,</span> <span class="s2">&quot;It worked!&quot;</span><span class="o">.</span><span class="n">inspect</span>
<span class="go">It worked!</span>
<span class="go">&quot;It worked!&quot;</span>
</pre></div>
</div>


<p>Кстати, использование <code>inspect</code> для печати объекта достаточно обычное явление, для этого даже есть специальное сокращение -  <code>p</code> функция:</p>


<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="nb">p</span> <span class="ss">:name</span>             <span class="c1"># Same as &#39;puts :name.inspect&#39;</span>
<span class="go">:name</span>
</pre></div>
</div>




<div class="label" id="sec:css_revisited"></div>


<h3><a id="sec:4.3.4" href="rails-flavored-ruby#sec:css_revisited" class="heading"><span class="number">4.3.4</span> Вновь CSS</a></h3>


<p>Пришло время снова посетить строки из <a class="ref" href="rails-flavored-ruby#code:layout_with_stylesheets">Листинга&nbsp;4.4</a> используемые в макете для включения каскадных таблиц стилей:</p>

<div class="code"><div class="highlight"><pre><span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/screen&#39;</span><span class="p">,</span> <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;screen&#39;</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/print&#39;</span><span class="p">,</span>  <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;print&#39;</span> <span class="cp">%&gt;</span>
</pre></div>
</div>


<p>Теперь мы почти в состоянии это понять.  Как уже упоминалось вкратце в <a class="ref" href="rails-flavored-ruby#sec:cascading_style_sheets">Разделе&nbsp;4.1.2</a>, Rails определяет специальную функцию для включения таблиц стилей и</p>

<div class="code"><div class="highlight"><pre><span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/screen&#39;</span><span class="p">,</span> <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;screen&#39;</span>
</pre></div>
</div>


<p>это вызов этой функции. Но есть две тайны.  Во-первых, где скобки? В Ruby, они не являются обязательными; эти две строки эквивалентны:</p>

<div class="code"><div class="highlight"><pre><span class="c1"># Parentheses on function calls are optional.</span>
<span class="n">stylesheet_link_tag</span><span class="p">(</span><span class="s1">&#39;blueprint/screen&#39;</span><span class="p">,</span> <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;screen&#39;</span><span class="p">)</span>
<span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/screen&#39;</span><span class="p">,</span> <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;screen&#39;</span>
</pre></div>
</div>


<p>Во-вторых, <code>:media</code> аргумент уверенно выглядит как хэш, но где фигурные скобки?  Когда хэш&nbsp;&mdash;&nbsp;<em>последний</em> аргумент в вызове функции, фигурные скобки не являются обязательными; эти две строки эквивалентны:</p>

<div class="code"><div class="highlight"><pre><span class="c1"># Curly braces on final hash arguments are optional.</span>
<span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/screen&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;screen&#39;</span> <span class="p">}</span>
<span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/screen&#39;</span><span class="p">,</span> <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;screen&#39;</span>
</pre></div>
</div>


<p>Таким образом, мы видим теперь, что каждая из строк</p>

<div class="code"><div class="highlight"><pre><span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/screen&#39;</span><span class="p">,</span> <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;screen&#39;</span> <span class="cp">%&gt;</span>
<span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s1">&#39;blueprint/print&#39;</span><span class="p">,</span>  <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s1">&#39;print&#39;</span> <span class="cp">%&gt;</span>
</pre></div>
</div>


<p>вызывает <code>stylesheet_link_tag</code> функцию с двумя аргументами: строкой, указывающей путь к таблице стилей, и хэшем, с указанием типа носителя ( <code>&rsquo;screen&rsquo;</code> для экрана компьютера и <code>&rsquo;print&rsquo;</code> для печатной версии). Из-за <tt class="verb">&lt;%= %&gt;</tt> скобок, результаты вставляются в шаблон ERb-ой, и если вы посмотрите исходный код страницы в браузере, вы должны увидеть HTML, необходимый для включении таблиц стилей  (<a class="ref" href="rails-flavored-ruby#code:css_source">Листинг&nbsp;4.6</a>).<sup class="footnote" id="fnref:4.14"><a href="#fn:4.14">14</a></sup></p>

<div class="label" id="code:css_source"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 4.6.</span> <span class="description">Исходный код HTML произведенный включением CSS.</span>
</div>
<div class="code"><div class="highlight"><pre><span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">&quot;/stylesheets/blueprint/screen.css&quot;</span> <span class="na">media=</span><span class="s">&quot;screen&quot;</span> <span class="na">rel=</span><span class="s">&quot;stylesheet&quot;</span>
<span class="na">type=</span><span class="s">&quot;text/css&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">&quot;/stylesheets/blueprint/print.css&quot;</span> <span class="na">media=</span><span class="s">&quot;print&quot;</span> <span class="na">rel=</span><span class="s">&quot;stylesheet&quot;</span>
<span class="na">type=</span><span class="s">&quot;text/css&quot;</span> <span class="nt">/&gt;</span>
</pre></div>
</div></div>




<div class="label" id="sec:ruby_classes"></div>


<h2><a id="sec:4.4" href="rails-flavored-ruby#sec:ruby_classes" class="heading"><span class="number">4.4</span> Ruby классы</a></h2>


<p>Мы говорили, что все в Ruby является объектами, и в этом разделе мы, наконец, определим несколько собственных классов. Ruby, как и многие другие объектно-ориентированные языки, использует <em>классы</em> чтобы организовать методы; эти классы, затем  <em>экземплируются</em> для создания объектов.  Если вы новичок в объектно-ориентированном программировании, это может звучать как бред, так что давайте посмотрим на некоторые конкретные примеры.</p>

<div class="label" id="sec:constructors"></div>


<h3><a id="sec:4.4.1" href="rails-flavored-ruby#sec:constructors" class="heading"><span class="number">4.4.1</span> Конструкторы</a></h3>


<p>Мы видели много примеров использования классов для создания экземпляра объекта, но нам еще предстоит сделать это в явном виде. Например, мы экземплировали строку с помощью двойных кавычек, которые являются <em>буквальным конструктором</em> для строк:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;foobar&quot;</span>       <span class="c1"># A literal constructor for strings using double quotes</span>
<span class="go">=&gt; &quot;foobar&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">class</span>
<span class="go">=&gt; String</span>
</pre></div>
</div>


<p>Мы видим здесь, что строки реагируют на метод <code>class</code>, и просто возвращают класс к которому они принадлежат.</p>

<p>Вместо использования буквального конструктора, можно использовать аналогичный <em>именованный конструктор</em>, что подразумевает вызов <code>new</code> метода на имени класса:<sup class="footnote" id="fnref:4.15"><a href="#fn:4.15">15</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="nb">String</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;foobar&quot;</span><span class="p">)</span>   <span class="c1"># A named constructor for a string</span>
<span class="go">=&gt; &quot;foobar&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">class</span>
<span class="go">=&gt; String</span>
<span class="gp">&gt;&gt; </span><span class="n">s</span> <span class="o">==</span> <span class="s2">&quot;foobar&quot;</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>Это эквивалентно буквальному конструктору, но это более четко говорит о том, что мы делаем.</p>

<p>Массивы в этом контексте работают так же как строки:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">]</span><span class="p">)</span>
<span class="go">=&gt; [1, 3, 2]</span>
</pre></div>
</div>


<p>Хэши работают по другому. Если конструктор массива <code>Array.new</code> принимает начальное значение для массива, <code>Hash.new</code> принимает значение по умолчанию для хэша, которое является значением хэша с несуществующим ключом:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="no">Hash</span><span class="o">.</span><span class="n">new</span>
<span class="go">=&gt; {}</span>
<span class="gp">&gt;&gt; </span><span class="n">h</span><span class="o">[</span><span class="ss">:foo</span><span class="o">]</span>            <span class="c1"># Try to access the value for the nonexistent key :foo.</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="no">Hash</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>    <span class="c1"># Arrange for nonexistent keys to return 0 instead of nil.</span>
<span class="go">=&gt; {}</span>
<span class="gp">&gt;&gt; </span><span class="n">h</span><span class="o">[</span><span class="ss">:foo</span><span class="o">]</span>
<span class="go">=&gt; 0</span>
</pre></div>
</div>




<div class="label" id="sec:a_class_of_our_own"></div>


<h3><a id="sec:4.4.2" href="rails-flavored-ruby#sec:a_class_of_our_own" class="heading"><span class="number">4.4.2</span> Наследование классов</a></h3>


<p>При изучении классов, полезно выяснять <em>иерархию классов</em>, используя <code>superclass</code> метод:</p>


<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="nb">String</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
<span class="go">=&gt; &quot;foobar&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">class</span>                        <span class="c1"># Find the class of s.</span>
<span class="go">=&gt; String</span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span>             <span class="c1"># Find the superclass of String.</span>
<span class="go">=&gt; Object</span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span>  <span class="c1"># Ruby 1.9 uses a new BasicObject base class</span>
<span class="go">=&gt; BasicObject </span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span>
<span class="go">=&gt; nil</span>
</pre></div>
</div>


<p>Диаграмма этой иерархии наследования представлена в <a class="ref" href="rails-flavored-ruby#fig:string_inheritance_ruby_1_9">Рис.&nbsp;4.2</a>. Мы видим здесь, что суперклассом <code>String</code> является <code>Object</code> , а суперкласс <code>Object</code> это <code>BasicObject</code>, но <code>BasicObject</code> не имеет  суперкласса. Эта модель относится к каждому объекту Ruby: можно проследить иерархию классов достаточно далеко, и каждый класс в Ruby в конечном счете наследуется от <code>BasicObject</code>, который не имеет своего суперкласса. Это техническое значение выражения &ldquo;все в Ruby является объектом&rdquo;.</p>

<div class="label" id="fig:string_inheritance_ruby_1_9"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/string_inheritance_ruby_1_9.png" alt="string_inheritance_ruby_1_9" /></span></div><div class="caption"><span class="header">Рис.  4.2: </span><span class="description">Иерархия наследования <code>String</code> класса.</span></div></div>


<p>Создание собственного класса незаменимо для более глубокого понимания классов. Давайте сделаем <code>Word</code> класс с <code>palindrome?</code> методом, который возвращает <code>true</code>, если слово можно читать и справа налево и слева направо, сохраняя смысл:</p>


<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="k">class</span> <span class="nc">Word</span>
<span class="gp">&gt;&gt; </span>  <span class="k">def</span> <span class="nf">palindrome?</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
<span class="gp">&gt;&gt; </span>    <span class="n">string</span> <span class="o">==</span> <span class="n">string</span><span class="o">.</span><span class="n">reverse</span>
<span class="gp">&gt;&gt; </span>  <span class="k">end</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">=&gt; nil</span>
</pre></div>
</div>


<p>Мы можем использовать его следующим образом:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="no">Word</span><span class="o">.</span><span class="n">new</span>              <span class="c1"># Make a new Word object.</span>
<span class="go">=&gt; #&lt;Word:0x22d0b20&gt;</span>
<span class="gp">&gt;&gt; </span><span class="n">w</span><span class="o">.</span><span class="n">palindrome?</span><span class="p">(</span><span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
<span class="go">=&gt; false</span>
<span class="gp">&gt;&gt; </span><span class="n">w</span><span class="o">.</span><span class="n">palindrome?</span><span class="p">(</span><span class="s2">&quot;level&quot;</span><span class="p">)</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>Если этот пример поражает вас, как немного надуманный, хорошо; это такой дизайн. Довольно странно создавать новый класс только для того чтобы создать метод принимающий строку в качестве аргумента. Поскольку слово это строка, более естественным решением будет <em>унаследовать</em> наш <code>Word</code> класс от <code>String</code>, как это показано в <a class="ref" href="rails-flavored-ruby#code:word_class">Листинге&nbsp;4.7</a>. (Вы должны выйти из консоли и ввести его заново, чтобы убрать старое определение <code>Word</code>.)</p>

<div class="label" id="code:word_class"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 4.7.</span> <span class="description">Определение <code>Word</code> класса в консоли.</span> </div>
<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="k">class</span> <span class="nc">Word</span> <span class="o">&lt;</span> <span class="nb">String</span>             <span class="c1"># Word inherits from String.</span>
<span class="gp">&gt;&gt; </span>  <span class="c1"># Return true if the string is its own reverse.</span>
<span class="gp">&gt;&gt; </span>  <span class="k">def</span> <span class="nf">palindrome?</span>
<span class="gp">&gt;&gt; </span>    <span class="nb">self</span> <span class="o">==</span> <span class="nb">self</span><span class="o">.</span><span class="n">reverse</span>        <span class="c1"># self is the string itself.</span>
<span class="gp">&gt;&gt; </span>  <span class="k">end</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">=&gt; nil</span>
</pre></div>
</div></div>


<p>Здесь <code>Word &lt; String</code> это Ruby-синтаксис  для наследования (кратко обсуждается в <a class="ref" href="static-pages#sec:static_pages_with_rails">Разделе&nbsp;3.1.2</a>), который гарантирует, что, в дополнение к новому <code>palindrome?</code> методу, words (слова) также имеют все те же методы, что и строки:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="no">Word</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;level&quot;</span><span class="p">)</span>    <span class="c1"># Make a new Word, initialized with &quot;level&quot;.</span>
<span class="go">=&gt; &quot;level&quot;                  </span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">palindrome?</span>            <span class="c1"># Words have the palindrome? method.</span>
<span class="go">=&gt; true                     </span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">length</span>                 <span class="c1"># Words also inherit all the normal string methods.</span>
<span class="go">=&gt; 5</span>
</pre></div>
</div>


<p>Так как <code>Word</code> класс наследует от <code>String</code> , мы можем использовать консоль, чтобы увидеть иерархию классов в явном виде:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">class</span>
<span class="go">=&gt; Word</span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span>
<span class="go">=&gt; String</span>
<span class="gp">&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span>
<span class="go">=&gt; Object</span>
</pre></div>
</div>


<p>Эта иерархия показана на <a class="ref" href="rails-flavored-ruby#fig:word_inheritance_ruby_1_9">Рис.&nbsp;4.3</a>.</p>

<div class="label" id="fig:word_inheritance_ruby_1_9"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/word_inheritance_ruby_1_9.png" alt="word_inheritance_ruby_1_9" /></span></div><div class="caption"><span class="header">Рисунок  4.3: </span><span class="description">Иерархия наследования (не встроенного) <code>Word</code> класса из <a class="ref" href="rails-flavored-ruby#code:word_class">Листинга&nbsp;4.7</a>.</span></div></div>


<p>В <a class="ref" href="rails-flavored-ruby#code:word_class">Листинге&nbsp;4.7</a>, обратите внимание, что проверка того, что слово является палиндромом включает в себя вызов слова внутри <code>Word</code> класса. Ruby позволяет нам сделать это, используя ключевое слово <code>self</code>: в <code>Word</code> классе, <code>self</code> является самим объектом, что означает, что мы можем использовать</p>

<div class="code"><div class="highlight"><pre><span class="nb">self</span> <span class="o">==</span> <span class="nb">self</span><span class="o">.</span><span class="n">reverse</span>
</pre></div>
</div>


<p>чтобы проверить, является ли  слово палиндромом.<sup class="footnote" id="fnref:4.16"><a href="#fn:4.16">16</a></sup></p>

<div class="label" id="sec:modifying_built_in_classes"></div>


<h3><a id="sec:4.4.3" href="rails-flavored-ruby#sec:modifying_built_in_classes" class="heading"><span class="number">4.4.3</span> Изменение встроенных классов</a></h3>


<p>Хотя наследование это мощная идея, в случае палиндромов может быть даже более естественно добавить <code>palindrome?</code> метод самому классу <code>String</code>, так что бы (среди прочего) мы могли вызвать <code>palindrome?</code> на буквальную строку, что мы в настоящее время не можем сделать:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s2">&quot;level&quot;</span><span class="o">.</span><span class="n">palindrome?</span>
<span class="go">NoMethodError: undefined method `palindrome?&#39; for &quot;level&quot;:String</span>
</pre></div>
</div>


<p>Несколько удивительно, что Ruby позволяет сделать это; Ruby классы могут быть <em>открыты</em> и изменены, простыми смертными, такими как мы, самостоятельно добавляющими методы к ним:<sup class="footnote" id="fnref:4.17"><a href="#fn:4.17">17</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="k">class</span> <span class="nc">String</span>
<span class="gp">&gt;&gt; </span>  <span class="c1"># Return true if the string is its own reverse.</span>
<span class="gp">&gt;&gt; </span>  <span class="k">def</span> <span class="nf">palindrome?</span>
<span class="gp">&gt;&gt; </span>    <span class="nb">self</span> <span class="o">==</span> <span class="nb">self</span><span class="o">.</span><span class="n">reverse</span>
<span class="gp">&gt;&gt; </span>  <span class="k">end</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;deified&quot;</span><span class="o">.</span><span class="n">palindrome?</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>(Я и не знаю что круче: то, что Ruby позволяет добавлять методы во встроенные классы или то, что слово <code>"deified"</code> является палиндромом.)</p>

<p>Изменение встроенных классов является мощной техникой, но с большой властью приходит большая ответственность и это считается дурным тоном добавлять методы к встроенным классам, не имея <em>действительно</em> хорошей причины для этого. Rails имеет несколько хороших причин (чтобы не делать этого); например, в веб-приложениях вы часто не хотите, чтобы переменные были <em>пустыми</em>; например, имя пользователя должно быть чем то другим, нежели ы и прочие <a href="http://ru.wikipedia.org/wiki/Пробел">пробелы</a>&mdash;и Rails добавляет <code>blank?</code> метод к Ruby.  Rails консоль автоматически включает Rails расширения, и мы можем увидеть это, например, здесь (это не будет работать в простом <code>irb</code> (Интерактивном Руби)):</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">blank?</span>
<span class="go">=&gt; true</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;      &quot;</span><span class="o">.</span><span class="n">empty?</span>
<span class="go">=&gt; false</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;      &quot;</span><span class="o">.</span><span class="n">blank?</span>
<span class="go">=&gt; true</span>
<span class="gp">&gt;&gt; </span><span class="kp">nil</span><span class="o">.</span><span class="n">blank?</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>Мы видим, что строка пробелов не является <em>пустой</em>, но она <em>чистая</em> (blank).  Отметим также, что <code>nil</code> является чистым, так как <code>nil</code> не является строкой, это намек, на то, что Rails фактически добавляет <code>blank?</code> к базовому классу <code>String</code>, которым (как мы видели в начале этого раздела) является сам Object. Мы увидим некоторые другие примеры Rails дополнений в Ruby классы в <a class="ref" href="sign-in-sign-out#sec:remember_me">Разделе&nbsp;9.3.2</a>.</p>

<div class="label" id="sec:a_controller_class"></div>


<h3><a id="sec:4.4.4" href="rails-flavored-ruby#sec:a_controller_class" class="heading"><span class="number">4.4.4</span> Класс контроллер</a></h3>


<p>Все эти разговоры о классах и наследованиях, возможно, вызвали вспышку узнавания, потому что мы видели их и раньше, в контроллере Pages (<a class="ref" href="static-pages#code:pages_controller_with_title">Листинг&nbsp;3.24</a>):</p>

<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">PagesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">home</span>
    <span class="vi">@title</span> <span class="o">=</span> <span class="s2">&quot;Home&quot;</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">contact</span>
    <span class="vi">@title</span> <span class="o">=</span> <span class="s2">&quot;Contact&quot;</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">about</span>
    <span class="vi">@title</span> <span class="o">=</span> <span class="s2">&quot;About&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>


<p>Теперь вы в состоянии оценить, по крайней мере смутно, что этот код означает: <code>PagesController</code> это класс, который наследует от <code>ApplicationController</code> и он оснащен <code>home</code>, <code>contact</code> и <code>about</code> методами, каждый из которых определяет переменную экземпляра <code>@title</code>. Так как каждый сеанс Rails консоли загружает локальную среду Rails, мы можем даже создать контроллер в явном виде и изучить иерархию его классов:<sup class="footnote" id="fnref:4.18"><a href="#fn:4.18">18</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">controller</span> <span class="o">=</span> <span class="no">PagesController</span><span class="o">.</span><span class="n">new</span>
<span class="go">=&gt; #&lt;PagesController:0x22855d0&gt;</span>
<span class="gp">&gt;&gt; </span><span class="n">controller</span><span class="o">.</span><span class="n">class</span>
<span class="go">=&gt; PagesController</span>
<span class="gp">&gt;&gt; </span><span class="n">controller</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span>
<span class="go">=&gt; ApplicationController</span>
<span class="gp">&gt;&gt; </span><span class="n">controller</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span>
<span class="go">=&gt; ActionController::Base</span>
<span class="gp">&gt;&gt; </span><span class="n">controller</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span>
<span class="go">=&gt; ActionController::Metal</span>
<span class="gp">&gt;&gt; </span><span class="n">controller</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span>
<span class="go">=&gt; AbstractController::Base</span>
<span class="gp">&gt;&gt; </span><span class="n">controller</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span><span class="o">.</span><span class="n">superclass</span>
<span class="go">=&gt; Object</span>
</pre></div>
</div>


<p>Диаграмма этой иерархии представлена на <a class="ref" href="rails-flavored-ruby#fig:pages_controller_inheritance_rails_3">Рис.&nbsp;4.4</a>.</p>

<div class="label" id="fig:pages_controller_inheritance_rails_3"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/pages_controller_inheritance_rails_3.png" alt="pages_controller_inheritance_rails_3" /></span></div><div class="caption"><span class="header">Рисунок  4.4: </span><span class="description">Иерархия наследования для контроллера Pages.</span></div></div>


<p>Мы можем даже вызвать действия контроллера в консоли, которые являются просто методами:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">controller</span><span class="o">.</span><span class="n">home</span>
<span class="go">=&gt; &quot;Home&quot;</span>
</pre></div>
</div>


<p>Это возвращение значения <code>"Home"</code> происходит от назначения <code>@title = "Home"</code> в <code>home</code> действии.</p>

<p>Но постойте: действия не имеют возвращаемых значений, по крайней мере не действия со знаком вопроса (#булевые). Целью <code>home</code> действия, как мы видели в <a class="ref" href="static-pages#top">Главе&nbsp;3</a>, является визуализация веб-страницы.  И я бы точно не забыл, если бы когда-либо вызывал <code>PagesController.new</code> где-нибудь. Что происходит?</p>

<p>Происходит вот что: Rails <em>написан</em> на Ruby, но Rails это не Ruby. Некоторые Rails классы используются как обычные объекты Ruby, но некоторые из них просто льют воду на Рельсовую "волшебную мельницу". Rails это <a href="http://ru.wikipedia.org/wiki/Sui_generis"><em>sui generis</em></a>, и должен быть изучен и понят отдельно от Ruby.  Именно поэтому, если ваш основной интерес программирования заключается в написании веб-приложений, я рекомендую изучать вначале Rails, затем изучать Ruby, затем вернуться обратно на рельсы.</p>

<div class="label" id="sec:a_user_class"></div>


<h3><a id="sec:4.4.5" href="rails-flavored-ruby#sec:a_user_class" class="heading"><span class="number">4.4.5</span> Класс user</a></h3>


<p>Мы закончим наше путешествие по Ruby комплектацией  собственного класса, <code>User</code> класса, который ожидает User модель которая появится в <a class="ref" href="modeling-and-viewing-users-one#top">Главе&nbsp;6</a>.</p>

<p>До сих пор мы вводили определения классов на консоли, но это быстро  стало  утомительным, вместо этого создайте файл <code>example_user.rb</code> в корневом каталоге Rails и заполните его содержимым  <a class="ref" href="rails-flavored-ruby#code:example_user">Листинга&nbsp;4.8</a>. (Напомним, из <a class="ref" href="beginning#sec:conventions">Раздела&nbsp;1.1.3</a> что корневой каталог Rails это корень вашего каталога приложения; например, корневой каталог Rails для моего  примера приложения это  <tt>/Users/mhartl/rails_projects/sample_app</tt>.)</p>

<div class="label" id="code:example_user"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 4.8.</span> <span class="description">Код для примера пользователя. <br /> <code>example_user.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span>
  <span class="kp">attr_accessor</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">attributes</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="vi">@name</span>  <span class="o">=</span> <span class="n">attributes</span><span class="o">[</span><span class="ss">:name</span><span class="o">]</span>
    <span class="vi">@email</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">[</span><span class="ss">:email</span><span class="o">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">formatted_email</span>
    <span class="s2">&quot;</span><span class="si">#{</span><span class="vi">@name</span><span class="si">}</span><span class="s2"> &lt;</span><span class="si">#{</span><span class="vi">@email</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Здесь довольно много чего происходит, так что давайте разбираться шаг за шагом.  Первая строка,</p>

<div class="code"><div class="highlight"><pre>  <span class="kp">attr_accessor</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span>
</pre></div>
</div>


<p>создает <em>атрибуты доступа</em> соответствующие имени пользователя и адресу электронной почты. Это создает &ldquo;получатель&rdquo; (&ldquo;getter&rdquo;) и &ldquo;назначатель&rdquo; (&ldquo;setter&rdquo;) методы, которые позволяют нам получать (get) и назначать (set) <code>@name</code> и <code>@email</code> переменные экземпляра.</p>

<p>Первый метод, <code>initialize</code>, специальный в Ruby: этот метод вызывается, когда мы выполняем <code>User.new</code>. Этот особенный <code>initialize</code> принимает один аргумент, <code>attributes</code>:</p>

<div class="code"><div class="highlight"><pre>  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">attributes</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="vi">@name</span>  <span class="o">=</span> <span class="n">attributes</span><span class="o">[</span><span class="ss">:name</span><span class="o">]</span>
    <span class="vi">@email</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">[</span><span class="ss">:email</span><span class="o">]</span>
  <span class="k">end</span>
</pre></div>
</div>


<p>Здесь <code>attributes</code> переменная имеет <em>значение по умолчанию</em> равное пустому хэшу, так что мы можем определить пользователя без имени или адреса электронной почты (напомним, из <a class="ref" href="rails-flavored-ruby#sec:hashes_and_symbols">Раздела&nbsp;4.3.3</a>, что хэши возвращают <code>nil</code> на несуществующие ключи, поэтому <code>attributes[:name]</code> будет <code>nil</code>, если нет <code>:name</code> ключа, и так же для <code>attributes[:email]</code>).</p>

<p>Наконец, наш класс определяет метод, называемый <code>formatted_email</code> который использует значения присваиваемые <code>@name</code> и <code>@email</code> переменным для создания отформатированной версии адреса электронной почты пользователя, используя  интерполяцию строки (<a class="ref" href="rails-flavored-ruby#sec:strings">Раздел&nbsp;4.2.2</a>):</p>

<div class="code"><div class="highlight"><pre>  <span class="k">def</span> <span class="nf">formatted_email</span>
    <span class="s2">&quot;</span><span class="si">#{</span><span class="vi">@name</span><span class="si">}</span><span class="s2"> &lt;</span><span class="si">#{</span><span class="vi">@email</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
  <span class="k">end</span>
</pre></div>
</div>


<p>Давайте запустим консоль, и <em>запросим</em> (require) код примера пользователя, и покрутим наш User класс.</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="nb">require</span> <span class="s1">&#39;./example_user&#39;</span>     <span class="c1"># This is how you load the example_user code.</span>
<span class="go">=&gt; [&quot;User&quot;]</span>
<span class="gp">&gt;&gt; </span><span class="n">example</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span>
<span class="go">=&gt; #&lt;User:0x224ceec @email=nil, @name=nil&gt;</span>
<span class="gp">&gt;&gt; </span><span class="n">example</span><span class="o">.</span><span class="n">name</span>                 <span class="c1"># nil since attributes[:name] is nil</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="n">example</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Example User&quot;</span>           <span class="c1"># Assign a non-nil name</span>
<span class="go">=&gt; &quot;Example User&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">example</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="s2">&quot;user@example.com&quot;</span>      <span class="c1"># and a non-nil email address</span>
<span class="go">=&gt; &quot;user@example.com&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">example</span><span class="o">.</span><span class="n">formatted_email</span>
<span class="go">=&gt; &quot;Example User &lt;user@example.com&gt;&quot;</span>
</pre></div>
</div>


<p>Здесь <code>&rsquo;.&rsquo;</code>&nbsp;&mdash;&nbsp;Unix обозначение для &ldquo;текущего каталога&rdquo;, и <code>&rsquo;./example_user&rsquo;</code> говорит Ruby искать файл примера пользователя относительно этого расположения. Последующий код создает пустого пользователя в качестве примера и затем заполняет имя и адрес электронной почты, присвоением непосредственно к соответствующим атрибутам (присвоение стало возможными благодаря <code>attr_accessor</code> строке в <a class="ref" href="rails-flavored-ruby#code:example_user">Листинге&nbsp;4.8</a>). Когда мы пишем</p>

<div class="code"><div class="highlight"><pre><span class="n">example</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Example User&quot;</span>
</pre></div>
</div>


<p>Ruby создает <code>@name</code> переменную для <code>"Example User"</code> (и аналогично для <code>email</code> атрибута), которую мы затем используем в <code>formatted_email</code> методе.</p>

<p>Ссылаясь на <a class="ref" href="rails-flavored-ruby#sec:css_revisited">Раздел&nbsp;4.3.4</a> мы можем опустить фигурные скобки для последнего хеш аргумента, мы можем создать другого пользователя, передавая хэш <code>initialize</code> методу для создания пользователя с заранее определенными атрибутами:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Michael Hartl&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;mhartl@example.com&quot;</span><span class="p">)</span>
<span class="go">=&gt; #&lt;User:0x225167c @email=&quot;mhartl@example.com&quot;, @name=&quot;Michael Hartl&quot;&gt;</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">formatted_email</span>
<span class="go">=&gt; &quot;Michael Hartl &lt;mhartl@example.com&gt;&quot;</span>
</pre></div>
</div>


<p>Мы увидим, начиная с <a class="ref" href="sign-up#top">Главы&nbsp;8</a> что инициализация объектов с использованием хэш аргумента является общепринятой в Rails приложениях.</p>

<div class="label" id="sec:exercises"></div>


<h2><a id="sec:4.5" href="rails-flavored-ruby#sec:exercises" class="heading"><span class="number">4.5</span> Упражнения</a></h2>




<ol>

<li>Используя <a class="ref" href="rails-flavored-ruby#code:string_shuffle">Листинг&nbsp;4.9</a> как руководство, скомбинировать <code>split</code>, <code>shuffle</code>, и <code>join</code> чтобы написать функцию, которая тасует буквы в данной строке.</li>

<li>Используя <a class="ref" href="rails-flavored-ruby#code:string_shuffle_two">Листинг&nbsp;4.10</a> как руководство, добавить <code>shuffle</code> метод к <code>String</code> классу.</li>

<li>Создайте три хэша, назовите их <code>person1</code>, <code>person2</code>, и <code>person3</code>, С именем (first name) и фамилией (last name) под ключами <code>:first</code> и <code>:last</code>. Затем создайте <code>params</code> хэш с тем, чтобы <code>params[:father]</code> являлся <code>person1</code>, <code>params[:mother]</code> являлся <code>person2</code>, и <code>params[:child]</code> являлся <code>person3</code> (father, mother, child это отец, мать, и ребенок соответственно). Убедитесь, что, например, <code>params[:father][:first]</code> имеет правильное значение.</li>

<li>Найдите онлайн версию Ruby API и почитайте о <code>Hash</code> методе <code>merge</code>.</li>
</ol>




<div class="label" id="code:string_shuffle"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 4.9.</span> <span class="description">Скелет для функции string shuffle.</span> </div>
<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="k">def</span> <span class="nf">string_shuffle</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt; </span>  <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="sc">?.</span><span class="p">?</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="n">string_shuffle</span><span class="p">(</span><span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
</pre></div>
</div></div>




<div class="label" id="code:string_shuffle_two"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 4.10.</span> <span class="description">Скелет для <code>shuffle</code> метода, принадлежащего <code>String</code> классу.</span> </div>
<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="k">class</span> <span class="nc">String</span>
<span class="gp">&gt;&gt; </span>  <span class="k">def</span> <span class="nf">shuffle</span>
<span class="gp">&gt;&gt; </span>    <span class="nb">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="sc">?.</span><span class="p">?</span>
<span class="gp">&gt;&gt; </span>  <span class="k">end</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="s2">&quot;foobar&quot;</span><span class="o">.</span><span class="n">shuffle</span>
</pre></div>
</div></div>




<div class="navigation">  <a class="prev_page" href="static-pages#top">
    &laquo;&nbsp;<span class="number">Глава 3</span> В основном статические страницы
  </a>
  <a class="next_page" href="filling-in-the-layout#top">
    <span class="number">Глава 5</span> Заполнение шаблона&nbsp;&raquo;
  </a>
</div><div class="footnotes">
<ol>
<li id="fn:4.1">Если помощник определен для конкретного контроллера, следует поместить его в соответствующий файл помощника; например, помощники для контроллера Pages обычно входят в <code>app/helpers/pages_helper.rb</code>. В нашем случае мы ожидаем, что помощник заголовка будет использоваться на страницах всего сайта, и у Rails есть специальный файл помощника для этого случая: <code>app/helpers/application_helper.rb</code>.&nbsp;<a class="arrow" href="#fnref:4.1">&uarr;</a></li>
<li id="fn:4.2">Я не даю ссылки на API, потому что у них есть тенденция быстро устаревать. Давайте Google будет вашей путеводной звездой. Кстати, &ldquo;API&rdquo; означает &ldquo;<a  href="http://ru.wikipedia.org/wiki/API">Application Programming Interface (Интерфейс прикладного программирования)</a>&rdquo;.&nbsp;<a class="arrow" href="#fnref:4.2">&uarr;</a></li>
<li id="fn:4.3">Если вы нетерпеливы, не стесняйтесь проверить <a href="https://github.com/joshuaclayton/blueprint-css/wiki">Blueprint CSS wiki</a>.&nbsp;<a class="arrow" href="#fnref:4.3">&uarr;</a></li>
<li id="fn:4.4">Вспомните, что консольное приглашение, вероятно, будет чем-то вроде <code>ruby-1.9.2-head &gt;</code>, но примеры используют&nbsp;<code>&gt;&gt;</code> так как версии Ruby изменяются.&nbsp;<a class="arrow" href="#fnref:4.4">&uarr;</a></li>
<li id="fn:4.5">Как и с Rails API, ссылки Ruby API выходят из моды, хотя и не так быстро. Google по-прежнему всегда готов вам помочь&nbsp;<a class="arrow" href="#fnref:4.5">&uarr;</a></li>
<li id="fn:4.6">Чтобы узнать больше о происхождении &ldquo;foo&rdquo; и &ldquo;bar&rdquo;&mdash;и, в частности возможном <em>не</em> отношении &ldquo;foobar&rdquo; к &ldquo;FUBAR&rdquo;&mdash;см. <a  href="http://www.catb.org/jargon/html/F/foo.html">&ldquo;foo&rdquo; в Jargon File</a>.&nbsp;</a>.&nbsp;<a class="arrow" href="#fnref:4.6">&uarr;</a></li>
<li id="fn:4.7">Програмисты, знакомые с Perl или PHP, должны сравнить это с автоматической интерполяцией переменных знака доллара в таких выражениях, как <code>"foo $bar"</code>.&nbsp;<a class="arrow" href="#fnref:4.7">&uarr;</a></li>
<li id="fn:4.8">Заранее извиняюсь за случайные переключения  между <code>функцией</code> и <code>методом</code> повсюду в этой главе; в Ruby они&nbsp;&mdash;&nbsp;одно и то же: все методы&nbsp;&mdash;&nbsp;функции, и все функции&nbsp;&mdash;&nbsp;методы, потому что все&nbsp;&mdash;&nbsp;объект.&nbsp;<a class="arrow" href="#fnref:4.8">&uarr;</a></li>
<li id="fn:4.9">Ну, все же осталась <em>одна</em> вещь, которую  мы не понимаем&nbsp;&mdash;&nbsp;как Rails связывает все это вместе: направление URL к действиям, делание <code>title</code> помощника доступным в представлениях, и т.д. Это интересная тема, и я поощряю вас исследовать ее далее, но точное знание того, <em>как</em> Rails работает, не является необходимым для <em>использования</em> Rails. (Для более глубокого понимания я рекомендую <a href="http://www.amazon.com/gp/product/0321601661?ie=UTF8&amp;tag=httpwwwrailst-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0321601661"><em>The Rails&nbsp;3 Way</em></a> Оби Фернандеса.)&nbsp;<a class="arrow" href="#fnref:4.9">&uarr;</a></li>
<li id="fn:4.10"><code>Second</code> метод, используемый здесь, не является в настоящий момент частью Ruby непосредственно, а скорее добавляется Rails. Это работает в данном случае, потому что консоль Rails автоматически включает Rails расширения в Ruby.&nbsp;<a class="arrow" href="#fnref:4.10">&uarr;</a></li>
<li id="fn:4.11">С другой стороны, искушенные программисты могут извлечь пользу из понимания, что блоки - это <em>замыкания</em>, объединяющие анонимные функции с внешними, по отношению к этим функциям, данными.&nbsp;<a class="arrow" href="#fnref:4.11">&uarr;</a></li>
<li id="fn:4.12">Ruby 1.9 фактически гарантирует, что хеши сохраняют свои элементы в том же самом порядке в каком они вводились, но было бы неблагоразумно когда-либо рассчитывать на определенный порядок.&nbsp;<a class="arrow" href="#fnref:4.12">&uarr;</a></li>
<li id="fn:4.13">В результате наличия меньшего количества багажа символы легче сравнить друг с другом; строки должны быть сравнены посимвольно, в то время как символы могут быть сравнены все одним разом. Это делает их идеальными для использования в качестве хеш ключей.&nbsp;<a class="arrow" href="#fnref:4.13">&uarr;</a></li>
<li id="fn:4.14">Можно увидеть немного пугающие числа, такие как <code>?1257465942</code>, после имен файла CSS. Они вставляются Rails, чтобы гарантировать, что браузеры перезагружают CSS, когда они изменяются на сервере.&nbsp;<a class="arrow" href="#fnref:4.14">&uarr;</a></li>
<li id="fn:4.15">Эти результаты могут изменятся, в зависимости от версии Ruby, которую вы используете. Этот пример предполагает, что вы используете Ruby&nbsp;1.9.2.&nbsp;<a class="arrow" href="#fnref:4.15">&uarr;</a></li>
<li id="fn:4.16">Для того чтобы узнать больше о классах Ruby и ключевом слове <code>self</code>, см.  <a href="http://railstips.org/">RailsTips</a> пост &ldquo;<a href="http://railstips.org/blog/archives/2006/11/18/class-and-instance-variables-in-ruby/">Class and Instance Variables in Ruby</a>&rdquo;.&nbsp;<a class="arrow" href="#fnref:4.16">&uarr;</a></li>
<li id="fn:4.17">Для знакомых с JavaScript, эта функциональность сопоставима с использованием встроенного class prototype object для расширения класса. (Спасибо читателю  <a href="http://getsatisfaction.com/railstutorial/topics/adding_methods_to_built_in_classes_comparable_to_using_javascripts_prototype_object">Erik Eldridge</a> за указание на это.)&nbsp;<a class="arrow" href="#fnref:4.17">&uarr;</a></li>
<li id="fn:4.18">Вы не должны знать, что делает каждый класс в этой иерархии. <em>Я</em> не знаю, что они все делают, и я программирую в Ruby on Rails с 2005. Это означает или что (a), я чрезвычайно некомпетентен или (b), можно быть квалифицированным  Rails разработчиком, не зная все его внутренности. Для нашей с вами пользы я уповаю на последнее.&nbsp;<a class="arrow" href="#fnref:4.18">&uarr;</a></li>
</ol>
</div>

