<div id="top"></div>


<h1 class="chapter"><a id="sec:7" href="modeling-and-viewing-users-two#top" class="heading"><span class="number">Глава 7</span> Моделирование и просмотр пользователей, часть II</a></h1>


<p>В <a class="ref" href="modeling-and-viewing-users-one#top">Главе&nbsp;6</a>, мы создали первую итерацию модели User представляющую пользователей нашего приложения, но работа сделана только наполовину. Практически любому веб-сайту с пользователями, в том числе нашему, необходима <em>аутентификация</em>, но в настоящее время любой пользователь, зарегистрировавшись на сайте, будет иметь только имя и адрес электронной почты, не имея возможности идентифицировать свою личность. В этой главе мы добавим атрибут <code>password</code> необходимый для начальной регистрации пользователя (<a class="ref" href="sign-up#top">Глава&nbsp;8</a>) и вход на сайт будет через указание комбинации электронная почта/пароль (<a class="ref" href="sign-in-sign-out#top">Глава&nbsp;9</a>). В процессе мы будем повторно использовать некоторые идеи из <a class="ref" href="modeling-and-viewing-users-one#top">Главы&nbsp;6</a>, в том числе миграции и валидации, а также введем некоторые новые идеи, такие как виртуальные атрибуты, приватные методы, и обратные вызовы (колбэки) Active Record.</p>

<p>После того как мы получим  <code>password</code> атрибут, мы сделаем рабочие действия и представления для отображения пользовательских профилей (<a class="ref" href="modeling-and-viewing-users-two#sec:better_user_views">Раздел&nbsp;7.3</a>). К концу этой главы, в профилях наших пользователей будут отображаться имена и аватары (как показано в макете <a class="ref" href="modeling-and-viewing-users-two#fig:profile_mockup_profile_name">Рис.&nbsp;7.1</a>), и они будут хорошо протестированы user <em>factories</em> (фабрикой пользователей).</p>

<p>Прежде чем двигаться дальше, давайте перезапустим базу данных командой <code>rake db:reset</code>, что очистит ее от старых пользователей из предыдущих разделов:</p>

<div class="code"><div class="highlight"><pre><span class="go">$ bundle exec rake db:reset</span>
</pre></div>
</div>


<div class="label" id="fig:profile_mockup_profile_name"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/profile_mockup_profile_name.png" alt="profile_mockup_profile_name" /></span></div><div class="caption"><span class="header">Рисунок  7.1: </span><span class="description">Макет пользовательского профиля, сделанного в <a class="ref" href="modeling-and-viewing-users-two#sec:better_user_views">Разделе&nbsp;7.3</a>.&nbsp;<a href="http://railstutorial.org/images/figures/profile_mockup_profile_name-full.png">(полный размер)</a></span></div></div>

<p><em>Примечание:</em> Разворачивание собственной системы аутентификации существенно упрощено в  Rails&nbsp;3.1. Платформа разрабатываемая в этой главе работает вполне корректно, но будущее издание этой книги реорганизует ее для использования новой  <code>has_secure_password</code> функции, предоставляемой  Rails&nbsp;3.1. См. также упражнения в  <a class="ref" href="rails-3-1#sec:rails_3_1_exercises">Разделе&nbsp;13.3</a>.</p>


<div class="label" id="sec:insecure_passwords"></div>


<h2><a id="sec:7.1" href="modeling-and-viewing-users-two#sec:insecure_passwords" class="heading"><span class="number">7.1</span> Небезопасные пароли</a></h2>


<p>Создание паролей промышленного уровня требует много машинерии, поэтому мы раздробим процесс на два этапа. В этом разделе мы создадим атрибут <code>password</code> и добавим валидации. В результате модель User будет функционально полной, но небезопасной, с паролями, которые хранятся в виде обычного текста в базе данных. В  <a class="ref" href="modeling-and-viewing-users-two#sec:secure_passwords">Разделе&nbsp;7.2</a>, мы решим эту проблему шифрованием паролей перед их сохранением, тем самым защитив наш сайт от потенциальных атак.</p>

<div class="label" id="sec:password_validations"></div>


<h3><a id="sec:7.1.1" href="modeling-and-viewing-users-two#sec:password_validations" class="heading"><span class="number">7.1.1</span> Валидации пароля</a></h3>

<p>Хотя мы еще даже не добавили колонку для паролей к нашей базе, мы начнем писать тесты для них. Наш первоначальный план - иметь тесты для валидации наличия, длины и подтверждения пароля.
Это наш самый большой единый блок испытаний до сих пор, так что увидим, сможете ли вы прочитать все за один раз. Если вы застрянете, вам может помочь пересмотр аналогичных проверок из <a class="ref" href="modeling-and-viewing-users-one#sec:user_validations">Раздела&nbsp;6.2</a> либо пропустите тесты и переходите сразу к коду приложения в <a class="ref" href="modeling-and-viewing-users-two#code:password_validations">Листинге&nbsp;7.2</a>.</p>

<p>В целях сведения к минимуму опечаток в паролях, при создании sign up страницы в <a class="ref" href="sign-up#top">Главе&nbsp;8</a>, мы реализуем общепринятую конвенцию запроса <em>подтверждения</em> пользователями их паролей. Для начала, давайте рассмотрим хэш пользовательских атрибутов из <a class="ref" href="modeling-and-viewing-users-one#code:validates_uniqueness_of_email_case_insensitive_test">Листинга&nbsp;6.20</a>:</p>

<div class="code"><div class="highlight"><pre><span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span> <span class="k">do</span>
    <span class="vi">@attr</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;user@example.com&quot;</span> <span class="p">}</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div>


<p>Чтобы написать тесты для паролей, нам необходимо добавить <em>два</em> новых атрибута к хэшу <code>@attr</code>: <code>password</code> (пароль) и <code>password_confirmation</code> (подтверждение пароля).  Как вы наверное догадались, атрибут <code>password_confirmation</code> будет использоваться для шага подтверждения пароля.</p>

<p>Давайте напишем тесты на наличие пароля и его подтверждение, а также тесты подтверждения валидности длины  (ограничение несколько произвольно и составляет от 6 до 40 символов). Результат представлен в <a class="ref" href="modeling-and-viewing-users-two#code:password_validation_tests">Листинге&nbsp;7.1</a>.</p>

<div class="label" id="code:password_validation_tests"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.1.</span> <span class="description">Тесты для валидации пароля. <br /> <code>spec/models/user_spec.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>

<span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>

  <span class="n">before</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span> <span class="k">do</span>
    <span class="vi">@attr</span> <span class="o">=</span> <span class="p">{</span>
      <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span>
      <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;user@example.com&quot;</span><span class="p">,</span>
      <span class="ss">:password</span> <span class="o">=&gt;</span> <span class="s2">&quot;foobar&quot;</span><span class="p">,</span>
      <span class="ss">:password_confirmation</span> <span class="o">=&gt;</span> <span class="s2">&quot;foobar&quot;</span>
    <span class="p">}</span>
  <span class="k">end</span>

  <span class="n">it</span> <span class="s2">&quot;should create a new instance given valid attributes&quot;</span> <span class="k">do</span>
    <span class="no">User</span><span class="o">.</span><span class="n">create!</span><span class="p">(</span><span class="vi">@attr</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">&quot;password validations&quot;</span> <span class="k">do</span>

    <span class="n">it</span> <span class="s2">&quot;should require a password&quot;</span> <span class="k">do</span>
      <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="vi">@attr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="ss">:password</span> <span class="o">=&gt;</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="ss">:password_confirmation</span> <span class="o">=&gt;</span> <span class="s2">&quot;&quot;</span><span class="p">))</span><span class="o">.</span>
        <span class="n">should_not</span> <span class="n">be_valid</span>
    <span class="k">end</span>

    <span class="n">it</span> <span class="s2">&quot;should require a matching password confirmation&quot;</span> <span class="k">do</span>
      <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="vi">@attr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="ss">:password_confirmation</span> <span class="o">=&gt;</span> <span class="s2">&quot;invalid&quot;</span><span class="p">))</span><span class="o">.</span>
        <span class="n">should_not</span> <span class="n">be_valid</span>
    <span class="k">end</span>

    <span class="n">it</span> <span class="s2">&quot;should reject short passwords&quot;</span> <span class="k">do</span>
      <span class="n">short</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span> <span class="o">*</span> <span class="mi">5</span>
      <span class="nb">hash</span> <span class="o">=</span> <span class="vi">@attr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="ss">:password</span> <span class="o">=&gt;</span> <span class="n">short</span><span class="p">,</span> <span class="ss">:password_confirmation</span> <span class="o">=&gt;</span> <span class="n">short</span><span class="p">)</span>
      <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span><span class="o">.</span><span class="n">should_not</span> <span class="n">be_valid</span>
    <span class="k">end</span>

    <span class="n">it</span> <span class="s2">&quot;should reject long passwords&quot;</span> <span class="k">do</span>
      <span class="n">long</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span> <span class="o">*</span> <span class="mi">41</span>
      <span class="nb">hash</span> <span class="o">=</span> <span class="vi">@attr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="ss">:password</span> <span class="o">=&gt;</span> <span class="n">long</span><span class="p">,</span> <span class="ss">:password_confirmation</span> <span class="o">=&gt;</span> <span class="n">long</span><span class="p">)</span>
      <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span><span class="o">.</span><span class="n">should_not</span> <span class="n">be_valid</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Отметьте в <a class="ref" href="modeling-and-viewing-users-two#code:password_validation_tests">Листинге&nbsp;7.1</a> как мы впервые собрали набор валидных атрибутов user в <code>@attr</code>. Если по каким-то причинам эти атрибуты станут не валидными, что может произойти если мы, например, как следует не реализуем подтверждение пароля — в этом случае первый тест</p>

<div class="code"><div class="highlight"><pre>  <span class="n">it</span> <span class="s2">&quot;should create a new instance given valid attributes&quot;</span> <span class="k">do</span>
    <span class="no">User</span><span class="o">.</span><span class="n">create!</span><span class="p">(</span><span class="vi">@attr</span><span class="p">)</span>
  <span class="k">end</span>
</pre></div>
</div>


<p>вызовет ошибку. Последующие тесты затем проверят каждую валидацию, в свою очередь, используя ту же <code>@attr.merge</code> технику что и в <a class="ref" href="modeling-and-viewing-users-one#code:failing_validates_name_spec">Листинге&nbsp;6.11</a>.</p>

<p>Теперь код приложения, в котором содержится трюк. На самом деле, он состоит из <em>двух</em> трюков. Во-первых, вы могли бы ожидать в этот момент, что мы запустим миграции для добавления <code>password</code> атрибута к модели User, как мы это делали с атрибутами <code>name</code> и <code>email</code> в  <a class="ref" href="modeling-and-viewing-users-one#code:generate_user_model">Листинге&nbsp;6.1</a>. Но это не так: мы будем хранить в базе данных только <em>зашифрованные</em> пароли; для пароля мы введем <em>виртуальный атрибут</em> (то есть, атрибут не соответствующий колонке в базе данных) используя метод <code>attr_accessor</code> так же как мы это делали с оригинальными <code>name</code> и <code>email</code> атрибутами образца пользователя в <a class="ref" href="rails-flavored-ruby#sec:a_user_class">Разделе&nbsp;4.4.5</a>. <code>Password</code> атрибут никогда не будет записан в базу данных, но будет существовать только в памяти для использования при выполнении шага подтверждения пароля (реализовано ниже) и шага шифрования (реализовано в <a class="ref" href="modeling-and-viewing-users-two#sec:password_migration">Разделе&nbsp;7.1.2</a> и <a class="ref" href="modeling-and-viewing-users-two#sec:secure_passwords">Разделе&nbsp;7.2</a>).</p>

<p>Второй фокус заключается в том, что мы <em>не</em> будем вводить атрибут <code>password_confirmation</code> , даже виртуальный. Вместо него мы будем использовать специальную валидацию</p>

<div class="code"><div class="highlight"><pre><span class="n">validates</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">:confirmation</span> <span class="o">=&gt;</span> <span class="kp">true</span>
</pre></div>
</div>


<p>которая <em>автоматически</em> создает виртуальный атрибут <code>password_confirmation</code>, одновременно подтверждая, что он совпадает с <code>password</code> атрибутом.</p>

<p>Таким образом, вы подготовлены к пониманию реализации, давайте посмотрим на сам код (<a class="ref" href="modeling-and-viewing-users-two#code:password_validations">Листинг&nbsp;7.2</a>).</p>

<div class="label" id="code:password_validations"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.2.</span> <span class="description">Валидации для атрибута <code>password</code>. <br /> <code>app/models/user.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="kp">attr_accessor</span> <span class="ss">:password</span>
  <span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">:password_confirmation</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="c1"># Automatically create the virtual attribute &#39;password_confirmation&#39;.</span>
  <span class="n">validates</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">:presence</span>     <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
                       <span class="ss">:confirmation</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
                       <span class="ss">:length</span>       <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:within</span> <span class="o">=&gt;</span> <span class="mi">6</span><span class="o">.</span><span class="n">.</span><span class="mi">40</span> <span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Как и было обещано, мы используем <code>attr_accessor :password</code> для создания виртуального <code>password</code> атрибута (как в <a class="ref" href="rails-flavored-ruby#sec:a_user_class">Разделе&nbsp;4.4.5</a>). Так как мы будем принимать пароль и подтверждение пароля как часть процесса регистрации из <a class="ref" href="sign-up#top">Главы&nbsp;8</a>, мы должны добавить пароль и его подтверждение в список доступных атрибутов (впервые упоминается в <a class="ref" href="modeling-and-viewing-users-one#sec:accessible_attributes">Разделе&nbsp;6.1.2.2</a>), что мы и сделали в строке</p>

<div class="code"><div class="highlight"><pre><span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:email</span><span class="p">,</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">:password_confirmation</span>
</pre></div>
</div>


<p>Далее идут валидации пароля. Они запрашивают наличие <code>:password</code> (как, например, в <a class="ref" href="modeling-and-viewing-users-one#code:validates_presence_of_name">Листинге&nbsp;6.7</a>) и включают <code>:confirmation =&gt; true</code> для отказа пользователям, чьи пароль и подтверждение пароля не совпадают. В коде также имеется второе применение валидации длины; в <a class="ref" href="modeling-and-viewing-users-one#code:length_validation">Листинге&nbsp;6.15</a> мы ограничили длину атрибута <code>name</code> 50 символами или менее, используя опцию <code>:maximum</code>:</p>

<div class="code"><div class="highlight"><pre><span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span>  <span class="ss">:presence</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
                  <span class="ss">:length</span>   <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:maximum</span> <span class="o">=&gt;</span> <span class="mi">50</span> <span class="p">}</span>
</pre></div>
</div>


<p>Вместо этого, для проверки длины пароля мы использовали <code>:within</code> ("в&nbsp;пределах") опцию, передав ей <em>диапазон</em><sup class="footnote" id="fnref:7.1"><a href="#fn:7.1">1</a></sup> <code>6..40</code> для обеспечения желаемого ограничения длины.</p>

<div class="label" id="sec:password_migration"></div>


<h3><a id="sec:7.1.2" href="modeling-and-viewing-users-two#sec:password_migration" class="heading"><span class="number">7.1.2</span> Миграция пароля</a></h3>


<p>В этой точке вы можете быть обеспокоены тем, что мы нигде не храним пароли пользователей; так как мы решили использовать виртуальный пароль, а не хранить его в базе данных, он существует только в памяти. Как мы можем использовать этот пароль для аутентификации? Решение состоит в создании отдельного атрибута, предназначенного для хранения паролей, и нашей стратегией будет использование виртуального пароля в качестве сырья для <em>зашифрованного</em> пароля, который мы <em>будем</em> хранить в базе данных после регистрации пользователя (<a class="ref" href="sign-up#top">Глава&nbsp;8</a>) и впоследствии будем использовать при аутентификации пользователей (<a class="ref" href="sign-in-sign-out#top">Глава&nbsp;9</a>).</p>

<p>Давайте запланируем хранить зашифрованные пароли, используя атрибут <code>encrypted_password</code>, в нашей модели User. Мы обсудим детали реализации в <a class="ref" href="modeling-and-viewing-users-two#sec:secure_passwords">Разделе&nbsp;7.2</a>, но мы можем начать работу с тестами для нашего зашифрованного пароля, отметив, что зашифрованный пароль должен, по крайней мере, <em>существовать</em>. Мы можем проверить это с помощью Ruby метода <code>respond_to?</code>, который принимает символ и возвращает <code>true</code> если объект отвечает данному методу или атрибуту и возвращает <code>false</code> в противном случае:</p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console --sandbox</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="ss">:password</span><span class="p">)</span>
<span class="go">=&gt; true</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="ss">:encrypted_password</span><span class="p">)</span>
<span class="go">=&gt; false</span>
</pre></div>
</div>


<p>Мы можем проверить существование атрибута <code>encrypted_password</code> с помощью кода из <a class="ref" href="modeling-and-viewing-users-two#code:respond_to_encrypted_password">Листинга&nbsp;7.3</a>, который использует вспомогательный RSpec метод <code>respond_to</code>.</p>

<div class="label" id="code:respond_to_encrypted_password"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.3.</span> <span class="description">Тестирование на существование атрибута <code>encrypted_password</code>. <br /> <code>spec/models/user_spec.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">&quot;password encryption&quot;</span> <span class="k">do</span>

    <span class="n">before</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span> <span class="k">do</span>
      <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">create!</span><span class="p">(</span><span class="vi">@attr</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">it</span> <span class="s2">&quot;should have an encrypted password attribute&quot;</span> <span class="k">do</span>
      <span class="vi">@user</span><span class="o">.</span><span class="n">should</span> <span class="n">respond_to</span><span class="p">(</span><span class="ss">:encrypted_password</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Отметьте, что в <code>before(:each)</code> блоке мы <em>create</em> (создаем) пользователя, а не просто вызываем <code>User.new</code>. Мы также могли бы заставить этот тест пройти, используя <code>User.new</code>, но (как мы увидим через мгновение) <em>установка</em> зашифрованного пароля требует, чтобы пользователь был сохранен в базе данных. Использование <code>create!</code> в этом первом случае не повредит, и помещение его в <code>before(:each)</code> позволит нам удержать все тесты зашифрованного пароля в одном <code>describe</code> блоке.</p>

<p>Чтобы получить прохождение этого теста нам необходимо выполнить миграцию, которая добавит атрибут <code>encrypted_password</code> к таблице <code>users</code>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> rails generate migration add_password_to_users encrypted_password:string
</pre></div>
</div>


<p>Здесь первый аргумент это имя миграции, и мы также добавляем второй аргумент с именем и типом атрибута, который мы хотим создать. (Сравните это с исходной генерацией таблицы <code>users</code> в <a class="ref" href="modeling-and-viewing-users-one#code:generate_user_model">Листинге&nbsp;6.1</a>.) Мы можем выбрать любое имя для миграции, но удобней будет закончить имя <code>_to_users</code>, так как в этом случае Rails может автоматически построить миграции и дополнить столбцы <code>users</code> таблицы. Кроме того, включив второй аргумент, мы дали Rails достаточно информации, чтобы построить для нас всю миграцию, как видно в <a class="ref" href="modeling-and-viewing-users-two#code:password_migration">Листинге&nbsp;7.4</a>.</p>

<div class="label" id="code:password_migration"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.4.</span> <span class="description">Миграция для добавления столбца <code>encrypted_password</code> к <code>users</code> таблице. <br /> <code>db/migrate/&lt;timestamp&gt;_add_password_to_users.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">AddPasswordToUsers</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">up</span>
    <span class="n">add_column</span> <span class="ss">:users</span><span class="p">,</span> <span class="ss">:encrypted_password</span><span class="p">,</span> <span class="ss">:string</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">down</span>
    <span class="n">remove_column</span> <span class="ss">:users</span><span class="p">,</span> <span class="ss">:encrypted_password</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Этот код использует метод <code>add_column</code> для добавления <code>encrypted_password</code> столбца к таблице <code>users</code> (и дополнительный метод <code>remove_column</code> для его удаления при migrating down). В результате получается модель данных, показанная на <a class="ref" href="modeling-and-viewing-users-two#fig:user_model_password">Рис.&nbsp;7.2</a>.</p>

<div class="label" id="fig:user_model_password"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/user_model_password.png" alt="user_model_password" /></span></div><div class="caption"><span class="header">Рисунок  7.2: </span><span class="description">Модель User с добавленным (зашифрованным) паролем.</span></div></div>


<p>Теперь если мы запустим миграции и подготовим тестовую базу данных, испытания должны пройти, так как модель User будет реагировать на атрибут <code>encrypted_password</code>. (Не забудьте закрыть все Rails консоли запущенные в песочнице; песочница закрывает базу данных и предотвращает миграцию.)</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rake db:migrate
<span class="gp">$</span> bundle <span class="nb">exec </span>rake db:test:prepare
</pre></div>
</div>


<p>Конечно, мы можем запустить полный набор тестов с <code>rspec spec/</code>, но иногда удобнее выполнить только <em>один</em> пример (тест) RSpec, что мы можем сделать используя флаг <code>-e</code> (“example” ('экземпляр')):</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rspec spec/models/user_spec.rb <span class="se">\</span>
<span class="gp">&gt;</span> -e <span class="s2">"should have an encrypted password attribute"</span>
<span class="go">.</span>

<span class="go">1 example, 0 failures</span>
</pre></div>
</div>


<div class="label" id="sec:an_active_record_callback"></div>


<h3><a id="sec:7.1.3" href="modeling-and-viewing-users-two#sec:an_active_record_callback" class="heading"><span class="number">7.1.3</span> Обратный вызов Active Record</a></h3>


<p>Теперь, когда наша модель User имеет атрибут для хранения паролей, мы должны организовать генерацию и сохранение зашифрованного пароля, при сохранении Active Record пользователя в базе данных. Мы будем делать это техникой, называемой <a   href="http://ru.wikipedia.org/wiki/Callback_(программирование)"><em>обратный вызов</em></a> (колбэк), которая представляет собой метод, который вызывается  в определенный момент  жизни  объекта Active Record. В данном случае, мы будем использовать обратный вызов <code>before_save</code> для создания <code>encrypted_password</code> непосредственно перед сохранением пользователя.<sup class="footnote" id="fnref:7.2"><a href="#fn:7.2">2</a></sup></p>

<p>Начнем с теста для атрибута зашифрованного пароля. Так как мы отложили детали реализации и, в частности, метод шифрования, до <a class="ref" href="modeling-and-viewing-users-two#sec:secure_passwords">Раздел&nbsp;7.2</a>, в этом разделе мы просто убедимся, что у сохраненного пользователя атрибут <code>encrypted_password</code> не является пустым. Мы сделаем это путем комбинации <code>blank?</code> метода на строке (<a class="ref" href="rails-flavored-ruby#sec:a_class_of_our_own">Раздел&nbsp;4.4.2</a>) с RSpec конвенцией для булевых методов (впервые показано в контексте <code>valid?</code>/<code>be_valid</code> в <a class="ref" href="modeling-and-viewing-users-one#code:failing_validates_name_spec">Листинге&nbsp;6.11</a>), что приведет нас к тесту в <a class="ref" href="modeling-and-viewing-users-two#code:encrypted_password_not_empty_test">Листинге&nbsp;7.5</a>.</p>

<div class="label" id="code:encrypted_password_not_empty_test"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.5.</span> <span class="description">Тестирование "непустоты" атрибута <code>encrypted_password</code>. <br /> <code>spec/models/user_spec.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">&quot;password encryption&quot;</span> <span class="k">do</span>

    <span class="n">before</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span> <span class="k">do</span>
      <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">create!</span><span class="p">(</span><span class="vi">@attr</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="n">it</span> <span class="s2">&quot;should set the encrypted password&quot;</span> <span class="k">do</span>
      <span class="vi">@user</span><span class="o">.</span><span class="n">encrypted_password</span><span class="o">.</span><span class="n">should_not</span> <span class="n">be_blank</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Этот код проверяет что <code>encrypted_password.blank?</code> не является истиной, используя конструкцию <code>should_not be_blank</code>.</p>

<p>Для того чтобы получить прохождение этого теста, мы <em>зарегистрируем</em> обратный вызов <code>encrypt_password</code> передачей символа его имени методу <code>before_save</code>, а затем определяя метод <code>encrypt_password</code> для выполнения шифрования. При наличии <code>before_save</code>, Active Record будет автоматически вызывать соответствующий метод перед сохранением записи. Результат представлен в <a class="ref" href="modeling-and-viewing-users-two#code:encrypt_password_callback">Листинге&nbsp;7.6</a>.</p>

<div class="label" id="code:encrypt_password_callback"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.6.</span> <span class="description">Обратный вызов <code>before_save</code> для создания атрибута <code>encrypted_password</code>. <br /> <code>app/models/user.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">validates</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">:presence</span>     <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
                       <span class="ss">:confirmation</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
                       <span class="ss">:length</span>       <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:within</span> <span class="o">=&gt;</span> <span class="mi">6</span><span class="o">.</span><span class="n">.</span><span class="mi">40</span> <span class="p">}</span>

  <span class="n">before_save</span> <span class="ss">:encrypt_password</span>

  <span class="kp">private</span>

    <span class="k">def</span> <span class="nf">encrypt_password</span>
      <span class="nb">self</span><span class="o">.</span><span class="n">encrypted_password</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">password</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
      <span class="n">string</span> <span class="c1"># Only a temporary implementation!</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Здесь обратный вызов <code>encrypt_password</code>  делегирует реальное шифрование методу <code>encrypt</code>; как отмечалось в комментарии, это лишь временная реализация - сейчас <a class="ref" href="modeling-and-viewing-users-two#code:encrypt_password_callback">Листинг&nbsp;7.6</a> просто устанавливает зашифрованным <em>нешифрованный</em> пароль, чтобы достигнуть цели. Но этого достаточно для прохождения наших тестов, и мы сделаем действительно шифрующий метод <code>encrypt</code> в <a class="ref" href="modeling-and-viewing-users-two#sec:secure_passwords">Раздел&nbsp;7.2</a>.</p>

<p>Прежде чем вы попытаетесь понять реализацию, отмечу, что методы шифрования идут после ключевого слова <code>private</code>; внутри Ruby классов, все методы, определенные <em>после</em> <code>private</code> используются внутри объекта и не предназначены для публичного использования.<sup class="footnote" id="fnref:7.3"><a href="#fn:7.3">3</a></sup> Для примера мы можем взглянуть на объект User в консоли:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">encrypt_password</span>
<span class="go">NoMethodError: Attempt to call private method</span>
</pre></div>
</div>


<p>Здесь Ruby вызывает исключение <code>NoMethodError</code> и выдает предупреждение, что <code>encrypt_password</code> это приватный метод.</p>

<p>В данном контексте, делать <code>encrypt_password</code> и <code>encrypt</code> методы приватными не обязательно, но делать их закрытыми, если они не нужны для открытого интерфейса это хорошая практика.<sup class="footnote" id="fnref:7.4"><a href="#fn:7.4">4</a></sup></p>

<p>Теперь, когда мы понимаем назначение ключевого слова <code>private</code>, давайте еще раз взглянем на метод <code>encrypt_password</code>:</p>

<div class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">encrypt_password</span>
  <span class="nb">self</span><span class="o">.</span><span class="n">encrypted_password</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">password</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>


<p>Это однострочный метод (лучший вид!), но он содержит не одну, а целых <em>две</em> тонкости. Во-первых, левая часть заявления явно назначает <code>encrypted_password</code> атрибут используя ключевое слово <code>self</code>. (Вспомните из <a class="ref" href="rails-flavored-ruby#sec:a_class_of_our_own">Раздела&nbsp;4.4.2</a> что внутри класса <code>self</code> вызывает сам метод, в случае модели User это просто пользователь.) Использование <code>self</code> <em>необходимо</em> в этом контексте; если бы мы опустили <code>self</code> и написали</p>

<div class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">encrypt_password</span>
  <span class="n">encrypted_password</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">password</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>


<p>Ruby создал бы <em>локальную переменную</em> <code>encrypted_password</code>, а это вовсе не то что нам нужно.</p>

<p>Во-вторых, правая сторона назначает вызовы <code>encrypt</code> на <code>password</code>, но мы нигде не видим <code>password</code>. В консоли мы могли бы получить доступ к атрибуту password через объект user</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:password</span> <span class="o">=&gt;</span> <span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">password</span>
<span class="go">=&gt; &quot;foobar&quot;</span>
</pre></div>
</div>


<p>Внутри класса User, объект user это просто <code>self</code>, и мы могли бы написать</p>

<div class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">encrypt_password</span>
  <span class="nb">self</span><span class="o">.</span><span class="n">encrypted_password</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="n">password</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>


<p>по аналогии с консольным примером, просто заменив <code>user</code> на <code>self</code>. Но <code>self</code> не является обязательным, поэтому для краткости мы можем писать просто</p>

<div class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">encrypt_password</span>
  <span class="nb">self</span><span class="o">.</span><span class="n">encrypted_password</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">password</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>


<p>как в <a class="ref" href="modeling-and-viewing-users-two#code:encrypt_password_callback">Листинге&nbsp;7.6</a>. (Конечно, как мы уже отметили, <code>self</code> является <em>обязательным</em> при назначении атрибута, поэтому мы должны написать <code>self.encrypted_password</code> в этом случае.)</p>

<div class="label" id="sec:secure_passwords"></div>


<h2><a id="sec:7.2" href="modeling-and-viewing-users-two#sec:secure_passwords" class="heading"><span class="number">7.2</span> Безопасные пароли</a></h2>


<p>С кодом из <a class="ref" href="modeling-and-viewing-users-two#sec:insecure_passwords">Раздела&nbsp;7.1</a>, в принципе мы сделали: хотя "зашифрованный" пароль совпадает с незашифрованным паролем, и пока мы готовы хранить незашифрованные пароли в базе данных, мы имеем необходимую основу для входа и аутентификации пользователей.<sup class="footnote" id="fnref:7.5"><a href="#fn:7.5">5</a></sup> Наши стандарты в Rails Учебнике значительно более высокие, хотя: любой веб-разработчик, который не зря ест свой хлеб, должен знать, как реализовать систему паролей с <em>безопасным односторонним хэшированием</em>. В этом разделе мы будем опираться на материал из <a class="ref" href="modeling-and-viewing-users-two#sec:insecure_passwords">Раздела&nbsp;7.1</a> для реализации именно такой, промышленного уровня, системы  паролей.</p>

<div class="label" id="sec:a_secure_password_test"></div>


<h3><a id="sec:7.2.1" href="modeling-and-viewing-users-two#sec:a_secure_password_test" class="heading"><span class="number">7.2.1</span> Тест безопасного пароля</a></h3>


<p>Как намекалось в <a class="ref" href="modeling-and-viewing-users-two#sec:an_active_record_callback">Разделе&nbsp;7.1.3</a>, весь механизм шифрования паролей будет спрятан в <code>private</code> регионе модели User, который представляет собой проблему для тестирования. Нам нужен какой-то <em>публичный интерфейс</em> который мы можем выставить в остальной части приложения. Одним из полезных аспектов разработки через тестирование является то, что, выступая в качестве клиента для нашего кода приложения, тесты мотивируют нас разрабатывать юзабельный интерфейс с самого начала.</p>

<p>Аутентификация пользователей предполагает сравнение зашифрованной версии подтверждаемого (отправляемого) пароля с (зашифрованным) паролем данного пользователя. Это означает, что мы должны определить какой-то метод для выполнения сравнения, мы назовем его <code>has_password?</code>; он и будет нашим публичным интерфейсом для машинерии шифрования.<sup class="footnote" id="fnref:7.6"><a href="#fn:7.6">6</a></sup> Метод  <code>has_password?</code> будет проверять имеет ли пользователь тот же пароль, что и отправленный в форме входа (будет сделана в <a class="ref" href="sign-in-sign-out#top">Главе&nbsp;9</a>); скелет метода <code>has_password?</code> показан в  <a class="ref" href="modeling-and-viewing-users-two#code:has_password_skeleton">Листинге&nbsp;7.7</a>.</p>

<div class="label" id="code:has_password_skeleton"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.7.</span> <span class="description">Метод  <code>has_password?</code> для пользователей.<br /> <code>app/models/user.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">before_save</span> <span class="ss">:encrypt_password</span>

  <span class="c1"># Return true if the user&#39;s password matches the submitted password.</span>
  <span class="k">def</span> <span class="nf">has_password?</span><span class="p">(</span><span class="n">submitted_password</span><span class="p">)</span>
    <span class="c1"># Compare encrypted_password with the encrypted version of</span>
    <span class="c1"># submitted_password.</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>С помощью этого метода, мы можем писать тесты как в <a class="ref" href="modeling-and-viewing-users-two#code:has_password_tests">Листинге&nbsp;7.8</a>, который использует RSpec методы <code>be_true</code> и <code>be_false</code> чтобы проверить что <code>has_password?</code> возвращает <code>true</code> или <code>false</code> в соответствующих случаях.</p>

<div class="label" id="code:has_password_tests"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.8.</span> <span class="description">Тесты для <code>has_password?</code> метода. <br /> <code>spec/models/user_spec.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">&quot;password encryption&quot;</span> <span class="k">do</span>

    <span class="n">before</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span> <span class="k">do</span>
      <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">create!</span><span class="p">(</span><span class="vi">@attr</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="n">describe</span> <span class="s2">&quot;has_password? method&quot;</span> <span class="k">do</span>

      <span class="n">it</span> <span class="s2">&quot;should be true if the passwords match&quot;</span> <span class="k">do</span>
        <span class="vi">@user</span><span class="o">.</span><span class="n">has_password?</span><span class="p">(</span><span class="vi">@attr</span><span class="o">[</span><span class="ss">:password</span><span class="o">]</span><span class="p">)</span><span class="o">.</span><span class="n">should</span> <span class="n">be_true</span>
      <span class="k">end</span>

      <span class="n">it</span> <span class="s2">&quot;should be false if the passwords don&#39;t match&quot;</span> <span class="k">do</span>
        <span class="vi">@user</span><span class="o">.</span><span class="n">has_password?</span><span class="p">(</span><span class="s2">&quot;invalid&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">should</span> <span class="n">be_false</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>В <a class="ref" href="modeling-and-viewing-users-two#sec:implementing_has_password">Разделе&nbsp;7.2.3</a> мы завершим реализацию <code>has_password?</code> (и получим проходящие тесты в процессе). Но вначале нам нужно узнать немного больше о безопасности паролей.</p>

<div class="label" id="sec:secure_password_theory"></div>


<h3><a id="sec:7.2.2" href="modeling-and-viewing-users-two#sec:secure_password_theory" class="heading"><span class="number">7.2.2</span> Немного теории безопасных паролей</a></h3>


<p>Основная идея зашифрованных паролей проста: вместо хранения самого пароля в базе данных (известно как "чистый текст"), мы сохраняем строку созданую с помощью  <a   href="http://ru.wikipedia.org/wiki/Криптографическая_хеш-функция">криптографической хэш-функции</a>, которая является по существу необратимой, так что даже злоумышленник владеющий хэшированным паролем не сможет вывести оригинал. Чтобы убедиться, что представленный пароль соответствует паролю пользователя, сначала зашифруем представленную строку, а затем сравним хэши. Давайте перейдем в консольную сессию, чтобы увидеть, как это работает:</p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console</span>
<span class="gp">&gt;&gt; </span><span class="nb">require</span> <span class="s1">&#39;digest&#39;</span>
<span class="gp">&gt;&gt; </span><span class="k">def</span> <span class="nf">secure_hash</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
<span class="gp">&gt;&gt; </span>  <span class="no">Digest</span><span class="o">::</span><span class="no">SHA2</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
<span class="gp">&gt;&gt; </span><span class="k">end</span>
<span class="go">=&gt; nil</span>
<span class="gp">&gt;&gt; </span><span class="n">password</span> <span class="o">=</span> <span class="s2">&quot;secret&quot;</span>
<span class="go">=&gt; &quot;secret&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">encrypted_password</span> <span class="o">=</span> <span class="n">secure_hash</span><span class="p">(</span><span class="n">password</span><span class="p">)</span>
<span class="go">=&gt; &quot;2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">submitted_password</span> <span class="o">=</span> <span class="s2">&quot;secret&quot;</span>
<span class="go">=&gt; &quot;secret&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">encrypted_password</span> <span class="o">==</span> <span class="n">secure_hash</span><span class="p">(</span><span class="n">submitted_password</span><span class="p">)</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>Здесь мы определили функцию <code>secure_hash</code> которая использует криптографическую хеш-функцию SHA2, часть <a   href="http://ru.wikipedia.org/wiki/SHA">SHA семейства криптографических хеш-функций</a>, которую мы включаем в Ruby через <code>digest</code> библиотеку. <sup class="footnote" id="fnref:7.7"><a href="#fn:7.7">7</a></sup> Не важно как именно работает эта хэш-функция; Для наших целей важно то, что они являются односторонними: нет вычислительного способа обнаружить, что </p>

<pre class="verbatim">2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b</pre>


<p>является SHA2 хэшем строки <code>"secret"</code>.</p>

<p>Однако если задуматься, у нас все же есть проблема: если злоумышленник каким-нибудь образом достанет хэшированные пароли, у него все же будет шанс на обнаружение оригиналов. Например, он мог бы догадаться, что мы использовали SHA2, и написать такую программу для сравнения данного хэша с хэшированными значениями потенциальных паролей: </p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="nb">hash</span> <span class="o">=</span> <span class="s2">&quot;2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">secure_hash</span><span class="p">(</span><span class="s2">&quot;secede&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span>
<span class="go">=&gt; false</span>
<span class="gp">&gt;&gt; </span><span class="n">secure_hash</span><span class="p">(</span><span class="s2">&quot;second&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span>
<span class="go">=&gt; false</span>
<span class="gp">&gt;&gt; </span><span class="n">secure_hash</span><span class="p">(</span><span class="s2">&quot;secret&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>Таким образом, у нашего злоумышленника есть очень плохие новости для всех пользователей с паролем <code>"secret"</code>. Эта техника также известна как <em>атака с применением <a   href="http://ru.wikipedia.org/wiki/Радужная_таблица"><em>радужных таблиц</em></a></em>.</p>

<p>Чтобы помешать потенциальной атаке с применением радужных таблиц, мы можем использовать, <a  rel="nofollow" href="http://ru.wikipedia.org/wiki/Salt#.D0.A3.D1.80.D0.BE.D0.B2.D0.BD.D0.B8_.D0.B7.D0.B0.D1.89.D0.B8.D1.82.D1.8B"><em>salt («соль», или «затравка»)</em></a>, которая представляет собой случайную и различную строку для каждого пользователя.<sup class="footnote" id="fnref:7.8"><a href="#fn:7.8">8</a></sup> Один из распространенных способов (почти) обеспечить уникальность заключается в хэшировании текущего времени (в <a  href="http://ru.wikipedia.org/wiki/UTC">UTC</a> чтобы не зависить от часового пояса) вместе с паролем, так что два пользователя будут иметь одинаковые соли, только если они создают в одно и то же время один и тот же пароль. Давайте посмотрим, как это работает, используя <code>secure_hash</code> функцию, определенную в консоли выше:</p>

<div class="code"><div class="highlight"><pre><span class="gp">&gt;&gt; </span><span class="no">Time</span><span class="o">.</span><span class="n">now</span><span class="o">.</span><span class="n">utc</span>
<span class="go">=&gt; Fri Jan 29 18:11:27 UTC 2010</span>
<span class="gp">&gt;&gt; </span><span class="n">password</span> <span class="o">=</span> <span class="s2">&quot;secret&quot;</span>
<span class="go">=&gt; &quot;secret&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">salt</span> <span class="o">=</span> <span class="n">secure_hash</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="no">Time</span><span class="o">.</span><span class="n">now</span><span class="o">.</span><span class="n">utc</span><span class="si">}</span><span class="s2">--</span><span class="si">#{</span><span class="n">password</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">=&gt; &quot;d1a3eb8c9aab32ec19cfda810d2ab351873b5dca4e16e7f57b3c1932113314c8&quot;</span>
<span class="gp">&gt;&gt; </span><span class="n">encrypted_password</span> <span class="o">=</span> <span class="n">secure_hash</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">salt</span><span class="si">}</span><span class="s2">--</span><span class="si">#{</span><span class="n">password</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">=&gt; &quot;69a98a49b7fd103058639be84fb88c19c998c8ad3639cfc5deb458018561c847&quot;</span>
</pre></div>
</div>


<p>В последней строке мы хэшировали соль с паролем, что дает зашифрованный пароль, который практически невозможно взломать. (Для ясности аргументы хэшируемых функций часто разделены&nbsp;<tt class="verb">--</tt>.)</p>

<div class="label" id="sec:implementing_has_password"></div>


<h3><a id="sec:7.2.3" href="modeling-and-viewing-users-two#sec:implementing_has_password" class="heading"><span class="number">7.2.3</span> Реализация <code>has_password?</code></a></h3>


<p>Покончив с теорией, мы готовы к реализации. Давайте забежим немного вперед, чтобы понять куда мы двигаемся. Каждый объект user знает свой собственный зашифрованный пароль encrypted password, таким образом, для проверки на соответствие с представленным паролем, мы можем определить <code>has_password?</code> следующим образом:</p>

<div class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">has_password?</span><span class="p">(</span><span class="n">submitted_password</span><span class="p">)</span>
  <span class="n">encrypted_password</span> <span class="o">==</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">submitted_password</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>


<p>Пока мы шифруем предоставленный пароль с помощью той же соли, что используется для шифрования исходного пароля, данная функция будет верной, но только если представленный пароль совпадает.</p>

<p>Поскольку сравнение пароля пользователя с предоставленным паролем будет включать шифрование предоставленного пароля с солью, мы должны где-то хранить соль, поэтому первый шаг заключается в добавлении столбца <code>salt</code> к таблице <code>users</code>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> rails generate migration add_salt_to_users salt:string
</pre></div>
</div>


<p>Как и c <code>encrypted_password</code> миграцией (<a class="ref" href="modeling-and-viewing-users-two#sec:password_migration">Раздел&nbsp;7.1.2</a>), имя этой миграции заканчивается на <code>_to_users</code> и передается второй аргумент, содержащий имя и тип атрибута, таким образом Rails автоматически создает правильную миграцию (<a class="ref" href="modeling-and-viewing-users-two#code:salt_migration">Листинг&nbsp;7.9</a>).</p>

<div class="label" id="code:salt_migration"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.9.</span> <span class="description">Миграция для добавления <code>salt</code> столбца к <code>users</code> таблице. <br /> <code>db/migrate/&lt;timestamp&gt;_add_salt_to_users.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">AddSaltToUsers</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">up</span>
    <span class="n">add_column</span> <span class="ss">:users</span><span class="p">,</span> <span class="ss">:salt</span><span class="p">,</span> <span class="ss">:string</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">down</span>
    <span class="n">remove_column</span> <span class="ss">:users</span><span class="p">,</span> <span class="ss">:salt</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Затем мы, как обычно, мигрируем базу данных и подготавливаем тестовую базу данных:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rake db:migrate
<span class="gp">$</span> bundle <span class="nb">exec </span>rake db:test:prepare
</pre></div>
</div>


<p>Полученная в результате модель данных представлена на <a class="ref" href="modeling-and-viewing-users-two#fig:user_model_salt">Рис.&nbsp;7.3</a>.</p>

<div class="label" id="fig:user_model_salt"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/user_model_salt.png" alt="user_model_salt" /></span></div><div class="caption"><span class="header">Рисунок  7.3: </span><span class="description">User модель с добавленной солью.</span></div></div>


<p>Наконец, мы готовы к полной реализации. Когда мы последний раз видели <code>encrypt</code> функцию (<a class="ref" href="modeling-and-viewing-users-two#code:encrypt_password_callback">Листинг&nbsp;7.6</a>), она ничего не делала, просто возвращала строку в аргумент. С идеями из <a class="ref" href="modeling-and-viewing-users-two#sec:secure_password_theory">Раздела&nbsp;7.2.2</a>, теперь мы готовы использовать вместо этого безопасный хэш  (<a class="ref" href="modeling-and-viewing-users-two#code:has_password_with_encrypt">Листинг&nbsp;7.10</a>).<sup class="footnote" id="fnref:7.9"><a href="#fn:7.9">9</a></sup></p>

<div class="label" id="code:has_password_with_encrypt"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.10.</span> <span class="description">Метод <code>has_password?</code> с безопасным шифрованием. <br /> <code>app/models/user.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;digest&#39;</span>
<span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">before_save</span> <span class="ss">:encrypt_password</span>

  <span class="k">def</span> <span class="nf">has_password?</span><span class="p">(</span><span class="n">submitted_password</span><span class="p">)</span>
    <span class="n">encrypted_password</span> <span class="o">==</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">submitted_password</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="kp">private</span>

    <span class="k">def</span> <span class="nf">encrypt_password</span>
      <span class="nb">self</span><span class="o">.</span><span class="n">salt</span> <span class="o">=</span> <span class="n">make_salt</span> <span class="k">if</span> <span class="n">new_record?</span>
      <span class="nb">self</span><span class="o">.</span><span class="n">encrypted_password</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">password</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
      <span class="n">secure_hash</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">salt</span><span class="si">}</span><span class="s2">--</span><span class="si">#{</span><span class="n">string</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">make_salt</span>
      <span class="n">secure_hash</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="no">Time</span><span class="o">.</span><span class="n">now</span><span class="o">.</span><span class="n">utc</span><span class="si">}</span><span class="s2">--</span><span class="si">#{</span><span class="n">password</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">secure_hash</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
      <span class="no">Digest</span><span class="o">::</span><span class="no">SHA2</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Этот код содержит те же две тонкости, упомянутые в <a class="ref" href="modeling-and-viewing-users-two#sec:an_active_record_callback">Разделе&nbsp;7.1.3</a>, а именно, присвоение атрибута Active Record в строке</p>

<div class="code"><div class="highlight"><pre><span class="nb">self</span><span class="o">.</span><span class="n">salt</span> <span class="o">=</span> <span class="n">make_salt</span> <span class="k">if</span> <span class="n">new_record?</span>
</pre></div>
</div>


<p>и опущенное ключевое слово <code>self</code> в методе <code>encrypt</code>:</p>

<div class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
  <span class="n">secure_hash</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">salt</span><span class="si">}</span><span class="s2">--</span><span class="si">#{</span><span class="n">string</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>


<p>Так как мы находимся внутри класса User, Ruby знает, что <code>salt</code> ссылается на пользовательский атрибут <code>salt</code>.</p>

<p>Важно также отметить использование булевого <code>new_record?</code> метода Active Record, который возвращает истину, если объект еще не был сохранен в базе данных. Поскольку соль это уникальный идентификатор для каждого пользователя, мы не хотим, чтобы он менялся каждый раз, когда пользователь обновляется (как в <a class="ref" href="updating-showing-and-deleting-users#sec:updating_users">Разделе&nbsp;10.1</a>), и включением <code>new_record?</code> мы обеспечиваем однократное создание соли, происходящее только при добавлении нового пользователя.<sup class="footnote" id="fnref:7.10"><a href="#fn:7.10">10</a></sup> (Эта тонкость не важна сейчас, но она понадобится, когда мы реализуем функцию "запомнить меня" в   <a class="ref" href="sign-in-sign-out#sec:remember_me">Разделе&nbsp;9.3.2</a>.)</p>

<p>В данный момент, тесты из  <a class="ref" href="modeling-and-viewing-users-two#code:has_password_tests">Листинга&nbsp;7.8</a> должны пройти:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rspec spec/models/user_spec.rb <span class="se">\</span>
<span class="gp">&gt;</span> -e <span class="s2">"should be true if the passwords match"</span>
<span class="go">.</span>

<span class="go">1 example, 0 failures</span>

<span class="gp">$</span> bundle <span class="nb">exec </span>rspec spec/models/user_spec.rb <span class="se">\</span>
<span class="gp">&gt;</span> -e <span class="s2">"should be false if the passwords don't match"</span>
<span class="go">.</span>

<span class="go">1 example, 0 failures</span>
</pre></div>
</div>


<p>Мы можем также выполнить все примеры, в частности, <code>describe</code> блок, но прежде мы должны <em>маскировать</em> все специальные знаки <a href="http://rubular.com/">регулярных выражений</a> — в данном случае, знак вопроса&nbsp;<code>?</code> в <code>"has_password? method"</code>:</code>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle <span class="nb">exec </span>rspec spec/models/user_spec.rb -e <span class="s2">"has_password\? method"</span>
<span class="go">Run filtered using {:full_description=&gt;/(?-mix:has_password\? method)/}</span>
<span class="go">..</span>

<span class="go">2 examples, 0 failures</span>
</pre></div>
</div>


<p>Обратный слэш перед знаком вопроса позволил сопоставителю регулярных выражений в RSpec интерпретировть строку правильно, тем самым выполнив тесты связанные с данным <code>describe</code> блоком.</p>

<div class="label" id="sec:an_authenticate_method"></div>


<h3><a id="sec:7.2.4" href="modeling-and-viewing-users-two#sec:an_authenticate_method" class="heading"><span class="number">7.2.4</span> Метод аутентификации</a></h3>


<p>Иметь метод <code>has_password?</code> для каждого пользователя это хорошо, но само по себе это не очень полезно. Мы закончим наше обсуждение паролей написав с помощью <code>has_password?</code> метод для аутентификации пользователя на основе электронной почты и пароля. В <a class="ref" href="sign-in-sign-out#top">Главе&nbsp;9</a>, мы будем использовать этот <code>authenticate</code> метод при регистрации пользователей на нашем сайте.</p>

<p>Мы можем получить подсказку о том, как это будет работать с помощью консоли. Во-первых, мы создадим пользователя, а затем отыщем этого пользователя по адресу электронной почты чтобы проверить что он имеет данный пароль:<sup class="footnote" id="fnref:7.11"><a href="#fn:7.11">11</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console --sandbox</span>
<span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">create!</span><span class="p">(</span><span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Michael Hartl&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;mhartl@example.com&quot;</span><span class="p">,</span>
<span class="gp">?&gt; </span>             <span class="ss">:password</span> <span class="o">=&gt;</span> <span class="s2">&quot;foobar&quot;</span><span class="p">,</span> <span class="ss">:password_confirmation</span> <span class="o">=&gt;</span> <span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find_by_email</span><span class="p">(</span><span class="s2">&quot;mhartl@example.com&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">has_password?</span><span class="p">(</span><span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>Используя эти идеи, давайте напишем метод, который вернет аутентифицированного пользователя при совпадении пароля, и <code>nil</code> в противном случае. Мы должны иметь возможность использовать получившийся метод <code>authenticate</code> класса следующим образом:</p>

<div class="code"><div class="highlight"><pre><span class="no">User</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">submitted_password</span><span class="p">)</span>
</pre></div>
</div>


<p>Начнем с тестов, которые мы будем использовать для определения поведения, которое мы ожидаем от <code>User.authenticate</code>. Нужно проверить три варианта развития событий: <code>authenticate</code>&nbsp;(1) должен возвращать <code>nil</code> когда комбинация email/password недействительна или&nbsp;(2) когда не существует пользователя с данным электронным адресом, и&nbsp;(3) должен возвращать сам объект user в случае успеха. С этой информацией, мы можем написать тесты для <code>authenticate</code> как в  <a class="ref" href="modeling-and-viewing-users-two#code:authenticate_method_tests">Листинге&nbsp;7.11</a>.</p>

<div class="label" id="code:authenticate_method_tests"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.11.</span> <span class="description">Тесты для метода <code>User.authenticate</code>. <br /> <code>spec/models/user_spec.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="n">describe</span> <span class="no">User</span> <span class="k">do</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">describe</span> <span class="s2">&quot;password encryption&quot;</span> <span class="k">do</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="n">describe</span> <span class="s2">&quot;authenticate method&quot;</span> <span class="k">do</span>

      <span class="n">it</span> <span class="s2">&quot;should return nil on email/password mismatch&quot;</span> <span class="k">do</span>
        <span class="n">wrong_password_user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="vi">@attr</span><span class="o">[</span><span class="ss">:email</span><span class="o">]</span><span class="p">,</span> <span class="s2">&quot;wrongpass&quot;</span><span class="p">)</span>
        <span class="n">wrong_password_user</span><span class="o">.</span><span class="n">should</span> <span class="n">be_nil</span>
      <span class="k">end</span>

      <span class="n">it</span> <span class="s2">&quot;should return nil for an email address with no user&quot;</span> <span class="k">do</span>
        <span class="n">nonexistent_user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="s2">&quot;bar@foo.com&quot;</span><span class="p">,</span> <span class="vi">@attr</span><span class="o">[</span><span class="ss">:password</span><span class="o">]</span><span class="p">)</span>
        <span class="n">nonexistent_user</span><span class="o">.</span><span class="n">should</span> <span class="n">be_nil</span>
      <span class="k">end</span>

      <span class="n">it</span> <span class="s2">&quot;should return the user on email/password match&quot;</span> <span class="k">do</span>
        <span class="n">matching_user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="vi">@attr</span><span class="o">[</span><span class="ss">:email</span><span class="o">]</span><span class="p">,</span> <span class="vi">@attr</span><span class="o">[</span><span class="ss">:password</span><span class="o">]</span><span class="p">)</span>
        <span class="n">matching_user</span><span class="o">.</span><span class="n">should</span> <span class="o">==</span> <span class="vi">@user</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Теперь мы готовы к реализации, с которой мы получим прохождение наших тестов и покажем как определить <em>метод класса</em> в качестве бонуса. Мы уже упоминали методы класса несколько раз до этого, совсем недавно в <a class="ref" href="modeling-and-viewing-users-one#sec:database_migrations">Разделе&nbsp;6.1.1</a>; метод класса это просто метод прикрепленный к классу, a не экземпляр этого класса. Например, <code>new</code>, <code>find</code>, и <code>find_by_email</code> это методы класса User. За пределами класса они вызываются с помощью имени класса, как в <code>User.find</code>, но внутри класса мы можем опустить имя класса.</p>

<div class="label" id="sidebar:self"></div>


<div class="sidebar"><span class="title"><span class="header">Блок 7.1.</span><span class="description">Что такое <code>self</code>?</span></span>
<p>Мы говорили о том, что <code>self</code> это “сам объект”, но конкретное значение зависит от контекста. Внутри обычного метода, <code>self</code> ссылается на <em>экземпляр</em> класса, то есть, обозначает сам объект. Например, в <a class="ref" href="modeling-and-viewing-users-two#code:has_password_with_encrypt">Листинге&nbsp;7.10</a>, <code>self</code> это <em>user</em>:</p>

<pre class="verbatim">  def encrypt_password
    self.salt = make_salt if new_record?
    self.encrypted_password = encrypt(password)
  end</pre>


<p>Внутри метода <code>encrypt_password</code>, <code>self</code> это объект user, таким образом, <code>self.salt</code> это тоже что и <code>user.salt</code> за пределами метода:</p>

<pre class="verbatim">  $ rails console
  &gt;&gt; user = User.first
  &gt;&gt; user.salt
  =&gt; &quot;d3b9af261c502947fbf32f78cb8179b16e62eabacf059451efee404328b2f537&quot;</pre>


<p>С другой стороны, <a class="ref" href="modeling-and-viewing-users-two#code:authenticate_method">Листинг&nbsp;7.12</a> показывает определение <code>authenticate</code>, которое использует <code>self</code> для определения <em>метода класса</em>; здесь, <code>self</code> это сам класс <code>User</code>:</p>

<pre class="verbatim">  def self.authenticate(email, submitted_password)
    .
    .
    .
  end</pre>


<p>Потому что он определен на <code>User</code> классе, <code>authenticate</code> непосредственно ссылается на <code>User</code>:</p>

<pre class="verbatim">  &gt;&gt; user = User.authenticate('example@railstutorial.org', 'foobar')
  &gt;&gt; user.name
  =&gt; &quot;Example User&quot;</pre>


<p>Стоит отметить два альтернативных способа определения <code>authenticate</code> метода класса, эквивалентные показанному в <a class="ref" href="modeling-and-viewing-users-two#code:authenticate_method">Листинге&nbsp;7.12</a>. Во-первых, мы могли бы указать на <code>User</code> класс явно по названию:</p>

<pre class="verbatim">  def User.authenticate(email, submitted_password)
    .
    .
    .
  end</pre>


<p>(Некоторые люди могут найти этот синтаксис яснее, но это не вполне идиоматически правильно.) Во-вторых, мы могли бы использовать следующий код, который, откровенно говоря, расплавляет мой мозг:</p>

<pre class="verbatim">  class &lt;&lt; self
    def authenticate(email, submitted_password)
      .
      .
      .
    end
  end</pre>


<p>Странное <code>class &lt;&lt; self</code> начинает блок в котором все новые методы автоматически являются методами класса. Я считаю этот синтаксис довольно запутанным, но вполне возможно, Вы встретите его в чужом коде, так что стоит знать, что он делает. (Я рекомендую <a href="http://www.amazon.com/gp/product/1933988657?ie=UTF8&amp;tag=httpwwwrailst-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1933988657"><em>The Well-Grounded Rubyist</em></a> David&nbsp;A. Black если вы хотите погрузиться в подробности Ruby.)</p>
</div>


<p>Способ определения метода класса заключается в использовании  ключевого слова <code>self</code> в определении метода. (Это <code>self</code> отличается от <code>self</code> показанного в  <a class="ref" href="modeling-and-viewing-users-two#code:has_password_with_encrypt">Листинге&nbsp;7.10</a>; см. <a class="ref" href="modeling-and-viewing-users-two#sidebar:self">Блок&nbsp;7.1</a>.) <a class="ref" href="modeling-and-viewing-users-two#code:authenticate_method">Листинг&nbsp;7.12</a> показывает эту конструкцию в контексте <code>authenticate</code> метода. Обратите внимание на вызов <code>find_by_email</code>, в котором мы опускаем явное имя класса <code>User</code> так как этот метод уже внутри <code>User</code> класса.</p>

<div class="label" id="code:authenticate_method"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.12.</span> <span class="description">Метод <code>User.authenticate</code>. <br /> <code>app/models/user.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="k">def</span> <span class="nf">has_password?</span><span class="p">(</span><span class="n">submitted_password</span><span class="p">)</span>
    <span class="n">encrypted_password</span> <span class="o">==</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">submitted_password</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">authenticate</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">submitted_password</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">find_by_email</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
    <span class="k">return</span> <span class="kp">nil</span>  <span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">nil?</span>
    <span class="k">return</span> <span class="n">user</span> <span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">has_password?</span><span class="p">(</span><span class="n">submitted_password</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Есть несколько эквивалентных способов записи <code>authenticate</code> метода, но я считаю реализацию выше более чистой. Она обрабатывает два случая (неверный email и успешное соответствие) с явным ключевым словом <code>return</code>, и обрабатывает третий случай (несоответствие пароля) неявно, так как в этом случае мы достигаем конца метода, который автоматически возвращает <code>nil</code>. См. в <a class="ref" href="modeling-and-viewing-users-two#sec:more_modeling_users_exercises">Разделе&nbsp;7.5</a> некоторые другие возможные способы реализации этого метода.</p>

<div class="label" id="sec:better_user_views"></div>


<h2><a id="sec:7.3" href="modeling-and-viewing-users-two#sec:better_user_views" class="heading"><span class="number">7.3</span> Улучшение отображения пользователя</a></h2>


<p>Теперь, когда User модель практически завершена,<sup class="footnote" id="fnref:7.12"><a href="#fn:7.12">12</a></sup> мы можем добавить образец пользователя в базу данных разработки и сделать <code>show</code> страницу, чтобы показать информацию о пользователе. По пути, мы добавим некоторые тесты к Users контроллеру spec из <a class="ref" href="filling-in-the-layout#sec:users_controller">Раздела&nbsp;5.3.1</a>.</p>

<p>Перед тем как продолжить, полезно посмотреть, где мы остановились, вспомнив как сейчас выглядит Users контроллер spec (<a class="ref" href="modeling-and-viewing-users-two#code:get_new_user_spec_review">Листинг&nbsp;7.13</a>). Наши тесты для  страницы показывающей пользователя будут следовать этому примеру, но мы увидим, что, в отличие от тестов для <code>new</code> действия, тесты для <code>show</code> действия требуют использования экземпляра User модели. Мы ответим на брошенный вызов используя технику, называемую <em>factories</em> (фабрики).</p>

<div class="label" id="code:get_new_user_spec_review"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.13.</span> <span class="description">Текущий Users контроллер spec. <br /> <code>spec/controllers/users_controller_spec.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>

<span class="n">describe</span> <span class="no">UsersController</span> <span class="k">do</span>
  <span class="n">render_views</span>

  <span class="n">describe</span> <span class="s2">&quot;GET &#39;new&#39;&quot;</span> <span class="k">do</span>

    <span class="n">it</span> <span class="s2">&quot;should be successful&quot;</span> <span class="k">do</span>
      <span class="n">get</span> <span class="s1">&#39;new&#39;</span>
      <span class="n">response</span><span class="o">.</span><span class="n">should</span> <span class="n">be_success</span>
    <span class="k">end</span>

    <span class="n">it</span> <span class="s2">&quot;should have the right title&quot;</span> <span class="k">do</span>
      <span class="n">get</span> <span class="s1">&#39;new&#39;</span>
      <span class="n">response</span><span class="o">.</span><span class="n">should</span> <span class="n">have_selector</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">,</span> <span class="ss">:content</span> <span class="o">=&gt;</span> <span class="s2">&quot;Sign up&quot;</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>




<div class="label" id="sec:tests_with_factories"></div>


<h3><a id="sec:7.3.1" href="modeling-and-viewing-users-two#sec:tests_with_factories" class="heading"><span class="number">7.3.1</span> Тестирование страницы просмотра пользователя (с factories)</a></h3>


<p>Тестам для контроллера Users потребуются экземпляры объектов модели User, желательно с заранее определенными значениями. Например, как показано в <a class="ref" href="modeling-and-viewing-users-two#code:user_show_reminder">Листинге&nbsp;7.14</a>, <code>show</code> действию контроллера Users необходим экземпляр класса User, поэтому тесты на это действие будут требовать, чтобы мы как-то создали <code>@user</code>. Мы достигнем этой цели с user <em>factory</em>, которая является удобным способом определения объекта user и добавления его в тестовую базу данных.<sup class="footnote" id="fnref:7.13"><a href="#fn:7.13">13</a></sup></p>

<div class="label" id="code:user_show_reminder"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.14.</span> <span class="description">User <code>show</code> действие из <a class="ref" href="modeling-and-viewing-users-one#code:user_show_action">Листинга&nbsp;6.25</a>. <br /> <code>app/controllers/users_controller.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">UsersController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">show</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:id</span><span class="o">]</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Мы будем использовать factories сгенерированные <a href="http://github.com/thoughtbot/factory_girl">Factory Girl</a>,<sup class="footnote" id="fnref:7.14"><a href="#fn:7.14">14</a></sup> Ruby гем, сделанный хорошими людьми из <a href="http://thoughtbot.com/">thoughtbot</a>. Как и другие Ruby гемы, мы можем установить его добавив соответствующую строку в <code>Gemfile</code> используя Bundler  (<a class="ref" href="modeling-and-viewing-users-two#code:gemfile_factory_girl">Листинг&nbsp;7.15</a>). (Так как Factory Girl необходима только в тестах, мы включим его в <code>:test</code> группу.)</p>

<div class="label" id="code:gemfile_factory_girl"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.15.</span> <span class="description">Добавление Factory Girl в <code>Gemfile</code>.</span>
</div>
<div class="code"><div class="highlight"><pre><span class="n">source</span> <span class="s1">&#39;http://rubygems.org&#39;</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="n">group</span> <span class="ss">:test</span> <span class="k">do</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="n">gem</span> <span class="s1">&#39;factory_girl_rails&#39;</span><span class="p">,</span> <span class="s1">&#39;1.0&#39;</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Затем установите как обычно:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle install
</pre></div>
</div>


<p>Теперь мы готовы создать файл <code>spec/factories.rb</code> и определить User factory, как показано в <a class="ref" href="modeling-and-viewing-users-two#code:user_factory">Листинге&nbsp;7.16</a>. Помещая файл <code>factories.rb</code> в директорию <code>spec/</code>, мы организуем автоматическую загрузку нашей фабрики при запуске тестов.</p>

<div class="label" id="code:user_factory"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.16.</span> <span class="description">Фабрика для симуляции объектов модели User. <br /> <code>spec/factories.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="c1"># Используя символ &#39;:user&#39;, мы указываем Factory Girl на необходимость симулировать модель User.</span>
<span class="no">Factory</span><span class="o">.</span><span class="n">define</span> <span class="ss">:user</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span>
  <span class="n">user</span><span class="o">.</span><span class="n">name</span>                  <span class="s2">&quot;Michael Hartl&quot;</span>
  <span class="n">user</span><span class="o">.</span><span class="n">email</span>                 <span class="s2">&quot;mhartl@example.com&quot;</span>
  <span class="n">user</span><span class="o">.</span><span class="n">password</span>              <span class="s2">&quot;foobar&quot;</span>
  <span class="n">user</span><span class="o">.</span><span class="n">password_confirmation</span> <span class="s2">&quot;foobar&quot;</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>С определением в <a class="ref" href="modeling-and-viewing-users-two#code:user_factory">Листинге&nbsp;7.16</a>, мы можем создать фабрику User в тестах вроде этой:</p>

<div class="code"><div class="highlight"><pre><span class="vi">@user</span> <span class="o">=</span> <span class="no">Factory</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span>
</pre></div>
</div>


<p>Как отмечалось в коментарии, в первой строке  <a class="ref" href="modeling-and-viewing-users-two#code:user_factory">Листинга&nbsp;7.16</a>, используя символ <code>:user</code> мы даем Factory Girl возможность угадать, что мы хотим использовать модель User, так что в данном случае <code>@user</code> будет симулировать экземпляр <code>User</code>.</p>

<p>Для нашей новой фабрики User в Users контроллере spec, мы создадим переменную <code>@user</code> в блоке <code>before(:each)</code> а затем <code>get</code> show страницу и проверим успешность (как мы делали с <code>new</code> страницей в <a class="ref" href="modeling-and-viewing-users-two#code:get_new_user_spec_review">Листинге&nbsp;7.13</a>), а также проверим, что действие <code>show</code> вытягивает нужного пользователя из базы данных. Результат представлен в <a class="ref" href="modeling-and-viewing-users-two#code:get_show_test">Листинге&nbsp;7.17</a>. (Если вы используете Spork, вам может потребоваться его рестарт, для прохождения этого теста.)</p>

<div class="label" id="code:get_show_test"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.17.</span> <span class="description">Тест для получения <code>show</code> страницы, с фабрикой пользователей. <br /> <code>spec/controllers/users_controller_spec.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>

<span class="n">describe</span> <span class="no">UsersController</span> <span class="k">do</span>
  <span class="n">render_views</span>

  <span class="n">describe</span> <span class="s2">&quot;GET &#39;show&#39;&quot;</span> <span class="k">do</span>

    <span class="n">before</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span> <span class="k">do</span>
      <span class="vi">@user</span> <span class="o">=</span> <span class="no">Factory</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">it</span> <span class="s2">&quot;should be successful&quot;</span> <span class="k">do</span>
      <span class="n">get</span> <span class="ss">:show</span><span class="p">,</span> <span class="ss">:id</span> <span class="o">=&gt;</span> <span class="vi">@user</span>
      <span class="n">response</span><span class="o">.</span><span class="n">should</span> <span class="n">be_success</span>
    <span class="k">end</span>

    <span class="n">it</span> <span class="s2">&quot;should find the right user&quot;</span> <span class="k">do</span>
      <span class="n">get</span> <span class="ss">:show</span><span class="p">,</span> <span class="ss">:id</span> <span class="o">=&gt;</span> <span class="vi">@user</span>
      <span class="n">assigns</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span><span class="o">.</span><span class="n">should</span> <span class="o">==</span> <span class="vi">@user</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Помимо первого использования фабрики, реально новым здесь является использование  <code>assigns(:user)</code>, который поставляется RSpec (через лежащую в его основе <tt>Test::Unit</tt> библиотеку). <code>Assigns</code> метод принимает в качестве аргумента символ и возвращает значение соответствующей переменной <em>экземпляра</em> в действие контроллера. Другими словами, в <a class="ref" href="modeling-and-viewing-users-two#code:get_show_test">Листинге&nbsp;7.17</a> код</p>

<div class="code"><div class="highlight"><pre><span class="n">assigns</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span>
</pre></div>
</div>


<p>возвращает значение переменной экземпляра</p>

<div class="code"><div class="highlight"><pre><span class="vi">@user</span>
</pre></div>
</div>


<p>в <code>show</code> действие контроллера Users. Тест</p>

<div class="code"><div class="highlight"><pre><span class="n">assigns</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span><span class="o">.</span><span class="n">should</span> <span class="o">==</span> <span class="vi">@user</span>
</pre></div>
</div>


<p>затем проверяет, что переменная извлекается из базы данных в действие соответствующее <code>@user</code> экземпляру созданному Factory Girl. Стоит заметить, что не все Rails программисты используют <code>assigns</code> в этом контексте, предпочитая вместо него использовать технику называемую <em>stubbing</em> (<a class="ref" href="modeling-and-viewing-users-two#sidebar:stubbing">Блок&nbsp;7.2</a>).</p>

<div class="label" id="sidebar:stubbing"></div>


<div class="sidebar"><span class="title"><span class="header">Блок 7.2.</span><span class="description"><code> stub!</code> или не <code>stub!</code>.</span></span>
<p>Код в <a class="ref" href="modeling-and-viewing-users-two#code:get_show_test">Листинге&nbsp;7.17</a> опирается на метод <code>User.find</code> в действии контроллера для получения правильного пользователя из тестовой базы данных. Второй способ добиться этого же результата использует технику, <em>stubbing</em>, использующую RSpec метод <code>stub!</code>:</p>

<pre class="verbatim">  before(:each)
    @user = Factory(:user)
    User.stub!(:find, @user.id).and_return(@user)
  end</pre>


<p>Этот код гарантирует, что любой вызов <code>User.find</code> с данным <code>id</code> вернет <code>@user</code>. Так как это именно то, что мы имеем в коде приложения (<a class="ref" href="modeling-and-viewing-users-two#code:user_show_reminder">Листинг&nbsp;7.14</a>), заглушка приводит к перехватыванию RSpec вызова <code>User.find</code> и, вместо вызова базы данных, возвращает <code>@user</code>.</p>

<p>Многие программисты Rails, особенно пользователи RSpec, предпочитают этот подход потому что он отделяет тесты контроллера от слоя модели. Действительно, <a href="http://railstutorial.org/book?version=2.3">Rails 2.3 версия этой книги</a> использует заглушки, вместе с тесно связанной техникой <em>ожидания сообщения</em>. После приобретения большого опыта с заглушками и ожиданиями, и особенно после ответов на большое количество вопросов читателей <em>Rails 2.3 Tutorial</em>, запутавшихся в этих вопросах, я пришел к выводу что заглушки и связанные с ними методы не стоят этих проблем.</p>

<p>Выяснение того, когда именно заглушать вещи это трудно и сообщения ожидания полны тонкостей и ошибок (см. например, <a href="http://railstutorial.org/chapters/sign-up?version=2.3#sidebar:expectation_subtlety">Блок&nbsp;8.1 в <em>Rails 2.3 Tutorial</em> book</a>). Для обычных возражений вроде; “Но теперь тесты контроллера обращаются к тестовой базе данных!”, я теперь нашел свой собственный ответ: “Ну и что?” По моему опыту это никогда не имело значения. Я не вижу никаких веских причин, чтобы не обратиться к слою модели в тестах контроллера, особенно если это приводит к упрощению тестов. Если вам интересно изучение техник заглушек и ожидающих сообщений, я рекомендую читать <a href="http://railstutorial.org/book?version=2.3"><em>Ruby on Rails 2.3 Tutorial</em> book</a>. В противном случае, я предлагаю, не беспокоиться об обеспечении полного разделения слоев модели и контроллера в Rails тестах. Хотя тесты контроллера в остальной части этой книги будут обращаться к тестовой базе данных, на <em>концептуальном</em>  уровне всегда будет ясно, какая часть MVC проходит испытания.</p>

<p>Кстати, в принципе, тесты должны работать быстрее, когда контроллеры не обращаются к базе данных и для законченного примера приложения, рассматриваемого в <em>Rails Tutorial</em> набор тестов который он выполняет — быстрее примерно на две десятых секунды.</p>
</div>


<p>Есть еще пара деталей в <a class="ref" href="modeling-and-viewing-users-two#code:get_show_test">Листинге&nbsp;7.17</a>, которые стоит отметить. Во первых, в вызове <code>get</code>, тест использует <em>символ</em> <code>:show</code> вместо строки <code>’show’</code>, что отличается от принятого способа в других тестах (например, в <a class="ref" href="static-pages#code:default_pages_controller_spec">Листинге&nbsp;3.7</a> мы писали <code>get ’home’</code>). Оба способа</p>

<div class="code"><div class="highlight"><pre><span class="n">get</span> <span class="ss">:show</span>
</pre></div>
</div>


<p>и</p>

<div class="code"><div class="highlight"><pre><span class="n">get</span> <span class="s1">&#39;show&#39;</span>
</pre></div>
</div>


<p>делают одно и то же, но при тестировании каноничных REST действий (<a class="ref" href="modeling-and-viewing-users-one#table:RESTful_users">Таблица&nbsp;6.2</a>) я предпочитаю использовать символы, которые почему-то кажутся мне более естественными в этом контексте.<sup class="footnote" id="fnref:7.15"><a href="#fn:7.15">15</a></sup> Во-вторых, обратите внимание, что значение хэш-ключа <code>:id</code>, вместо того чтобы быть <code>id</code> атрибутом пользователя <code>@user.id</code>, является самим объектом user:</p>


<div class="code"><div class="highlight"><pre><span class="n">get</span> <span class="ss">:show</span><span class="p">,</span> <span class="ss">:id</span> <span class="o">=&gt;</span> <span class="vi">@user</span>
</pre></div>
</div>


<p>Мы могли бы использовать</p>

<div class="code"><div class="highlight"><pre><span class="n">get</span> <span class="ss">:show</span><span class="p">,</span> <span class="ss">:id</span> <span class="o">=&gt;</span> <span class="vi">@user</span><span class="o">.</span><span class="n">id</span>
</pre></div>
</div>


<p>чтобы сделать то же самое, но в этом контексте Rails автоматически преобразует объект user  в соответствующий id.<sup class="footnote" id="fnref:7.16"><a href="#fn:7.16">16</a></sup> Использование более краткой конструкции</p>

<div class="code"><div class="highlight"><pre><span class="n">get</span> <span class="ss">:show</span><span class="p">,</span> <span class="ss">:id</span> <span class="o">=&gt;</span> <span class="vi">@user</span>
</pre></div>
</div>


<p>является очень распространенной Rails идиомой.</p>

<p>Из-за кода, который мы добавили в <a class="ref" href="modeling-and-viewing-users-one#code:user_show_action">Листинге&nbsp;6.25</a>, тест в этом разделе, уже проходит. Если вы чувствуете себя параноиком, вы можете закомментировать строку</p>

<div class="code"><div class="highlight"><pre><span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:id</span><span class="o">]</span><span class="p">)</span>
</pre></div>
</div>


<p>и убедиться, что тест не проходит, а затем раскомментировать ее, чтобы заставить его пройти. (Мы однажды проделывали подобное, в <a class="ref" href="modeling-and-viewing-users-one#sec:presence_validation">Разделе&nbsp;6.2.1</a>.)</p>

<div class="label" id="sec:a_name_and_a_gravatar"></div>


<h3><a id="sec:7.3.2" href="modeling-and-viewing-users-two#sec:a_name_and_a_gravatar" class="heading"><span class="number">7.3.2</span> Имя и Gravatar</a></h3>


<p>В этом разделе мы улучшим внешний вид страницы показывающей пользователя, добавив заголовок с именем пользователя и аватар. Это одна из тех ситуаций, где я могу выбрать любой путь разработки через тестирование и когда я делаю представления я часто экспериментирую с HTML, прежде чем возиться с тестами. Давайте все же придерживаться темы TDD, и протестируем верхнюю часть заголовка (тег <code>h1</code>) содержащую имя пользователя и тег <code>img</code> класса <code>gravatar</code>. (Мы поговорим через мгновение о том, что эта вторая часть значит.)</p>

<p>Для просмотра рабочей страницы показывающей пользователя в браузере, мы должны создать образец пользователя в development базе данных. Для этого запустите консоль (не в песочнице на этот раз) и создайте пользователя:</p>

<div class="code"><div class="highlight"><pre><span class="go">$ bundle exec rake db:reset</span>
<span class="go">$ rails console</span>
<span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">create!</span><span class="p">(</span><span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">"Example User"</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">"user@example.com"</span><span class="p">,</span>
<span class="gp">?&gt; </span>             <span class="ss">:password</span> <span class="o">=&gt;</span> <span class="s2">"foobar"</span><span class="p">,</span> <span class="ss">:password_confirmation</span> <span class="o">=&gt;</span> <span class="s2">"foobar"</span><span class="p">)</span>
</pre></div>
</div>


<p>Тесты в этом разделе, похожи на тесты для <code>new</code> страницы из <a class="ref" href="filling-in-the-layout#code:signup_title_test">Листинга&nbsp;5.26</a>. В частности, мы используем метод <code>have_selector</code> для проверки заголовка и содержимого тега <code>h1</code>&nbsp;, как видно в <a class="ref" href="modeling-and-viewing-users-two#code:user_show_tests">Листинге&nbsp;7.18</a>.</p>

<div class="label" id="code:user_show_tests"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.18.</span> <span class="description">Тест для страницы показывающей пользователя.<br /> <code>spec/controllers/users_controller_spec.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>

<span class="n">describe</span> <span class="no">UsersController</span> <span class="k">do</span>
  <span class="n">render_views</span>

  <span class="n">describe</span> <span class="s2">&quot;GET &#39;show&#39;&quot;</span> <span class="k">do</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="n">it</span> <span class="s2">&quot;should have the right title&quot;</span> <span class="k">do</span>
      <span class="n">get</span> <span class="ss">:show</span><span class="p">,</span> <span class="ss">:id</span> <span class="o">=&gt;</span> <span class="vi">@user</span>
      <span class="n">response</span><span class="o">.</span><span class="n">should</span> <span class="n">have_selector</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">,</span> <span class="ss">:content</span> <span class="o">=&gt;</span> <span class="vi">@user</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">it</span> <span class="s2">&quot;should include the user&#39;s name&quot;</span> <span class="k">do</span>
      <span class="n">get</span> <span class="ss">:show</span><span class="p">,</span> <span class="ss">:id</span> <span class="o">=&gt;</span> <span class="vi">@user</span>
      <span class="n">response</span><span class="o">.</span><span class="n">should</span> <span class="n">have_selector</span><span class="p">(</span><span class="s2">&quot;h1&quot;</span><span class="p">,</span> <span class="ss">:content</span> <span class="o">=&gt;</span> <span class="vi">@user</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">it</span> <span class="s2">&quot;should have a profile image&quot;</span> <span class="k">do</span>
      <span class="n">get</span> <span class="ss">:show</span><span class="p">,</span> <span class="ss">:id</span> <span class="o">=&gt;</span> <span class="vi">@user</span>
      <span class="n">response</span><span class="o">.</span><span class="n">should</span> <span class="n">have_selector</span><span class="p">(</span><span class="s2">&quot;h1&gt;img&quot;</span><span class="p">,</span> <span class="ss">:class</span> <span class="o">=&gt;</span> <span class="s2">&quot;gravatar&quot;</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Здесь RSpec’s <code>have_selector</code> метод RSpec's проверяет наличие <code>title</code> и <code>h1</code> тегов содержащих имя пользователя. Третий пример вводит новый элемент через код <code>h1&gt;img</code>, который гарантирует что тег <code>img</code> находится <em>внутри</em> тега <code>h1</code>.<sup class="footnote" id="fnref:7.17"><a href="#fn:7.17">17</a></sup> Кроме того, мы видим, что <code>have_selector</code> может принимать опцию <code>:class</code> для тестирования CSS класса элемента о котором идет речь.</p>

<p>Мы можем получить прохождение теста путем установки <code>@title</code> переменной для использования в <code>title</code> хелпере (<a class="ref" href="rails-flavored-ruby#sec:title_helper">Раздел&nbsp;4.1.1</a>),  в этом случае установив ей имя пользователя (<a class="ref" href="modeling-and-viewing-users-two#code:user_show_title">Листинг&nbsp;7.19</a>).</p>

<div class="label" id="code:user_show_title"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.19.</span> <span class="description">Заголовок для страницы показывающей пользователя. <br /> <code>app/controllers/users_controller.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">UsersController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>

  <span class="k">def</span> <span class="nf">show</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:id</span><span class="o">]</span><span class="p">)</span>
    <span class="vi">@title</span> <span class="o">=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">name</span>
  <span class="k">end</span>
  <span class="o">.</span>
  <span class="o">.</span>
  <span class="o">.</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Этот код представляет потенциальную проблему: пользователь может ввести имя с вредоносным кодом—так называемый <a   href="http://ru.wikipedia.org/wiki/XSS">межсайтовый скриптинг</a> который может быть внедрен в наше приложение посредством <code>title</code> хелпера определенного в <a class="ref" href="rails-flavored-ruby#code:title_helper">Листинге&nbsp;4.2</a>. До выхода Rails 3, решеним было <em>маскировать</em>  потенциально проблемный код, используя метод&nbsp;<code>h</code> (сокращение от <code>html_escape</code>), но в случае Rails&nbsp;3.0 весь Embedded Ruby текст маскирован по умолчанию.<sup class="footnote" id="fnref:7.18"><a href="#fn:7.18">18</a></sup> Например, если пользователь пытается внедрить вредоносные программы JavaScript с помощью <code>&lt;script&gt;</code> в своем имени, автоматический HTML маскировщик преобразует его в <code>&amp;lt;script&amp;gt;</code>, что сделает его совершенно безвредным.</p>

<p>Теперь для других тестов. Создание <code>h1</code> с (авто-маскированным) пользовательским именем это просто (<a class="ref" href="modeling-and-viewing-users-two#code:user_show_view_with_name">Листинг&nbsp;7.20</a>).</p>

<div class="label" id="code:user_show_view_with_name"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.20.</span> <span class="description">Представление user show с пользовательским именем. <br /> <code>app/views/users/show.html.erb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="nt">&lt;h1&gt;</span>
  <span class="cp">&lt;%=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">name</span> <span class="cp">%&gt;</span>
<span class="nt">&lt;/h1&gt;</span>
</pre></div>
</div></div>


<p>Получение проходящего <code>img</code> теста сложнее.  Первым шагом является установка <a href="http://github.com/mdeering/gravatar_image_tag"><tt>gravatar_image_tag</tt> гема</a> для обработки каждого пользовательского <a href="http://ru.gravatar.com/">Gravatar</a>,<sup class="footnote" id="fnref:7.19"><a href="#fn:7.19">19</a></sup> что означает <a  rel="nofollow" href="http://ru.wikipedia.org/wiki/Gravatar"> &ldquo;globally recognized avatar&rdquo;</a>.<sup class="footnote" id="fnref:7.20"><a href="#fn:7.20">20</a></sup> Как обычно, мы включим  гем в <code>Gemfile</code> (<a class="ref" href="modeling-and-viewing-users-two#code:gemfile_gravatar">Листинг&nbsp;7.21</a>).</p>

<div class="label" id="code:gemfile_gravatar"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.21.</span> <span class="description">Добавление гема Gravatar в <code>Gemfile</code>.</span>
</div>
<div class="code"><div class="highlight"><pre><span class="n">source</span> <span class="s1">&#39;http://rubygems.org&#39;</span>

<span class="n">gem</span> <span class="s1">&#39;rails&#39;</span><span class="p">,</span> <span class="s1">&#39;3.0.9&#39;</span>
<span class="n">gem</span> <span class="s1">&#39;sqlite3&#39;</span><span class="p">,</span> <span class="s1">&#39;1.3.3&#39;</span>
<span class="n">gem</span> <span class="s1">&#39;gravatar_image_tag&#39;</span><span class="p">,</span> <span class="s1">&#39;1.0.0.pre2&#39;</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="o">.</span>
</pre></div>
</div></div>


<p>Затем установим его с <code>bundle</code>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> bundle install
</pre></div>
</div>


<p>Вы должны также перезапустить веб-сервер в данный момент для правильной загрузки гема Gravatar.</p>

<p>Gravatars являются удобным способом включать изображения для профиля пользователя, минуя проблемы управления загрузкой изображений, обрезки и хранения.<sup class="footnote" id="fnref:7.21"><a href="#fn:7.21">21</a></sup> Каждый Gravatar связан с адресом электронной почты, поэтому гем Gravatar поставляется со вспомогательным методом <code>gravatar_image_tag</code>, который принимает  адрес электронной почты в качестве аргумента:</p>

<div class="code"><div class="highlight"><pre><span class="cp">&lt;%=</span> <span class="n">gravatar_image_tag</span> <span class="s1">&#39;example@railstutorial.org&#39;</span> <span class="cp">%&gt;</span>
</pre></div>
</div>


<p>
На данный момент, мы будем использовать это непосредственно в нашем user show представлении, как показано в <a class="ref" href="modeling-and-viewing-users-two#code:user_show_view_with_gravatar">Листинге&nbsp;7.22</a>. результат представлен на <a class="ref" href="modeling-and-viewing-users-two#fig:user_show_default_gravatar_rails_3">Рис.&nbsp;7.4</a>, который показывает образец нашего пользователя с дефолтным Gravatar изображением.</p>

<div class="label" id="code:user_show_view_with_gravatar"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.22.</span> <span class="description">Представление user show с именем и Gravatar. <br /> <code>app/views/users/show.html.erb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="nt">&lt;h1&gt;</span>
  <span class="cp">&lt;%=</span> <span class="n">gravatar_image_tag</span> <span class="vi">@user</span><span class="o">.</span><span class="n">email</span> <span class="cp">%&gt;</span>
  <span class="cp">&lt;%=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">name</span> <span class="cp">%&gt;</span>
<span class="nt">&lt;/h1&gt;</span>
</pre></div>
</div></div>




<div class="label" id="fig:user_show_default_gravatar_rails_3"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/user_show_default_gravatar_rails_3.png" alt="user_show_default_gravatar_rails_3" /></span></div><div class="caption"><span class="header">Рисунок  7.4: </span><span class="description">Начальная страница показывающая пользователя  <a   href="http://localhost:3000/users/1"><tt>/users/1</tt></a> с дефолтным Gravatar.&nbsp;<a href="http://railstutorial.org/images/figures/user_show_default_gravatar_rails_3-full.png">(полный размер)</a></span></div></div>


<p>Этот Gravatar бизнес может выглядеть как волшебство, так что давайте запустим консоль, чтобы получить немного больше понимания о том, что происходит:</p>

<div class="code"><div class="highlight"><pre><span class="go">$ rails console</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="o">.</span><span class="n">first</span>
<span class="gp">&gt;&gt; </span><span class="n">user</span><span class="o">.</span><span class="n">update_attributes</span><span class="p">(</span><span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;example@railstutorial.org&quot;</span><span class="p">,</span>
<span class="gp">?&gt; </span>                       <span class="ss">:password</span> <span class="o">=&gt;</span> <span class="s2">&quot;foobar&quot;</span><span class="p">,</span>
<span class="gp">?&gt; </span>                       <span class="ss">:password_confirmation</span> <span class="o">=&gt;</span> <span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
<span class="go">=&gt; true</span>
</pre></div>
</div>


<p>Обратите внимание, что мы можем извлечь первого (и в данный момент единственного) пользователя из базы данных удобным методом <code>User.first</code>. В шаге <code>update_attributes</code> переназначаем пользовательский email адрес, превращая его в <code>example@railstutorial.org</code>. Как вы можете видеть на <a class="ref" href="modeling-and-viewing-users-two#fig:user_show_railstutorial_gravatar_rails_3">Рис.&nbsp;7.5</a>, это изменение приводит к отображению нового Gravatar: логотипу Rails Tutorial. Происходит следующее: Gravatar работает, связывая изображения с адресом электронной почты; так как <code>user@example.com</code> это неправильный адрес электронной почты (<a href="http://example.com/">example.com</a> домен зарезервирован и не доступен для регистрации) Gravatar для этого email адреса отсутствует. Но в моем аккуанте Gravatar я связал  адрес <code>example@railstutorial.org</code> с логотипом Rails Tutorial, поэтому при обновлении образца пользователя с этим email адресом Gravatar меняется автоматически.</p>

<div class="label" id="fig:user_show_railstutorial_gravatar_rails_3"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/user_show_railstutorial_gravatar_rails_3.png" alt="user_show_railstutorial_gravatar_rails_3" /></span></div><div class="caption"><span class="header">Рисунок  7.5: </span><span class="description">Страница показывающая пользователя  <a href="http://localhost:3000/users/1"><tt>/users/1</tt></a> с Rails Tutorial Gravatar.&nbsp;<a href="http://railstutorial.org/images/figures/user_show_railstutorial_gravatar_rails_3-full.png">(полный размер)</a></span></div></div>




<div class="label" id="sec:a_gravatar_helper"></div>


<h4><a id="sec:7.3.2.1" href="modeling-and-viewing-users-two#sec:a_gravatar_helper" class="heading">Gravatar хелпер</a></h4>


<p>На данный момент, Gravatar отображается правильно, но последний пример из <a class="ref" href="modeling-and-viewing-users-two#code:user_show_tests">Листинга&nbsp;7.18</a> до сих пор не проходит. Это потому, что класс <code>"gravatar"</code> , который мы хотим использовать в CSS для Gravatar, еще не присутствует в теге <code>img</code> Gravatar-а. Мы можем заставить тест пройти, включив опцию в метод <code>gravatar_image_tag</code>:</p>

<div class="code"><div class="highlight"><pre><span class="cp">&lt;%=</span> <span class="n">gravatar_image_tag</span> <span class="vi">@user</span><span class="o">.</span><span class="n">email</span><span class="p">,</span> <span class="ss">:class</span> <span class="o">=&gt;</span> <span class="s2">&quot;gravatar&quot;</span> <span class="cp">%&gt;</span>
</pre></div>
</div>


<p>С другой стороны, так как мы ожидаем, что Gravatar будет использоваться в нескольких местах нашего приложения, вставлять класс повсеместно вручную было бы повторением. Лучше сделать вспомогательный метод для ликвидации этого дублирования в зародыше.</p>

<p>Это может напомнить вам  ситуацию с повторением в базовом заголовке сайта (“Ruby on Rails Tutorial Sample App”), которую мы решили с <code>title</code> помощником в Application helper (<a class="ref" href="rails-flavored-ruby#code:title_helper">Листинг&nbsp;4.2</a>). Решение здесь аналогично; так как Gravatars естественным образом связаны с пользователями, мы определим <code>gravatar_for</code> метод в Users helper. (Users helpers выбран вместо Application helper только для концептуального удобства; Rails делает все помощники доступными во всех представлениях.)  результатом будет сокращение кода представления</p>

<div class="code"><div class="highlight"><pre><span class="cp">&lt;%=</span> <span class="n">gravatar_for</span> <span class="vi">@user</span> <span class="cp">%&gt;</span>
</pre></div>
</div>


<p><code>gravatar_for</code> помощник должен принимать объект <code>user</code> а затем передавать некоторые дефолтные параметры помощнику <code>gravatar_image_tag</code>. Реализация представлена в <a class="ref" href="modeling-and-viewing-users-two#code:gravatar_for_helper">Листинге&nbsp;7.23</a>.</p>

<div class="label" id="code:gravatar_for_helper"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.23.</span> <span class="description">Определение метода <code>gravatar_for</code> хелпер. <br /> <code>app/helpers/users_helper.rb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="k">module</span> <span class="nn">UsersHelper</span>

  <span class="k">def</span> <span class="nf">gravatar_for</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:size</span> <span class="o">=&gt;</span> <span class="mi">50</span> <span class="p">})</span>
    <span class="n">gravatar_image_tag</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">email</span><span class="o">.</span><span class="n">downcase</span><span class="p">,</span> <span class="ss">:alt</span> <span class="o">=&gt;</span> <span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                            <span class="ss">:class</span> <span class="o">=&gt;</span> <span class="s1">&#39;gravatar&#39;</span><span class="p">,</span>
                                            <span class="ss">:gravatar</span> <span class="o">=&gt;</span> <span class="n">options</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div></div>


<p>Первый аргумент в вызове <code>gravatar_image_tag</code> передает строчную версию пользовательского email адреса (используя метод <code>downcase</code>).<sup class="footnote" id="fnref:7.22"><a href="#fn:7.22">22</a></sup> Затем первая опция  <code>gravatar_image_tag</code> присваивает пользовательское имя атрибуту <code>alt</code> тега <code>img</code> (который отображается в устройствах не показывающих изображения), в то время как вторая опция устанавливает CSS класс получившегося Gravatar. Третья опция передает хэш <code>options</code> используя ключ <code>:gravatar</code>, который (в соответствии с <a href="http://github.com/mdeering/gravatar_image_tag"><tt>gravatar_image_tag</tt> гем документацией</a>) устанавливает (или добавляет) опции для для <code>gravatar_image_tag</code>. Отметьте, что определение функции устанавливает <em>дефолтную опцию</em><sup class="footnote" id="fnref:7.23"><a href="#fn:7.23">23</a></sup> для размера Gravatar<sup class="footnote" id="fnref:7.24"><a href="#fn:7.24">24</a></sup> используя</p>

<div class="code"><div class="highlight"><pre><span class="n">option</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:size</span> <span class="o">=&gt;</span> <span class="mi">50</span> <span class="p">}</span>
</pre></div>
</div>


<p>Что устанавливает дефолтный размер Gravatar <tt>50x50</tt>, а также позволяет переопределить размер по умолчанию с помощью кода</p>

<div class="code"><div class="highlight"><pre><span class="cp">&lt;%=</span> <span class="n">gravatar_for</span> <span class="vi">@user</span><span class="p">,</span> <span class="ss">:size</span> <span class="o">=&gt;</span> <span class="mi">30</span> <span class="cp">%&gt;</span>
</pre></div>
</div>


<p>Если мы сейчас обновим user show шаблон с кодом из <a class="ref" href="modeling-and-viewing-users-two#code:user_show_gravatar_for">Листинга&nbsp;7.24</a>, страница показывающая пользователя будет выглядеть как в <a class="ref" href="modeling-and-viewing-users-two#fig:user_show_gravatar_for">Рис.&nbsp;7.6</a>. И так как <code>gravatar_for</code> помощник назначает <code>img</code> тегу класс <code>"gravatar"</code>, тесты из <a class="ref" href="modeling-and-viewing-users-two#code:user_show_tests">Листинга&nbsp;7.18</a> теперь должны пройти.</p>

<div class="label" id="code:user_show_gravatar_for"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.24.</span> <span class="description">Обновление user show шаблона для использования <code>gravatar_for</code>. <br /> <code>app/views/users/show.html.erb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="nt">&lt;h1&gt;</span>
  <span class="cp">&lt;%=</span> <span class="n">gravatar_for</span> <span class="vi">@user</span> <span class="cp">%&gt;</span>
  <span class="cp">&lt;%=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">name</span> <span class="cp">%&gt;</span>
<span class="nt">&lt;/h1&gt;</span>
</pre></div>
</div></div>




<div class="label" id="fig:user_show_gravatar_for"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/user_show_gravatar_for.png" alt="user_show_gravatar_for" /></span></div><div class="caption"><span class="header">Рисунок  7.6: </span><span class="description">Страница показывающая пользователя с <code>gravatar_for</code>.&nbsp;<a href="http://railstutorial.org/images/figures/user_show_gravatar_for-full.png">(полный размер)</a></span></div></div>




<div class="label" id="sec:a_user_sidebar"></div>


<h3><a id="sec:7.3.3" href="modeling-and-viewing-users-two#sec:a_user_sidebar" class="heading"><span class="number">7.3.3</span> Боковая панель пользователя</a></h3>


<p>Хотя наши тесты в настоящее время проходят, и страница пользователя значительно улучшилась, все же хорошо бы ее еще немного отполировать. В <a class="ref" href="modeling-and-viewing-users-two#code:user_show_with_sidebar">Листинге&nbsp;7.25</a>, у нас есть  таблица в <code>table</code> теге с одной строкой (<code>tr</code>) и двумя ячейками (<code>td</code>).<sup class="footnote" id="fnref:7.25"><a href="#fn:7.25">25</a></sup></p>

<div class="label" id="code:user_show_with_sidebar"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.25.</span> <span class="description">Добавление сайдбара к user <code>show</code> представлению. <br /> <code>app/views/users/show.html.erb</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="nt">&lt;table</span> <span class="na">class=</span><span class="s">&quot;profile&quot;</span> <span class="na">summary=</span><span class="s">&quot;Profile information&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;tr&gt;</span>
    <span class="nt">&lt;td</span> <span class="na">class=</span><span class="s">&quot;main&quot;</span><span class="nt">&gt;</span>
      <span class="nt">&lt;h1&gt;</span>
        <span class="cp">&lt;%=</span> <span class="n">gravatar_for</span> <span class="vi">@user</span> <span class="cp">%&gt;</span>
        <span class="cp">&lt;%=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">name</span> <span class="cp">%&gt;</span>
      <span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;td</span> <span class="na">class=</span><span class="s">&quot;sidebar round&quot;</span><span class="nt">&gt;</span>
      <span class="nt">&lt;strong&gt;</span>Name<span class="nt">&lt;/strong&gt;</span> <span class="cp">&lt;%=</span> <span class="vi">@user</span><span class="o">.</span><span class="n">name</span> <span class="cp">%&gt;</span><span class="nt">&lt;br</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;strong&gt;</span>URL<span class="nt">&lt;/strong&gt;</span>  <span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="n">user_path</span><span class="p">(</span><span class="vi">@user</span><span class="p">),</span> <span class="vi">@user</span> <span class="cp">%&gt;</span>
    <span class="nt">&lt;/td&gt;</span>
  <span class="nt">&lt;/tr&gt;</span>
<span class="nt">&lt;/table&gt;</span>
</pre></div>
</div></div>


<p>Здесь мы использовали HTML тег перевода строки&nbsp;<code>&lt;br /&gt;</code> чтобы разделить имя пользователя и URL. Также обратите внимание на использование <code>user_path</code> для создания кликабельной ссылки позволяющей пользователям легко обмениваться URL своих профайлов. Это лишь один из многих именованных маршрутов (<a class="ref" href="filling-in-the-layout#sec:rails_routes">Раздел&nbsp;5.2.2</a>) связанных с ресурсом User (<a class="ref" href="modeling-and-viewing-users-one#code:users_resource">Листинг&nbsp;6.26</a>); мы увидим много больше в следующих главах. Код</p>

<div class="code"><div class="highlight"><pre><span class="n">user_path</span><span class="p">(</span><span class="vi">@user</span><span class="p">)</span>
</pre></div>
</div>


<p>возвращает путь к пользователю, в данном случае <tt>/users/1</tt>. Связанный код</p>

<div class="code"><div class="highlight"><pre><span class="n">user_url</span><span class="p">(</span><span class="vi">@user</span><span class="p">)</span>
</pre></div>
</div>


<p>просто возвращает весь URL, <tt>http://localhost:3000/users/1</tt>. (Сравните с маршрутами созданными в <a class="ref" href="filling-in-the-layout#sec:rails_routes">Разделе&nbsp;5.2.2</a>.) Оба примера именнованных маршрутов созданы ресурсом пользователей в <a class="ref" href="modeling-and-viewing-users-one#code:users_resource">Листинг&nbsp;6.26</a>; Листинге&nbsp;6.26</a>; список всех именованных маршрутов представлен в <a class="ref" href="modeling-and-viewing-users-two#table:named_routes">Таблице&nbsp;7.1</a>.</p>

<div class="label" id="table:named_routes"></div>


<div class="table"><div class="center"><table class="tabular"><tr><th class="align_left"><strong>Именованный маршрут</strong></th><th class="align_left"><strong>Путь</strong></th></tr><tr class="top_bar"><td class="align_left"><code>users_path</code></td><td class="align_left"><tt>/users</tt></td></tr><tr><td class="align_left"><code>user_path(@user)</code></td><td class="align_left"><tt>/users/1</tt></td></tr><tr><td class="align_left"><code>new_user_path</code></td><td class="align_left"><tt>/users/new</tt></td></tr><tr><td class="align_left"><code>edit_user_path(@user)</code></td><td class="align_left"><tt>/users/1/edit</tt></td></tr><tr><td class="align_left"><code>users_url</code></td><td class="align_left"><tt>http://localhost:3000/users</tt></td></tr><tr><td class="align_left"><code>user_url(@user)</code></td><td class="align_left"><tt>http://localhost:3000/users/1</tt></td></tr><tr><td class="align_left"><code>new_user_url</code></td><td class="align_left"><tt>http://localhost:3000/users/new</tt></td></tr><tr><td class="align_left"><code>edit_user_url(@user)</code></td><td class="align_left"><tt>http://localhost:3000/users/1/edit</tt></td></tr></table></div><div class="caption"><span class="header">Таблица 7.1: </span><span class="description">Именованные маршруты обеспеченные ресурсом users в <a class="ref" href="modeling-and-viewing-users-one#code:users_resource">Листинге&nbsp;6.26</a>.  </span></div></div>


<p>Отметим, что в</p>

<div class="code"><div class="highlight"><pre><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="n">user_path</span><span class="p">(</span><span class="vi">@user</span><span class="p">),</span> <span class="vi">@user</span> <span class="cp">%&gt;</span>
</pre></div>
</div>


<p><code>user_path(@user)</code> это <em>текст</em> ссылки, в то время как адрес это просто <code>@user</code>. В контексте <code>link_to</code>, Rails преобразует <code>@user</code> в соответствующий URL; другими словами, код выше эквивалентен коду</p>

<div class="code"><div class="highlight"><pre><span class="cp">&lt;%=</span> <span class="n">link_to</span> <span class="n">user_path</span><span class="p">(</span><span class="vi">@user</span><span class="p">),</span> <span class="n">user_path</span><span class="p">(</span><span class="vi">@user</span><span class="p">)</span> <span class="cp">%&gt;</span>
</pre></div>
</div>


<p>В любом случае хорошо работает, но, как и в <code>:id =&gt; @user</code> идиоме из <a class="ref" href="modeling-and-viewing-users-two#code:get_show_test">Листинга&nbsp;7.17</a>, использование просто <code>@user</code> это общепринятая Rails конвенция. В обоих случаях, Embedded Ruby производит HTML</p>

<div class="code"><div class="highlight"><pre><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;/users/1&quot;</span><span class="nt">&gt;</span>/users/1<span class="nt">&lt;/a&gt;</span>
</pre></div>
</div>


<p>С HTML элементами и CSS классами, мы можем отстилить show страницу с CSS показанным в <a class="ref" href="modeling-and-viewing-users-two#code:sidebar_css">Листинге&nbsp;7.26</a>. Получившаяся страница показана на <a class="ref" href="modeling-and-viewing-users-two#fig:user_show_sidebar_css">Рис.&nbsp;7.7</a>.</p>

<div class="label" id="code:sidebar_css"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.26.</span> <span class="description">CSS для стиля страницы показывающей пользователя, включающий сайдбар. <br /> <code>public/stylesheets/custom.css</code></span>
</div>
<div class="code"><div class="highlight"><pre><span class="o">.</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="c">/* User show page */</span>

<span class="nt">table</span><span class="nc">.profile</span> <span class="p">{</span>
  <span class="k">width</span><span class="o">:</span> <span class="m">100%</span><span class="p">;</span>
  <span class="k">margin-bottom</span><span class="o">:</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">td</span><span class="nc">.main</span> <span class="p">{</span>
  <span class="k">width</span><span class="o">:</span> <span class="m">70%</span><span class="p">;</span>
  <span class="k">padding</span><span class="o">:</span> <span class="m">1em</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">td</span><span class="nc">.sidebar</span> <span class="p">{</span>
  <span class="k">width</span><span class="o">:</span> <span class="m">30%</span><span class="p">;</span>
  <span class="k">padding</span><span class="o">:</span> <span class="m">1em</span><span class="p">;</span>
  <span class="k">vertical-align</span><span class="o">:</span> <span class="k">top</span><span class="p">;</span>
  <span class="k">background</span><span class="o">:</span> <span class="m">#ffc</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.profile</span> <span class="nt">img</span><span class="nc">.gravatar</span> <span class="p">{</span>
  <span class="k">border</span><span class="o">:</span> <span class="m">1px</span> <span class="k">solid</span> <span class="m">#999</span><span class="p">;</span>
  <span class="k">margin-bottom</span><span class="o">:</span> <span class="m">-15px</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div></div>




<div class="label" id="fig:user_show_sidebar_css"></div>


<div class="figure"><div class="center"><span class="graphic"><img src="/images/figures/user_show_sidebar_css.png" alt="user_show_sidebar_css" /></span></div><div class="caption"><span class="header">Рисунок  7.7: </span><span class="description">Страница показывающая пользователя <a href="http://localhost:3000/users/1"><tt>/users/1</tt></a> с сайдбаром и CSS.&nbsp;<a href="http://railstutorial.org/images/figures/user_show_sidebar_css-full.png">(полный размер)</a></span></div></div>




<h2><a id="sec:7.4" href="modeling-and-viewing-users-two#sec:7.4" class="heading"><span class="number">7.4</span> Заключение</a></h2>


<p>В этой главе мы фактически закончили модель User, так что мы теперь полностью готовы регистрировать новых пользователей и позволять им безопасно входить с комбинацией электронной почты и пароля. Кроме того, у нас есть хорошая первая часть страницы профиля пользователя, так что после входа пользователям есть куда пойти.</p>

<h3><a id="sec:7.4.1" href="modeling-and-viewing-users-two#sec:7.4.1" class="heading"><span class="number">7.4.1</span> Git commit</a></h3>


<p>Прежде чем двигаться дальше, мы должны завершить цикл Git, начатый во введении <a class="ref" href="modeling-and-viewing-users-one#top">Главы&nbsp;6</a> сделав финальную фиксацию для ветки <code>modeling-users</code> и объединив ее с <code>master</code>.<sup class="footnote" id="fnref:7.26"><a href="#fn:7.26">26</a></sup> Во-первых, убедимся, что мы находимся на веткe <code>modeling-users</code>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> git branch
<span class="go">  master</span>
<span class="go">* modeling-users</span>
</pre></div>
</div>


<p>Как отмечалось в <a class="ref" href="beginning#sec:git_branch">Разделе&nbsp;1.3.5.1</a>, звездочка здесь идентифицирует текущую ветку, так что мы действительно готовы к фиксации  и объединению:<sup class="footnote" id="fnref:7.27"><a href="#fn:7.27">27</a></sup></p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> git add .
<span class="gp">$</span> git commit -m <span class="s2">&quot;User model with passwords, and user show page&quot;</span>
<span class="gp">$</span> git checkout master
<span class="gp">$</span> git merge modeling-users
</pre></div>
</div>


<div class="label" id="sec:heroku_deploy"></div>


<h3><a id="sec:7.4.2" href="modeling-and-viewing-users-two#sec:heroku_deploy" class="heading"><span class="number">7.4.2</span> Развертывание Heroku</a></h3>


<p>Если вы разворачивали ваш пример приложения на Heroku, вы можете отправить его в этой точке:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> git push heroku
</pre></div>
</div>


<p>Затем мигрировать базу данных на удаленном сервере, используя команду <code>heroku</code>:</p>

<div class="code"><div class="highlight"><pre><span class="gp">$</span> heroku rake db:migrate
</pre></div>
</div>


<p>Теперь, если вы хотите создать образец пользователя на Heroku, вы можете использовать Heroku консоль:</p>

<div class="code"><div class="highlight"><pre><span class="go">$ heroku console</span>
<span class="gp">&gt;&gt; </span><span class="no">User</span><span class="o">.</span><span class="n">create!</span><span class="p">(</span><span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">&quot;Example User&quot;</span><span class="p">,</span> <span class="ss">:email</span> <span class="o">=&gt;</span> <span class="s2">&quot;user@example.com&quot;</span><span class="p">,</span>
<span class="gp">?&gt; </span>             <span class="ss">:password</span> <span class="o">=&gt;</span> <span class="s2">&quot;foobar&quot;</span><span class="p">,</span> <span class="ss">:password_confirmation</span> <span class="o">=&gt;</span> <span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
</pre></div>
</div>




<div class="label" id="sec:more_modeling_users_exercises"></div>


<h2><a id="sec:7.5" href="modeling-and-viewing-users-two#sec:more_modeling_users_exercises" class="heading"><span class="number">7.5</span> Упражнения</a></h2>




<ol>
<li>Скопируйте каждый из вариантов метода <code>authenticate</code> из <a class="ref" href="modeling-and-viewing-users-two#code:authenticate_variant_1">Листинга&nbsp;7.27</a> по <a class="ref" href="modeling-and-viewing-users-two#code:authenticate_variant_5">Листинг&nbsp;7.31</a> в вашу модель User, и проверьте, что они корректны, запустив ваш набор тестов. </li>

<li>Последний пример <code>authenticate</code> (<a class="ref" href="modeling-and-viewing-users-two#code:authenticate_variant_5">Листинг&nbsp;7.31</a>) это практически вызов. Поэкспериментируйте в консоли, чтобы увидеть, сможете ли вы понять, как это работает.</li>

<li>Как бы вы заставили работать Gravatar хелпер <code>gravatar_for</code> если бы наша модель User использовала <code>email_address</code> вместо <code>email</code> для отображения  email адреса?</li>

</ol>




<div class="label" id="code:authenticate_variant_1"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.27.</span> <span class="description">Метод <code>authenticate</code> с <code>User</code> вместо <code>self</code>.</span>
</div>
<div class="code"><div class="highlight"><pre>  <span class="k">def</span> <span class="nc">User</span><span class="o">.</span><span class="nf">authenticate</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">submitted_password</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">find_by_email</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
    <span class="k">return</span> <span class="kp">nil</span>  <span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">nil?</span>
    <span class="k">return</span> <span class="n">user</span> <span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">has_password?</span><span class="p">(</span><span class="n">submitted_password</span><span class="p">)</span>
  <span class="k">end</span>
</pre></div>
</div></div>




<div class="label" id="code:authenticate_variant_2"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.28.</span> <span class="description">Метод <code>authenticate</code> с явным третьим <code>return</code>.</span>
</div>
<div class="code"><div class="highlight"><pre>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">authenticate</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">submitted_password</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">find_by_email</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
    <span class="k">return</span> <span class="kp">nil</span>  <span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">nil?</span>
    <span class="k">return</span> <span class="n">user</span> <span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">has_password?</span><span class="p">(</span><span class="n">submitted_password</span><span class="p">)</span>
    <span class="k">return</span> <span class="kp">nil</span>
  <span class="k">end</span>
</pre></div>
</div></div>




<div class="label" id="code:authenticate_variant_3"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.29.</span> <span class="description">Метод <code>authenticate</code> использующий <code>if</code> выражение.</span>
</div>
<div class="code"><div class="highlight"><pre>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">authenticate</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">submitted_password</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">find_by_email</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">nil?</span>
      <span class="kp">nil</span>
    <span class="k">elsif</span> <span class="n">user</span><span class="o">.</span><span class="n">has_password?</span><span class="p">(</span><span class="n">submitted_password</span><span class="p">)</span>
      <span class="n">user</span>
    <span class="k">else</span>
      <span class="kp">nil</span>
    <span class="k">end</span>
  <span class="k">end</span>
</pre></div>
</div></div>




<div class="label" id="code:authenticate_variant_4"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.30.</span> <span class="description">Метод <code>authenticate</code> использующий <code>if</code> выражение и неявное возвращение.</span>
</div>
<div class="code"><div class="highlight"><pre>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">authenticate</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">submitted_password</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">find_by_email</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">nil?</span>
      <span class="kp">nil</span>
    <span class="k">elsif</span> <span class="n">user</span><span class="o">.</span><span class="n">has_password?</span><span class="p">(</span><span class="n">submitted_password</span><span class="p">)</span>
      <span class="n">user</span>
    <span class="k">end</span>
  <span class="k">end</span>
</pre></div>
</div></div>




<div class="label" id="code:authenticate_variant_5"></div>


<div class="codelisting">
<div class="listing"><span class="header">Листинг 7.31.</span> <span class="description">Метод <code>authenticate</code> использующий тернарный оператор.</span>
</div>
<div class="code"><div class="highlight"><pre>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">authenticate</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">submitted_password</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">find_by_email</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="o">.</span><span class="n">has_password?</span><span class="p">(</span><span class="n">submitted_password</span><span class="p">)</span> <span class="p">?</span> <span class="n">user</span> <span class="p">:</span> <span class="kp">nil</span>
  <span class="k">end</span>
</pre></div>
</div></div>




<div class="navigation">  <a class="prev_page" href="modeling-and-viewing-users-one#top">
    &laquo;&nbsp;<span class="number">Глава 6</span> Моделирование и просмотр пользователей, часть I
  </a>
  <a class="next_page" href="sign-up#top">
    <span class="number">Глава 8</span> Регистрация&nbsp;&raquo;
  </a>
</div><div class="footnotes">
<ol>
<li id="fn:7.1">Мы видели диапазоны ранее в <a class="ref" href="rails-flavored-ruby#sec:arrays_and_ranges">Разделе&nbsp;4.3.1</a>.&nbsp;<a class="arrow" href="#fnref:7.1">&uarr;</a></li>
<li id="fn:7.2">За более подробной информацией о видах обратных вызовов поддерживаемых Active Record, обращайтесь к к статье <a  rel="nofollow" href="http://www.rusrails.ru/active-record-validations-and-callbacks">Валидации и колбэки Active Record</a> на сайте <a  rel="nofollow" href="http://www.rusrails.ru">http://www.rusrails.ru</a>&nbsp;<a class="arrow" href="#fnref:7.2">&uarr;</a></li>
<li id="fn:7.3">Дополнительный отступ это типографское напоминание о том, что мы находимся в приватном разделе; в противном случае можно легко пропустить <code>private</code> ключевое слово и запутаться при попытке доступа к приватному методу, думая что он публичный. Я думал, что дополнительные отступы это просто глупая конвенция, пока я не убил час на эту проблему пару лет назад. Теперь я добавляю дополнительные отступы&hellip;&nbsp;<a class="arrow" href="#fnref:7.3">&uarr;</a></li>
<li id="fn:7.4">В Ruby есть тесно связаное ключевое слово <code>protected</code> чем-то отличающееся от <code>private</code>. Насколько я могу судить, единственный повод узнать разницу между ними это то, что у вас будет козырь на собеседовании, когда вас спросят “В Ruby, в чем разница между  <code>private</code> и <code>protected</code>?” Но вы действительно хотите работать в компании, которая задает такие хромые вопросы на собеседовании? В своем выступлении на RubyConf в 2008, Dave Thomas (автор <em>Programming Ruby</em>) предлагал ликвидировать <code>protected</code> в будущих версиях Ruby, и я полностью с ним согласен. Просто используйте <code>private</code> и все будет хорошо.&nbsp;<a class="arrow" href="#fnref:7.4">&uarr;</a></li>
<li id="fn:7.5">Мне стыдно признаться, что именно так мы реализовывали пароли в <em>RailsSpace</em>. Считайте этот раздел моим покаянием.&nbsp;<a class="arrow" href="#fnref:7.5">&uarr;</a></li>
<li id="fn:7.6">The alert reader may notice that none of what we do in this section <em>requires</em> encryption, but, once we develop some of the theory of secure passwords and write a basic implementation (<a class="ref" href="modeling-and-viewing-users-two#sec:secure_password_theory">Раздел&nbsp;7.2.2</a>), the only way for the <code>has_password?</code> method to work properly is for all the encryption machinery to work properly as well. (??)&nbsp;<a class="arrow" href="#fnref:7.6">&uarr;</a></li>
<li id="fn:7.7">В моей установке, строка <code>require ’digest’</code> не является необходимой, но несколько читателей сообщили о получении <code>NameError</code> исключения, если они не включали его явно. Это не вредит в любом случае, поэтому я включил явное <code>require</code> на всякий случай.&nbsp;<a class="arrow" href="#fnref:7.7">&uarr;</a></li>
<li id="fn:7.8">Технически, атака с использованием радужных таблиц все же может добиться успеха, но использование соленого хэша делает ее вычислительно невозможной (сложной?) (computationally unfeasible)(??).&nbsp;<a class="arrow" href="#fnref:7.8">&uarr;</a></li>
<li id="fn:7.9">Как отмечалось в  <a class="ref" href="modeling-and-viewing-users-two#sec:secure_password_theory">Разделе&nbsp;7.2.2</a>, строка с явным <code>require ’digest’</code> необязательна на некоторых системах, но ее включение не навредит.&nbsp;<a class="arrow" href="#fnref:7.9">&uarr;</a></li>
<li id="fn:7.10">В прошлых версиях Rails, мы могли бы использовать обратный вызов <code>after_validation_before_create</code> для установки соли но он был ликвидирован в Rails&nbsp;3. Между тем, мы не можем использовать обратный вызов <code>before_create</code> потому что он выполняется <em>после</em> обратного вызова <code>before_save</code> и обратному вызову <code>before_save</code> нужна соль.&nbsp;<a class="arrow" href="#fnref:7.10">&uarr;</a></li>
<li id="fn:7.11">Напомним, из <a class="ref" href="modeling-and-viewing-users-one#sidebar:database_indices">Блока&nbsp;6.2</a> что <em>индекс</em> на <code>email</code> столбце гарантирует что этот поиск является эффективным.&nbsp;<a class="arrow" href="#fnref:7.11">&uarr;</a></li>
<li id="fn:7.12">Мы планируем добавить еще пару атрибутов (один для идентификации административных пользователей и один для функции "запомнить меня"), но они не являются строго необходимыми. Все <em>необходимые</em> атрибуты пользователей в настоящее время определены.&nbsp;<a class="arrow" href="#fnref:7.12">&uarr;</a></li>
<li id="fn:7.13">Многие опытные Rails програмисты находят этот фабричный подход более гибким нежели <em>fixtures</em>, которые Rails использует по умолчанию но могут быть хрупкими и сложными в обслуживании.&nbsp;<a class="arrow" href="#fnref:7.13">&uarr;</a></li>
<li id="fn:7.14">Предположительно, &ldquo;Factory Girl&rdquo; это ссылка на <a href="http://www.imdb.com/title/tt0432402/">фильм с одноименным названием</a>.&nbsp;<a class="arrow" href="#fnref:7.14">&uarr;</a></li>
<li id="fn:7.15">Я использовал <code>get &rsquo;new&rsquo;</code> в <a class="ref" href="filling-in-the-layout#code:get_new_user_spec">Листинге&nbsp;5.24</a> и последующих тестах для <code>new</code> действия  поскольку на тот момент мы еще не сталкивались с идеей стандартных REST действий. Я переключусь на <code>get :new</code> в будущих тестах.&nbsp;<a class="arrow" href="#fnref:7.15">&uarr;</a></li>
<li id="fn:7.16">Он делает это путем вызова <code>to_param</code> метода на переменной <code>@user</code>.<a class="arrow" href="#fnref:7.16">&uarr;</a></li>
<li id="fn:7.17">Это не всегда хорошая идея  делать HTML тесты настолько специфичными, поскольку мы не всегда хотим ограничивать макет HTML настолько сильно. Не стесняйтесь экспериментировать и найдите нужный уровень детализации для ваших проектов.&nbsp;<a class="arrow" href="#fnref:7.17">&uarr;</a></li>
<li id="fn:7.18">Вместо этого, если вам нужен <em>немаскированный</em> текст, вы должны использовать  метод <code>raw</code>, например <tt class="verb">&lt;%= raw @title %&gt;</tt>.&nbsp;<a class="arrow" href="#fnref:7.18">&uarr;</a></li>
<li id="fn:7.19">Gravatar был создан Tom Preston-Werner, одним из основателей <a href="http://github.com/">GitHub</a>, и был приобретен и масштабирован <a href="http://automattic.com/">Automattic</a> (более известные как создатели  <a href="http://wordpress.com/">WordPress</a>).&nbsp;<a class="arrow" href="#fnref:7.19">&uarr;</a></li>
<li id="fn:7.20">В индуизме, аватар это форма проявление божества в человеке или животном. В более широком смысле термин <em>avatar</em> обычно используется для обозначения  персонализации пользователя, особенно в виртуальной среде. Но вы видели фильм, так что вы уже знаете об этом.&nbsp;<a class="arrow" href="#fnref:7.20">&uarr;</a></li>
<li id="fn:7.21">Если вашему приложению требуется обработка изображений или загрузка других файлов, обратите внимание на <a href="http://github.com/thoughtbot/paperclip">Paperclip</a> Как и Factory Girl, Paperclip предоставляется <a href="http://thoughtbot.com/">thoughtbot</a>. (Хотя я знаю несколько человек оттуда, у меня нет личной заинтересованности в продвижении thoughtbot; Они просто делают хорошее программное обеспечение.)&nbsp;<a class="arrow" href="#fnref:7.21">&uarr;</a></li>
<li id="fn:7.22">Благодарю анонимного читателя, который отметил, что плагин Gravatar чувствителен к регистру в этом контексте.&nbsp;<a class="arrow" href="#fnref:7.22">&uarr;</a></li>
<li id="fn:7.23">На самом деле есть возможность сбросить дефолтный размер в файле конфигурации, но я считаю  этот способ более чистым.&nbsp;<a class="arrow" href="#fnref:7.23">&uarr;</a></li>
<li id="fn:7.24">Gravatars квадратные, поэтому единственный параметр определяет их размер однозначно.&nbsp;<a class="arrow" href="#fnref:7.24">&uarr;</a></li>
<li id="fn:7.25">Если кто либо обругает вас за использование, о ужас, <em>таблицы для разметки</em>, попросите этого умника посмотреть на боковую панель Твиттера в Firebug и сказать вам что он видит. В самом деле, вы обнаружите что, в то время как “семантичная разметка” использующая <code>div</code>ы и <code>span</code>ы получает все большее распространение, практически все сайты прибегают к таблицам для разметки при случае. В данном случае, получение вертикального  выравнивания только справа <em>намного</em> легче реализовать с помощью таблицы.&nbsp;<a class="arrow" href="#fnref:7.25">&uarr;</a></li>
<li id="fn:7.26">Обычно, я рекомендую делать более частые, меньшие фиксации, но частые Git фиксации на протяжении всего учебника будет трудно поддерживать и это будет разбивать поток обсуждения.&nbsp;<a class="arrow" href="#fnref:7.26">&uarr;</a></li>
<li id="fn:7.27">Если вы <em>не</em> на нужной ветке, запустите <code>git checkout modeling-users</code> перед продолжением.&nbsp;<a class="arrow" href="#fnref:7.27">&uarr;</a></li>
</ol>
</div>

